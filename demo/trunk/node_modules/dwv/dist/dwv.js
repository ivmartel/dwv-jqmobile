/*! dwv 0.31.2 2023-05-07 12:03:47 */
// Inspired from umdjs
// See https://github.com/umdjs/umd/blob/master/templates/returnExports.js
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([
            'jszip',
            'konva',
            'magic-wand-tool'
        ], factory);
    } else if (typeof module === 'object' && module.exports) {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.

        // Konva: requires 'canvas'
        module.exports = factory(
            require('jszip'),
            require('konva/cmj'),
            require('magic-wand-tool')
        );
    } else {
        // Browser globals (root is window)
        root.dwv = factory(
            root.JSZip,
            root.Konva,
            root.MagicWand
        );
    }
}(this, function (
    JSZip,
    Konva,
    MagicWand) {

    // similar to what browserify does but reversed
    // https://www.contentful.com/blog/2017/01/17/the-global-object-in-javascript/
    var window = typeof window !== 'undefined' ?
      window : typeof self !== 'undefined' ?
      self : typeof global !== 'undefined' ?
      global : {};

    // if it has a default, treat it as ESM
    var isEsmModule = function (mod) {
      return typeof mod !== 'undefined' &&
        typeof mod.default !== 'undefined';
    }
    // Konva (>=v8) comes as a module, see #1044
    if (isEsmModule(Konva)) {
      Konva = Konva.default;
    }

/** @namespace */
var dwv = dwv || {};

/**
 * Main application class.
 *
 * @class
 * @example
 * // create the dwv app
 * var app = new dwv.App();
 * // initialise
 * app.init({
 *   dataViewConfigs: {'*': [{divId: 'layerGroup0'}]}
 * });
 * // load dicom data
 * app.loadURLs([
 *   'https://raw.githubusercontent.com/ivmartel/dwv/master/tests/data/bbmri-53323851.dcm'
 * ]);
 */
dwv.App = function () {
  // closure to self
  var self = this;

  // app options
  var options = null;

  // data controller
  var dataController = null;

  // toolbox controller
  var toolboxController = null;

  // load controller
  var loadController = null;

  // stage
  var stage = null;

  // UndoStack
  var undoStack = null;

  // Generic style
  var style = new dwv.gui.Style();

  /**
   * Listener handler.
   *
   * @type {object}
   * @private
   */
  var listenerHandler = new dwv.utils.ListenerHandler();

  /**
   * Get the image.
   *
   * @param {number} index The data index.
   * @returns {dwv.image.Image} The associated image.
   */
  this.getImage = function (index) {
    return dataController.get(index).image;
  };
  /**
   * Get the last loaded image.
   *
   * @returns {dwv.image.Image} The image.
   */
  this.getLastImage = function () {
    return dataController.get(dataController.length() - 1).image;
  };
  /**
   * Set the image at the given index.
   *
   * @param {number} index The data index.
   * @param {dwv.image.Image} img The associated image.
   */
  this.setImage = function (index, img) {
    dataController.setImage(index, img);
  };
  /**
   * Set the last image.
   *
   * @param {dwv.image.Image} img The associated image.
   */
  this.setLastImage = function (img) {
    dataController.setImage(dataController.length() - 1, img);
  };

  /**
   * Add a new image.
   *
   * @param {dwv.image.Image} image The new image.
   * @param {object} meta The image meta.
   * @returns {number} The new image id.
   */
  this.addNewImage = function (image, meta) {
    var id = dataController.length();

    // load start event
    fireEvent({
      type: 'loadstart',
      loadtype: 'image',
      source: 'internal',
      loadid: id
    });

    // add image to data controller
    dataController.addNew(id, image, meta);

    // load item event
    fireEvent({
      type: 'loaditem',
      loadtype: 'image',
      data: meta,
      source: 'internal',
      loadid: id,
      isfirstitem: true
    });

    // optional render
    if (options.viewOnFirstLoadItem) {
      this.render(id);
    }

    // load events
    fireEvent({
      type: 'load',
      loadtype: 'image',
      source: 'internal',
      loadid: id
    });
    fireEvent({
      type: 'loadend',
      loadtype: 'image',
      source: 'internal',
      loadid: id
    });

    return id;
  };

  /**
   * Get the meta data.
   *
   * @param {number} index The data index.
   * @returns {object} The list of meta data.
   */
  this.getMetaData = function (index) {
    return dataController.get(index).meta;
  };

  /**
   * Get the number of loaded data.
   *
   * @returns {number} The number.
   */
  this.getNumberOfLoadedData = function () {
    return dataController.length();
  };

  /**
   * Can the data be scrolled?
   *
   * @returns {boolean} True if the data has a third dimension greater than one.
   */
  this.canScroll = function () {
    var viewLayer = stage.getActiveLayerGroup().getActiveViewLayer();
    var controller = viewLayer.getViewController();
    return controller.canScroll();
  };

  /**
   * Can window and level be applied to the data?
   *
   * @returns {boolean} True if the data is monochrome.
   */
  this.canWindowLevel = function () {
    var viewLayer = stage.getActiveLayerGroup().getActiveViewLayer();
    var controller = viewLayer.getViewController();
    return controller.canWindowLevel();
  };

  /**
   * Get the layer scale on top of the base scale.
   *
   * @returns {object} The scale as {x,y}.
   */
  this.getAddedScale = function () {
    return stage.getActiveLayerGroup().getAddedScale();
  };

  /**
   * Get the base scale.
   *
   * @returns {object} The scale as {x,y}.
   */
  this.getBaseScale = function () {
    return stage.getActiveLayerGroup().getBaseScale();
  };

  /**
   * Get the layer offset.
   *
   * @returns {object} The offset.
   */
  this.getOffset = function () {
    return stage.getActiveLayerGroup().getOffset();
  };

  /**
   * Get the toolbox controller.
   *
   * @returns {object} The controller.
   */
  this.getToolboxController = function () {
    return toolboxController;
  };

  /**
   * Get the active layer group.
   * The layer is available after the first loaded item.
   *
   * @returns {dwv.gui.LayerGroup} The layer group.
   */
  this.getActiveLayerGroup = function () {
    return stage.getActiveLayerGroup();
  };

  /**
   * Get the view layers associated to a data index.
   * The layer are available after the first loaded item.
   *
   * @param {number} index The data index.
   * @returns {Array} The layers.
   */
  this.getViewLayersByDataIndex = function (index) {
    return stage.getViewLayersByDataIndex(index);
  };

  /**
   * Get the draw layers associated to a data index.
   * The layer are available after the first loaded item.
   *
   * @param {number} index The data index.
   * @returns {Array} The layers.
   */
  this.getDrawLayersByDataIndex = function (index) {
    return stage.getDrawLayersByDataIndex(index);
  };

  /**
   * Get a layer group by div id.
   * The layer is available after the first loaded item.
   *
   * @param {string} divId The div id.
   * @returns {dwv.gui.LayerGroup} The layer group.
   */
  this.getLayerGroupByDivId = function (divId) {
    return stage.getLayerGroupByDivId(divId);
  };

  /**
   * Get the number of layer groups.
   *
   * @returns {number} The number of groups.
   */
  this.getNumberOfLayerGroups = function () {
    return stage.getNumberOfLayerGroups();
  };

  /**
   * Get the app style.
   *
   * @returns {object} The app style.
   */
  this.getStyle = function () {
    return style;
  };

  /**
   * Add a command to the undo stack.
   *
   * @param {object} cmd The command to add.
   * @fires dwv.tool.UndoStack#undoadd
   */
  this.addToUndoStack = function (cmd) {
    if (undoStack !== null) {
      undoStack.add(cmd);
    }
  };

  /**
   * Initialise the application.
   *
   * @param {object} opt The application option with:
   * - `dataViewConfigs`: data indexed object containing the data view
   *   configurations in the form of a list of objects containing:
   *   - divId: the HTML div id
   *   - orientation: optional 'axial', 'coronal' or 'sagittal' orientation
   *     string (default undefined keeps the original slice order)
   * - `binders`: array of layerGroup binders
   * - `tools`: tool name indexed object containing individual tool
   *   configurations in the form of a list of objects containing:
   *   - options: array of tool options
   * - `viewOnFirstLoadItem`: boolean flag to trigger the first data render
   *   after the first loaded data or not
   * - `defaultCharacterSet`: the default chraracter set string used for DICOM
   *   parsing
   * @example
   * // create the dwv app
   * var app = new dwv.App();
   * // initialise
   * app.init({
   *   dataViewConfigs: {'*': [{divId: 'layerGroup0'}]},
   *   viewOnFirstLoadItem: false
   * });
   * // render button
   * var button = document.createElement('button');
   * button.id = 'render';
   * button.disabled = true;
   * button.appendChild(document.createTextNode('render'));
   * document.body.appendChild(button);
   * app.addEventListener('load', function () {
   *   var button = document.getElementById('render');
   *   button.disabled = false;
   *   button.onclick = function () {
   *     // render data #0
   *     app.render(0);
   *   };
   * });
   * // load dicom data
   * app.loadURLs([
   *   'https://raw.githubusercontent.com/ivmartel/dwv/master/tests/data/bbmri-53323851.dcm'
   * ]);
   */
  this.init = function (opt) {
    // store
    options = opt;
    // defaults
    if (typeof options.viewOnFirstLoadItem === 'undefined') {
      options.viewOnFirstLoadItem = true;
    }

    // undo stack
    undoStack = new dwv.tool.UndoStack();
    undoStack.addEventListener('undoadd', fireEvent);
    undoStack.addEventListener('undo', fireEvent);
    undoStack.addEventListener('redo', fireEvent);

    // tools
    if (options.tools && options.tools.length !== 0) {
      // setup the tool list
      var toolList = {};
      var keys = Object.keys(options.tools);
      for (var t = 0; t < keys.length; ++t) {
        var toolName = keys[t];
        var toolParams = options.tools[toolName];
        // find the tool in the dwv.tool namespace
        if (typeof dwv.tool[toolName] !== 'undefined') {
          // create tool instance
          toolList[toolName] = new dwv.tool[toolName](this);
          // register listeners
          if (typeof toolList[toolName].addEventListener !== 'undefined') {
            var names = toolList[toolName].getEventNames();
            for (var j = 0; j < names.length; ++j) {
              toolList[toolName].addEventListener(names[j], fireEvent);
            }
          }
          // tool options
          if (typeof toolParams.options !== 'undefined') {
            var type = 'raw';
            if (typeof toolList[toolName].getOptionsType !== 'undefined') {
              type = toolList[toolName].getOptionsType();
            }
            var toolOptions = toolParams.options;
            if (type === 'instance' ||
                type === 'factory') {
              toolOptions = {};
              for (var i = 0; i < toolParams.options.length; ++i) {
                var optionName = toolParams.options[i];
                var optionClassName = optionName;
                if (type === 'factory') {
                  optionClassName += 'Factory';
                }
                var toolNamespace = toolName.charAt(0).toLowerCase() +
                  toolName.slice(1);
                if (typeof dwv.tool[toolNamespace][optionClassName] !==
                  'undefined') {
                  toolOptions[optionName] =
                    dwv.tool[toolNamespace][optionClassName];
                } else {
                  dwv.logger.warn('Could not find option class for: ' +
                    optionName);
                }
              }
            }
            toolList[toolName].setOptions(toolOptions);
          }
        } else {
          dwv.logger.warn('Could not initialise unknown tool: ' + toolName);
        }
      }
      // add tools to the controller
      toolboxController = new dwv.ctrl.ToolboxController(toolList);
    }

    // create load controller
    loadController = new dwv.ctrl.LoadController(options.defaultCharacterSet);
    loadController.onloadstart = onloadstart;
    loadController.onprogress = onloadprogress;
    loadController.onloaditem = onloaditem;
    loadController.onload = onload;
    loadController.onloadend = onloadend;
    loadController.onerror = onloaderror;
    loadController.onabort = onloadabort;

    // create data controller
    dataController = new dwv.ctrl.DataController();
    // create stage
    stage = new dwv.gui.Stage();
    if (typeof options.binders !== 'undefined') {
      stage.setBinders(options.binders);
    }
  };

  /**
   * Get a HTML element associated to the application.
   *
   * @param {string} _name The name or id to find.
   * @returns {object} The found element or null.
   * @deprecated
   */
  this.getElement = function (_name) {
    return null;
  };

  /**
   * Reset the application.
   */
  this.reset = function () {
    // clear objects
    dataController.reset();
    stage.empty();
    // reset undo/redo
    if (undoStack) {
      undoStack = new dwv.tool.UndoStack();
      undoStack.addEventListener('undoadd', fireEvent);
      undoStack.addEventListener('undo', fireEvent);
      undoStack.addEventListener('redo', fireEvent);
    }
  };

  /**
   * Reset the layout of the application.
   */
  this.resetLayout = function () {
    stage.reset();
    stage.draw();
  };

  /**
   * Add an event listener to this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type, will be called with the fired event.
   */
  this.addEventListener = function (type, callback) {
    listenerHandler.add(type, callback);
  };

  /**
   * Remove an event listener from this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type.
   */
  this.removeEventListener = function (type, callback) {
    listenerHandler.remove(type, callback);
  };

  // load API [begin] -------------------------------------------------------

  /**
   * Load a list of files. Can be image files or a state file.
   *
   * @param {Array} files The list of files to load.
   * @fires dwv.App#loadstart
   * @fires dwv.App#loadprogress
   * @fires dwv.App#loaditem
   * @fires dwv.App#loadend
   * @fires dwv.App#error
   * @fires dwv.App#abort
   */
  this.loadFiles = function (files) {
    if (files.length === 0) {
      dwv.logger.warn('Ignoring empty input file list.');
      return;
    }
    loadController.loadFiles(files);
  };

  /**
   * Load a list of URLs. Can be image files or a state file.
   *
   * @param {Array} urls The list of urls to load.
   * @param {object} options The options object, can contain:
   *  - requestHeaders: an array of {name, value} to use as request headers
   *  - withCredentials: boolean xhr.withCredentials flag to pass to the request
   *  - batchSize: the size of the request url batch
   * @fires dwv.App#loadstart
   * @fires dwv.App#loadprogress
   * @fires dwv.App#loaditem
   * @fires dwv.App#loadend
   * @fires dwv.App#error
   * @fires dwv.App#abort
   */
  this.loadURLs = function (urls, options) {
    if (urls.length === 0) {
      dwv.logger.warn('Ignoring empty input url list.');
      return;
    }
    loadController.loadURLs(urls, options);
  };

  /**
   * Load a list of ArrayBuffers.
   *
   * @param {Array} data The list of ArrayBuffers to load
   *   in the form of [{name: "", filename: "", data: data}].
   * @fires dwv.App#loadstart
   * @fires dwv.App#loadprogress
   * @fires dwv.App#loaditem
   * @fires dwv.App#loadend
   * @fires dwv.App#error
   * @fires dwv.App#abort
   */
  this.loadImageObject = function (data) {
    loadController.loadImageObject(data);
  };

  /**
   * Abort the current load.
   */
  this.abortLoad = function () {
    loadController.abort();
  };

  // load API [end] ---------------------------------------------------------

  /**
   * Fit the display to the data of each layer group.
   * To be called once the image is loaded.
   */
  this.fitToContainer = function () {
    stage.syncLayerGroupScale();
  };

  /**
   * Init the Window/Level display
   */
  this.initWLDisplay = function () {
    var viewLayer = stage.getActiveLayerGroup().getActiveViewLayer();
    var controller = viewLayer.getViewController();
    controller.initialise();
  };

  /**
   * Get the layer group configuration from a data index.
   * Defaults to div id 'layerGroup' if no association object has been set.
   *
   * @param {number} dataIndex The data index.
   * @returns {Array} The list of associated configs.
   */
  function getViewConfigs(dataIndex) {
    // check options
    if (options.dataViewConfigs === null ||
      typeof options.dataViewConfigs === 'undefined') {
      throw new Error('No available data view configuration');
    }
    var configs = [];
    if (typeof options.dataViewConfigs['*'] !== 'undefined') {
      configs = options.dataViewConfigs['*'];
    } else if (typeof options.dataViewConfigs[dataIndex] !== 'undefined') {
      configs = options.dataViewConfigs[dataIndex];
    }
    return configs;
  }

  /**
   * Get the data view config.
   * Carefull, returns a reference, do not modify without resetting.
   *
   * @returns {object} The configuration list.
   */
  this.getDataViewConfig = function () {
    return options.dataViewConfigs;
  };

  /**
   * Set the data view configuration (see the init options for details).
   *
   * @param {object} configs The configuration list.
   */
  this.setDataViewConfig = function (configs) {
    // clean up
    stage.empty();
    // set new
    options.dataViewConfigs = configs;
    // create layer groups
    createLayerGroups(configs);
  };

  /**
   * Create layer groups according to a data view config:
   * adds them to stage and bind them.
   *
   * @param {object} dataViewConfigs The data view config.
   */
  function createLayerGroups(dataViewConfigs) {
    var dataKeys = Object.keys(dataViewConfigs);
    var divIds = [];
    for (var i = 0; i < dataKeys.length; ++i) {
      var dataConfigs = dataViewConfigs[dataKeys[i]];
      for (var j = 0; j < dataConfigs.length; ++j) {
        var viewConfig = dataConfigs[j];
        // view configs can contain the same divIds, avoid duplicating
        if (!divIds.includes(viewConfig.divId)) {
          // create new layer group
          var element = document.getElementById(viewConfig.divId);
          var layerGroup = stage.addLayerGroup(element);
          // bind events
          bindLayerGroupToApp(layerGroup);
          // optional orientation
          if (typeof viewConfig.orientation !== 'undefined') {
            layerGroup.setTargetOrientation(
              dwv.math.getMatrixFromName(viewConfig.orientation));
          }
          divIds.push(viewConfig.divId);
        }
      }
    }
  }

  /**
   * Set the layer groups binders.
   *
   * @param {Array} list The binders list.
   */
  this.setLayerGroupsBinders = function (list) {
    stage.setBinders(list);
  };

  /**
   * Render the current data.
   *
   * @param {number} dataIndex The data index to render.
   */
  this.render = function (dataIndex) {
    if (typeof dataIndex === 'undefined' || dataIndex === null) {
      throw new Error('Cannot render without data index');
    }

    // create layer groups if not done yet
    // (create all to allow for ratio sync)
    if (stage.getNumberOfLayerGroups() === 0) {
      createLayerGroups(options.dataViewConfigs);
    }

    // loop on all configs
    var viewConfigs = getViewConfigs(dataIndex);
    // nothing to do if no view config
    if (viewConfigs.length === 0) {
      dwv.logger.info('Not rendering data: ' + dataIndex +
        ' (no data view config)');
      return;
    }
    for (var i = 0; i < viewConfigs.length; ++i) {
      var config = viewConfigs[i];
      var layerGroup =
        stage.getLayerGroupByDivId(config.divId);
      // layer group must exist
      if (!layerGroup) {
        throw new Error('No layer group for ' + config.divId);
      }
      // initialise or add view
      // warn: needs a loaded DOM
      if (layerGroup.getViewLayersByDataIndex(dataIndex).length === 0) {
        if (layerGroup.getNumberOfLayers() === 0) {
          initialiseBaseLayers(dataIndex, config);
        } else {
          addViewLayer(dataIndex, config);
        }
      }
      // draw
      layerGroup.draw();
    }
  };

  /**
   * Zoom to the layers.
   *
   * @param {number} step The step to add to the current zoom.
   * @param {number} cx The zoom center X coordinate.
   * @param {number} cy The zoom center Y coordinate.
   */
  this.zoom = function (step, cx, cy) {
    var layerGroup = stage.getActiveLayerGroup();
    var viewController = layerGroup.getActiveViewLayer().getViewController();
    var k = viewController.getCurrentScrollPosition();
    var center = new dwv.math.Point3D(cx, cy, k);
    layerGroup.addScale(step, center);
    layerGroup.draw();
  };

  /**
   * Apply a translation to the layers.
   *
   * @param {number} tx The translation along X.
   * @param {number} ty The translation along Y.
   */
  this.translate = function (tx, ty) {
    var layerGroup = stage.getActiveLayerGroup();
    layerGroup.addTranslation({x: tx, y: ty});
    layerGroup.draw();
  };

  /**
   * Set the image layer opacity.
   *
   * @param {number} alpha The opacity ([0:1] range).
   */
  this.setOpacity = function (alpha) {
    var viewLayer = stage.getActiveLayerGroup().getActiveViewLayer();
    viewLayer.setOpacity(alpha);
    viewLayer.draw();
  };

  /**
   * Set the drawings on the current stage.
   *
   * @param {Array} drawings An array of drawings.
   * @param {Array} drawingsDetails An array of drawings details.
   */
  this.setDrawings = function (drawings, drawingsDetails) {
    var layerGroup = stage.getActiveLayerGroup();
    var viewController =
      layerGroup.getActiveViewLayer().getViewController();
    var drawController =
      layerGroup.getActiveDrawLayer().getDrawController();

    drawController.setDrawings(
      drawings, drawingsDetails, fireEvent, this.addToUndoStack);

    drawController.activateDrawLayer(
      viewController.getCurrentOrientedIndex(),
      viewController.getScrollIndex());
  };

  /**
   * Get the JSON state of the app.
   *
   * @returns {object} The state of the app as a JSON object.
   */
  this.getState = function () {
    var state = new dwv.io.State();
    return state.toJSON(self);
  };

  // Handler Methods -----------------------------------------------------------

  /**
   * Handle resize: fit the display to the window.
   * To be called once the image is loaded.
   * Can be connected to a window 'resize' event.
   *
   * @param {object} _event The change event.
   * @private
   */
  this.onResize = function (_event) {
    self.fitToContainer();
  };

  /**
   * Key down callback. Meant to be used in tools.
   *
   * @param {object} event The key down event.
   * @fires dwv.App#keydown
   */
  this.onKeydown = function (event) {
    /**
     * Key down event.
     *
     * @event dwv.App#keydown
     * @type {KeyboardEvent}
     * @property {string} type The event type: keydown.
     * @property {string} context The tool where the event originated.
     */
    fireEvent(event);
  };

  /**
   * Key down event handler example.
   * - CRTL-Z: undo
   * - CRTL-Y: redo
   * - CRTL-ARROW_LEFT: next element on fourth dim
   * - CRTL-ARROW_UP: next element on third dim
   * - CRTL-ARROW_RIGHT: previous element on fourth dim
   * - CRTL-ARROW_DOWN: previous element on third dim
   *
   * @param {object} event The key down event.
   * @fires dwv.tool.UndoStack#undo
   * @fires dwv.tool.UndoStack#redo
   */
  this.defaultOnKeydown = function (event) {
    if (event.ctrlKey) {
      if (event.shiftKey) {
        var viewController =
          stage.getActiveLayerGroup().getActiveViewLayer().getViewController();
        var size = viewController.getImageSize();
        if (event.key === 'ArrowLeft') { // crtl-shift-arrow-left
          if (size.moreThanOne(3)) {
            viewController.decrementIndex(3);
          }
        } else if (event.key === 'ArrowUp') { // crtl-shift-arrow-up
          if (viewController.canScroll()) {
            viewController.incrementScrollIndex();
          }
        } else if (event.key === 'ArrowRight') { // crtl-shift-arrow-right
          if (size.moreThanOne(3)) {
            viewController.incrementIndex(3);
          }
        } else if (event.key === 'ArrowDown') { // crtl-shift-arrow-down
          if (viewController.canScroll()) {
            viewController.decrementScrollIndex();
          }
        }
      } else if (event.key === 'y') { // crtl-y
        undoStack.redo();
      } else if (event.key === 'z') { // crtl-z
        undoStack.undo();
      } else if (event.key === ' ') { // crtl-space
        for (var i = 0; i < stage.getNumberOfLayerGroups(); ++i) {
          stage.getLayerGroup(i).setShowCrosshair(
            !stage.getLayerGroup(i).getShowCrosshair()
          );
        }
      }
    }
  };

  // Internal members shortcuts-----------------------------------------------

  /**
   * Reset the display
   */
  this.resetDisplay = function () {
    self.resetLayout();
    self.initWLDisplay();
  };

  /**
   * Reset the app zoom.s
   */
  this.resetZoom = function () {
    self.resetLayout();
  };

  /**
   * Set the colour map.
   *
   * @param {string} colourMap The colour map name.
   */
  this.setColourMap = function (colourMap) {
    var viewController =
      stage.getActiveLayerGroup().getActiveViewLayer().getViewController();
    viewController.setColourMapFromName(colourMap);
  };

  /**
   * Set the window/level preset.
   *
   * @param {object} preset The window/level preset.
   */
  this.setWindowLevelPreset = function (preset) {
    var viewController =
      stage.getActiveLayerGroup().getActiveViewLayer().getViewController();
    viewController.setWindowLevelPreset(preset);
  };

  /**
   * Set the tool
   *
   * @param {string} tool The tool.
   */
  this.setTool = function (tool) {
    // bind tool to active layer
    for (var i = 0; i < stage.getNumberOfLayerGroups(); ++i) {
      var layerGroup = stage.getLayerGroup(i);
      // draw or view layer
      var layer = null;
      if (tool === 'Draw' ||
        tool === 'Livewire' ||
        tool === 'Floodfill') {
        layer = layerGroup.getActiveDrawLayer();
      } else {
        layer = layerGroup.getActiveViewLayer();
      }
      if (layer) {
        toolboxController.bindLayer(layer, layerGroup.getDivId());
      }
    }

    // set toolbox tool
    toolboxController.setSelectedTool(tool);
  };

  /**
   * Set the tool live features.
   *
   * @param {object} list The list of features.
   */
  this.setToolFeatures = function (list) {
    toolboxController.setToolFeatures(list);
  };

  /**
   * Undo the last action
   *
   * @fires dwv.tool.UndoStack#undo
   */
  this.undo = function () {
    undoStack.undo();
  };

  /**
   * Redo the last action
   *
   * @fires dwv.tool.UndoStack#redo
   */
  this.redo = function () {
    undoStack.redo();
  };

  /**
   * Get the undo stack size.
   *
   * @returns {number} The size of the stack.
   */
  this.getStackSize = function () {
    return undoStack.getStackSize();
  };

  /**
   * Get the current undo stack index.
   *
   * @returns {number} The stack index.
   */
  this.getCurrentStackIndex = function () {
    return undoStack.getCurrentStackIndex();
  };

  // Private Methods -----------------------------------------------------------

  /**
   * Fire an event: call all associated listeners with the input event object.
   *
   * @param {object} event The event to fire.
   * @private
   */
  function fireEvent(event) {
    listenerHandler.fireEvent(event);
  }

  /**
   * Data load start callback.
   *
   * @param {object} event The load start event.
   * @private
   */
  function onloadstart(event) {
    /**
     * Load start event.
     *
     * @event dwv.App#loadstart
     * @type {object}
     * @property {string} type The event type: loadstart.
     * @property {string} loadType The load type: image or state.
     * @property {*} source The load source: string for an url,
     *   File for a file.
     */
    event.type = 'loadstart';
    fireEvent(event);
  }

  /**
   * Data load progress callback.
   *
   * @param {object} event The progress event.
   * @private
   */
  function onloadprogress(event) {
    /**
     * Load progress event.
     *
     * @event dwv.App#loadprogress
     * @type {object}
     * @property {string} type The event type: loadprogress.
     * @property {string} loadType The load type: image or state.
     * @property {*} source The load source: string for an url,
     *   File for a file.
     * @property {number} loaded The loaded percentage.
     * @property {number} total The total percentage.
     */
    event.type = 'loadprogress';
    fireEvent(event);
  }

  /**
   * Data load callback.
   *
   * @param {object} event The load event.
   * @private
   */
  function onloaditem(event) {
    // check event
    if (typeof event.data === 'undefined') {
      dwv.logger.error('Missing loaditem event data.');
    }
    if (typeof event.loadtype === 'undefined') {
      dwv.logger.error('Missing loaditem event load type.');
    }

    var isFirstLoadItem = event.isfirstitem;

    var eventMetaData = null;
    if (event.loadtype === 'image') {
      if (isFirstLoadItem) {
        dataController.addNew(
          event.loadid, event.data.image, event.data.info);
      } else {
        dataController.update(
          event.loadid, event.data.image, event.data.info);
      }
      eventMetaData = event.data.info;
    } else if (event.loadtype === 'state') {
      var state = new dwv.io.State();
      state.apply(self, state.fromJSON(event.data));
      eventMetaData = 'state';
    }

    /**
     * Load item event: fired when a load item is successfull.
     *
     * @event dwv.App#loaditem
     * @type {object}
     * @property {string} type The event type: loaditem.
     * @property {string} loadType The load type: image or state.
     * @property {*} source The load source: string for an url,
     *   File for a file.
     * @property {object} data The loaded meta data.
     */
    fireEvent({
      type: 'loaditem',
      data: eventMetaData,
      source: event.source,
      loadtype: event.loadtype,
      loadid: event.loadid,
      isfirstitem: event.isfirstitem
    });

    // render if first and flag allows
    if (event.loadtype === 'image' &&
      getViewConfigs(event.loadid).length !== 0 &&
      isFirstLoadItem && options.viewOnFirstLoadItem) {
      self.render(event.loadid);
    }
  }

  /**
   * Data load callback.
   *
   * @param {object} event The load event.
   * @private
   */
  function onload(event) {
    /**
     * Load event: fired when a load finishes successfully.
     *
     * @event dwv.App#load
     * @type {object}
     * @property {string} type The event type: load.
     * @property {string} loadType The load type: image or state.
     */
    event.type = 'load';
    fireEvent(event);
  }

  /**
   * Data load end callback.
   *
   * @param {object} event The load end event.
   * @private
   */
  function onloadend(event) {
    /**
     * Main load end event: fired when the load finishes,
     *   successfully or not.
     *
     * @event dwv.App#loadend
     * @type {object}
     * @property {string} type The event type: loadend.
     * @property {string} loadType The load type: image or state.
     * @property {*} source The load source: string for an url,
     *   File for a file.
     */
    event.type = 'loadend';
    fireEvent(event);
  }

  /**
   * Data load error callback.
   *
   * @param {object} event The error event.
   * @private
   */
  function onloaderror(event) {
    /**
     * Load error event.
     *
     * @event dwv.App#loaderror
     * @type {object}
     * @property {string} type The event type: error.
     * @property {string} loadType The load type: image or state.
     * @property {*} source The load source: string for an url,
     *   File for a file.
     * @property {object} error The error.
     * @property {object} target The event target.
     */
    event.type = 'loaderror';
    fireEvent(event);
  }

  /**
   * Data load abort callback.
   *
   * @param {object} event The abort event.
   * @private
   */
  function onloadabort(event) {
    /**
     * Load abort event.
     *
     * @event dwv.App#loadabort
     * @type {object}
     * @property {string} type The event type: abort.
     * @property {string} loadType The load type: image or state.
     * @property {*} source The load source: string for an url,
     *   File for a file.
     */
    event.type = 'loadabort';
    fireEvent(event);
  }

  /**
   * Bind layer group events to app.
   *
   * @param {object} group The layer group.
   * @private
   */
  function bindLayerGroupToApp(group) {
    // propagate layer group events
    group.addEventListener('zoomchange', fireEvent);
    group.addEventListener('offsetchange', fireEvent);
    // propagate viewLayer events
    group.addEventListener('renderstart', fireEvent);
    group.addEventListener('renderend', fireEvent);
    // propagate view events
    for (var j = 0; j < dwv.image.viewEventNames.length; ++j) {
      group.addEventListener(dwv.image.viewEventNames[j], fireEvent);
    }
    // propagate drawLayer events
    if (toolboxController && toolboxController.hasTool('Draw')) {
      group.addEventListener('drawcreate', fireEvent);
      group.addEventListener('drawdelete', fireEvent);
    }
  }

  /**
   * Initialise the layers.
   * To be called once the DICOM data has been loaded.
   *
   * @param {number} dataIndex The data index.
   * @param {object} dataViewConfig The data view config.
   * @private
   */
  function initialiseBaseLayers(dataIndex, dataViewConfig) {
    // add layers
    addViewLayer(dataIndex, dataViewConfig);

    // initialise the toolbox
    if (toolboxController) {
      toolboxController.init();
    }
  }

  /**
   * Add a view layer.
   *
   * @param {number} dataIndex The data index.
   * @param {object} dataViewConfig The data view config.
   */
  function addViewLayer(dataIndex, dataViewConfig) {
    var data = dataController.get(dataIndex);
    if (!data) {
      throw new Error('Cannot initialise layer with data id: ' + dataIndex);
    }
    var layerGroup = stage.getLayerGroupByDivId(dataViewConfig.divId);
    if (!layerGroup) {
      throw new Error('Cannot initialise layer with group id: ' +
        dataViewConfig.divId);
    }
    var imageGeometry = data.image.getGeometry();

    // un-bind
    stage.unbindLayerGroups();

    // create and setup view
    var viewFactory = new dwv.ViewFactory();
    var view = viewFactory.create(data.meta, data.image);
    var viewOrientation = dwv.gui.getViewOrientation(
      imageGeometry.getOrientation(),
      layerGroup.getTargetOrientation()
    );
    view.setOrientation(viewOrientation);

    // make pixel of value 0 transparent for segmentation
    // (assuming RGB data)
    if (data.image.getMeta().Modality === 'SEG') {
      view.setAlphaFunction(function (value /*, index*/) {
        if (value[0] === 0 &&
          value[1] === 0 &&
          value[2] === 0) {
          return 0;
        } else {
          return 0xff;
        }
      });
    }

    // colour map
    if (typeof dataViewConfig.colourMap !== 'undefined') {
      view.setColourMap(dataViewConfig.colourMap);
    }

    var isBaseLayer = layerGroup.getNumberOfLayers() === 0;

    // opacity
    var opacity = 1;
    // do we have more than one layer
    // (the layer has not been added to the layer group yet)
    if (!isBaseLayer) {
      opacity = 0.5;
      // set color map if non was provided
      if (typeof dataViewConfig.colourMap === 'undefined') {
        view.setColourMap(dwv.image.lut.rainbow);
      }
    }

    // view layer
    var viewLayer = layerGroup.addViewLayer();
    viewLayer.setView(view, dataIndex);
    var size2D = imageGeometry.getSize(viewOrientation).get2D();
    var spacing2D = imageGeometry.getSpacing(viewOrientation).get2D();
    viewLayer.initialise(size2D, spacing2D, opacity);
    var viewController = viewLayer.getViewController();

    // listen to controller events
    if (data.image.getMeta().Modality === 'SEG') {
      viewController.addEventListener('masksegmentdelete', fireEvent);
      viewController.addEventListener('masksegmentredraw', fireEvent);
    }

    // listen to image changes
    dataController.addEventListener('imageset', viewLayer.onimageset);
    dataController.addEventListener('imagechange', function (event) {
      viewLayer.onimagechange(event);
      self.render(event.dataid);
    });

    // bind
    stage.bindLayerGroups();
    if (toolboxController) {
      toolboxController.bindLayer(viewLayer, layerGroup.getDivId());
    }

    // optional draw layer
    var drawLayer;
    if (toolboxController && toolboxController.hasTool('Draw')) {
      drawLayer = layerGroup.addDrawLayer();
      drawLayer.initialise(size2D, spacing2D, dataIndex);
      drawLayer.setPlaneHelper(viewLayer.getViewController().getPlaneHelper());
    }

    // sync layers position
    var value = [
      viewController.getCurrentIndex().getValues(),
      viewController.getCurrentPosition().getValues()
    ];
    layerGroup.updateLayersToPositionChange({
      value: value,
      srclayerid: viewLayer.getId()
    });

    // sync layer groups
    stage.syncLayerGroupScale();

    // major orientation axis
    var major = imageGeometry.getOrientation().getThirdColMajorDirection();

    // view layer offset (done before scale)
    viewLayer.setOffset(layerGroup.getOffset());
    // extra flip offset for oriented views...
    if (typeof dataViewConfig.orientation !== 'undefined') {
      if (major === 2) {
        // flip offset Y for axial aquired data
        if (dataViewConfig.orientation !== 'axial') {
          viewLayer.addFlipOffsetY();
          if (typeof drawLayer !== 'undefined') {
            drawLayer.addFlipOffsetY();
          }
        }
      } else if (major === 0) {
        // flip offset X for sagittal aquired data
        if (dataViewConfig.orientation !== 'sagittal') {
          viewLayer.addFlipOffsetX();
          if (typeof drawLayer !== 'undefined') {
            drawLayer.addFlipOffsetX();
          }
        }
      }
    }

    // view layer scale
    // only flip scale for base layers
    if (isBaseLayer) {
      if (typeof dataViewConfig.orientation !== 'undefined') {
        if (major === 0 || major === 2) {
          // scale flip Z for oriented views...
          layerGroup.flipScaleZ();
        } else {
          viewLayer.setScale(layerGroup.getScale());
          if (typeof drawLayer !== 'undefined') {
            drawLayer.setScale(layerGroup.getScale());
          }
        }
      } else {
        if (major === 0) {
          // scale flip Z for sagittal and undefined target orientation
          layerGroup.flipScaleZ();
        } else {
          viewLayer.setScale(layerGroup.getScale());
          if (typeof drawLayer !== 'undefined') {
            drawLayer.setScale(layerGroup.getScale());
          }
        }
      }
    } else {
      viewLayer.setScale(layerGroup.getScale());
      if (typeof drawLayer !== 'undefined') {
        drawLayer.setScale(layerGroup.getScale());
      }
    }

  }

}; // class dwv.App

// namespaces
var dwv = dwv || {};
/** @namespace */
dwv.ctrl = dwv.ctrl || {};

/*
 * Data (list of {image, meta}) controller.
 *
 * @class
 */
dwv.ctrl.DataController = function () {

  /**
   * List of {image, meta}.
   *
   * @private
   * @type {object}
   */
  var data = {};

  /**
   * Listener handler.
   *
   * @type {dwv.utils.ListenerHandler}
   * @private
   */
  var listenerHandler = new dwv.utils.ListenerHandler();

  /**
   * Get the length of the data storage.
   *
   * @returns {number} The length.
   */
  this.length = function () {
    return Object.keys(data).length;
  };

  /**
   * Reset the class: empty the data storage.
   */
  this.reset = function () {
    data = [];
  };

  /**
   * Get a data at a given index.
   *
   * @param {number} index The index of the data.
   * @returns {object} The data.
   */
  this.get = function (index) {
    return data[index];
  };

  /**
   * Set the image at a given index.
   *
   * @param {number} index The index of the data.
   * @param {dwv.image.Image} image The image to set.
   */
  this.setImage = function (index, image) {
    data[index].image = image;
    // fire image set
    fireEvent({
      type: 'imageset',
      value: [image],
      dataid: index
    });
    // listen to image change
    image.addEventListener('imagechange', getFireEvent(index));
  };

  /**
   * Add a new data.
   *
   * @param {number} index The index of the data.
   * @param {dwv.image.Image} image The image.
   * @param {object} meta The image meta.
   */
  this.addNew = function (index, image, meta) {
    if (typeof data[index] !== 'undefined') {
      throw new Error('Index already used in storage: ' + index);
    }
    // store the new image
    data[index] = {
      image: image,
      meta: getMetaObject(meta)
    };
    // listen to image change
    image.addEventListener('imagechange', getFireEvent(index));
  };

  /**
   * Update the current data.
   *
   * @param {number} index The index of the data.
   * @param {dwv.image.Image} image The image.
   * @param {object} meta The image meta.
   */
  this.update = function (index, image, meta) {
    var dataToUpdate = data[index];

    // add slice to current image
    dataToUpdate.image.appendSlice(image);

    // update meta data
    // TODO add time support
    var idKey = '';
    if (typeof meta.x00020010 !== 'undefined') {
      // dicom case
      idKey = 'InstanceNumber';
    } else {
      idKey = 'imageUid';
    }
    dataToUpdate.meta = dwv.utils.mergeObjects(
      dataToUpdate.meta,
      getMetaObject(meta),
      idKey,
      'value');
  };

  /**
   * Add an event listener to this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type, will be called with the fired event.
   */
  this.addEventListener = function (type, callback) {
    listenerHandler.add(type, callback);
  };

  /**
   * Remove an event listener from this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type.
   */
  this.removeEventListener = function (type, callback) {
    listenerHandler.remove(type, callback);
  };

  /**
   * Fire an event: call all associated listeners with the input event object.
   *
   * @param {object} event The event to fire.
   * @private
   */
  function fireEvent(event) {
    listenerHandler.fireEvent(event);
  }

  /**
   * Get a fireEvent function that adds the input index
   * to the event value.
   *
   * @param {number} index The data index.
   * @returns {Function} A fireEvent function.
   */
  function getFireEvent(index) {
    return function (event) {
      event.dataid = index;
      fireEvent(event);
    };
  }

  /**
   * Get a meta data object.
   *
   * @param {*} meta The meta data to convert.
   * @returns {*} object for DICOM, array for DOM image.
   */
  function getMetaObject(meta) {
    var metaObj = null;
    // wrap meta if dicom (x00020010: transfer syntax)
    if (typeof meta.x00020010 !== 'undefined') {
      var newDcmMetaData = new dwv.dicom.DicomElementsWrapper(meta);
      metaObj = newDcmMetaData.dumpToObject();
    } else {
      metaObj = meta;
    }
    return metaObj;
  }

}; // ImageController class

// namespaces
var dwv = dwv || {};
dwv.draw = dwv.draw || {};
dwv.ctrl = dwv.ctrl || {};

/**
 * The Konva namespace.
 *
 * @external Konva
 * @see https://konvajs.org/
 */
var Konva = Konva || {};

/**
 * Get the draw group id for a given position.
 *
 * @param {dwv.math.Point} currentPosition The current position.
 * @returns {string} The group id.
 * @deprecated Use the index.toStringId instead.
 */
dwv.draw.getDrawPositionGroupId = function (currentPosition) {
  var sliceNumber = currentPosition.get(2);
  var frameNumber = currentPosition.length() === 4
    ? currentPosition.get(3) : 0;
  return 'slice-' + sliceNumber + '_frame-' + frameNumber;
};

/**
 * Get the slice and frame position from a group id.
 *
 * @param {string} groupId The group id.
 * @returns {object} The slice and frame number.
 * @deprecated Use the dwv.math.getVectorFromStringId instead.
 */
dwv.draw.getPositionFromGroupId = function (groupId) {
  var sepIndex = groupId.indexOf('_');
  if (sepIndex === -1) {
    dwv.logger.warn('Badly formed PositionGroupId: ' + groupId);
  }
  return {
    sliceNumber: groupId.substring(6, sepIndex),
    frameNumber: groupId.substring(sepIndex + 7)
  };
};

/**
 * Is an input node's name 'shape'.
 *
 * @param {object} node A Konva node.
 * @returns {boolean} True if the node's name is 'shape'.
 */
dwv.draw.isNodeNameShape = function (node) {
  return node.name() === 'shape';
};

/**
 * Is a node an extra shape associated with a main one.
 *
 * @param {object} node A Konva node.
 * @returns {boolean} True if the node's name starts with 'shape-'.
 */
dwv.draw.isNodeNameShapeExtra = function (node) {
  return node.name().startsWith('shape-');
};

/**
 * Is an input node's name 'label'.
 *
 * @param {object} node A Konva node.
 * @returns {boolean} True if the node's name is 'label'.
 */
dwv.draw.isNodeNameLabel = function (node) {
  return node.name() === 'label';
};

/**
 * Is an input node a position node.
 *
 * @param {object} node A Konva node.
 * @returns {boolean} True if the node's name is 'position-group'.
 */
dwv.draw.isPositionNode = function (node) {
  return node.name() === 'position-group';
};

/**
 * Get a lambda to check a node's id.
 *
 * @param {string} id The id to check.
 * @returns {Function} A function to check a node's id.
 */
dwv.draw.isNodeWithId = function (id) {
  return function (node) {
    return node.id() === id;
  };
};

/**
 * Is the input node a node that has the 'stroke' method.
 *
 * @param {object} node A Konva node.
 * @returns {boolean} True if the node's name is 'anchor' and 'label'.
 */
dwv.draw.canNodeChangeColour = function (node) {
  return node.name() !== 'anchor' && node.name() !== 'label';
};

/**
 * Debug function to output the layer hierarchy as text.
 *
 * @param {object} layer The Konva layer.
 * @param {string} prefix A display prefix (used in recursion).
 * @returns {string} A text representation of the hierarchy.
 */
dwv.draw.getHierarchyLog = function (layer, prefix) {
  if (typeof prefix === 'undefined') {
    prefix = '';
  }
  var kids = layer.getChildren();
  var log = prefix + '|__ ' + layer.name() + ': ' + layer.id() + '\n';
  for (var i = 0; i < kids.length; ++i) {
    log += dwv.draw.getHierarchyLog(kids[i], prefix + '    ');
  }
  return log;
};

/**
 * Draw controller.
 *
 * @class
 * @param {object} konvaLayer The draw layer.
 */
dwv.ctrl.DrawController = function (konvaLayer) {
  // current position group id
  var currentPosGroupId = null;

  /**
   * Get the current position group.
   *
   * @returns {object} The Konva.Group.
   */
  this.getCurrentPosGroup = function () {
    // get position groups
    var posGroups = konvaLayer.getChildren(function (node) {
      return node.id() === currentPosGroupId;
    });
    // if one group, use it
    // if no group, create one
    var posGroup = null;
    if (posGroups.length === 1) {
      posGroup = posGroups[0];
    } else if (posGroups.length === 0) {
      posGroup = new Konva.Group();
      posGroup.name('position-group');
      posGroup.id(currentPosGroupId);
      posGroup.visible(true); // dont inherit
      // add new group to layer
      konvaLayer.add(posGroup);
    } else {
      dwv.logger.warn('Unexpected number of draw position groups.');
    }
    // return
    return posGroup;
  };

  /**
   * Reset: clear the layers array.
   */
  this.reset = function () {
    konvaLayer = null;
  };

  /**
   * Get a Konva group using its id.
   *
   * @param {string} id The group id.
   * @returns {object|undefined} The Konva group.
   */
  this.getGroup = function (id) {
    var group = konvaLayer.findOne('#' + id);
    if (typeof group === 'undefined') {
      dwv.logger.warn('Cannot find node with id: ' + id
      );
    }
    return group;
  };

  /**
   * Activate the current draw layer.
   *
   * @param {dwv.math.Index} index The current position.
   * @param {number} scrollIndex The scroll index.
   */
  this.activateDrawLayer = function (index, scrollIndex) {
    // TODO: add layer info
    // get and store the position group id
    var dims = [scrollIndex];
    for (var j = 3; j < index.length(); ++j) {
      dims.push(j);
    }
    currentPosGroupId = index.toStringId(dims);

    // get all position groups
    var posGroups = konvaLayer.getChildren(dwv.draw.isPositionNode);
    // reset or set the visible property
    var visible;
    for (var i = 0, leni = posGroups.length; i < leni; ++i) {
      visible = false;
      if (posGroups[i].id() === currentPosGroupId) {
        visible = true;
      }
      // group members inherit the visible property
      posGroups[i].visible(visible);
    }

    // show current draw layer
    konvaLayer.draw();
  };

  /**
   * Get a list of drawing display details.
   *
   * @returns {Array} A list of draw details as
   *   {id, position, type, color, meta}
   */
  this.getDrawDisplayDetails = function () {
    var list = [];
    var groups = konvaLayer.getChildren();
    for (var j = 0, lenj = groups.length; j < lenj; ++j) {
      var position = dwv.math.getIndexFromStringId(groups[j].id());
      var collec = groups[j].getChildren();
      for (var i = 0, leni = collec.length; i < leni; ++i) {
        var shape = collec[i].getChildren(dwv.draw.isNodeNameShape)[0];
        var label = collec[i].getChildren(dwv.draw.isNodeNameLabel)[0];
        var text = label.getChildren()[0];
        var type = shape.className;
        if (type === 'Line') {
          var shapeExtrakids = collec[i].getChildren(
            dwv.draw.isNodeNameShapeExtra);
          if (shape.closed()) {
            type = 'Roi';
          } else if (shapeExtrakids.length !== 0) {
            var extraName0 = shapeExtrakids[0].name();
            if (extraName0.indexOf('triangle') !== -1) {
              type = 'Arrow';
            } else if (extraName0.indexOf('arc') !== -1) {
              type = 'Protractor';
            } else {
              type = 'Ruler';
            }
          }
        }
        if (type === 'Rect') {
          type = 'Rectangle';
        }
        list.push({
          id: collec[i].id(),
          position: position.toString(),
          type: type,
          color: shape.stroke(),
          meta: text.meta
        });
      }
    }
    return list;
  };

  /**
   * Get a list of drawing store details. Used in state.
   *
   * @returns {object} A list of draw details including id, text, quant...
   * TODO Unify with getDrawDisplayDetails?
   */
  this.getDrawStoreDetails = function () {
    var drawingsDetails = {};

    // get all position groups
    var posGroups = konvaLayer.getChildren(dwv.draw.isPositionNode);

    var posKids;
    var group;
    for (var i = 0, leni = posGroups.length; i < leni; ++i) {
      posKids = posGroups[i].getChildren();
      for (var j = 0, lenj = posKids.length; j < lenj; ++j) {
        group = posKids[j];
        // remove anchors
        var anchors = group.find('.anchor');
        for (var a = 0; a < anchors.length; ++a) {
          anchors[a].remove();
        }
        // get text
        var texts = group.find('.text');
        if (texts.length !== 1) {
          dwv.logger.warn('There should not be more than one text per shape.');
        }
        // get meta (non konva vars)
        drawingsDetails[group.id()] = {
          meta: texts[0].meta
        };
      }
    }
    return drawingsDetails;
  };

  /**
   * Set the drawings on the current stage.
   *
   * @param {Array} drawings An array of drawings.
   * @param {Array} drawingsDetails An array of drawings details.
   * @param {object} cmdCallback The DrawCommand callback.
   * @param {object} exeCallback The callback to call once the
   *   DrawCommand has been executed.
   */
  this.setDrawings = function (
    drawings, drawingsDetails, cmdCallback, exeCallback) {
    // regular Konva deserialize
    var stateLayer = Konva.Node.create(drawings);

    // get all position groups
    var statePosGroups = stateLayer.getChildren(dwv.draw.isPositionNode);

    for (var i = 0, leni = statePosGroups.length; i < leni; ++i) {
      var statePosGroup = statePosGroups[i];

      // Get or create position-group if it does not exist and
      // append it to konvaLayer
      var posGroup = konvaLayer.getChildren(
        dwv.draw.isNodeWithId(statePosGroup.id()))[0];
      if (typeof posGroup === 'undefined') {
        posGroup = new Konva.Group({
          id: statePosGroup.id(),
          name: 'position-group',
          visible: false
        });
        konvaLayer.add(posGroup);
      }

      var statePosKids = statePosGroup.getChildren();
      for (var j = 0, lenj = statePosKids.length; j < lenj; ++j) {
        // shape group (use first one since it will be removed from
        // the group when we change it)
        var stateGroup = statePosKids[0];
        // add group to posGroup (switches its parent)
        posGroup.add(stateGroup);
        // shape
        var shape = stateGroup.getChildren(dwv.draw.isNodeNameShape)[0];
        // create the draw command
        var cmd = new dwv.tool.DrawGroupCommand(
          stateGroup, shape.className, konvaLayer);
        // draw command callbacks
        cmd.onExecute = cmdCallback;
        cmd.onUndo = cmdCallback;
        // details
        if (drawingsDetails) {
          var details = drawingsDetails[stateGroup.id()];
          var label = stateGroup.getChildren(dwv.draw.isNodeNameLabel)[0];
          var text = label.getText();
          // store details
          text.meta = details.meta;
          // reset text (it was not encoded)
          text.setText(dwv.utils.replaceFlags(
            text.meta.textExpr, text.meta.quantification
          ));
        }
        // execute
        cmd.execute();
        exeCallback(cmd);
      }
    }
  };

  /**
   * Update a drawing from its details.
   *
   * @param {object} drawDetails Details of the drawing to update.
   */
  this.updateDraw = function (drawDetails) {
    // get the group
    var group = konvaLayer.findOne('#' + drawDetails.id);
    if (typeof group === 'undefined') {
      dwv.logger.warn(
        '[updateDraw] Cannot find group with id: ' + drawDetails.id
      );
      return;
    }
    // shape
    var shapes = group.getChildren(dwv.draw.isNodeNameShape);
    for (var i = 0; i < shapes.length; ++i) {
      shapes[i].stroke(drawDetails.color);
    }
    // shape extra
    var shapesExtra = group.getChildren(dwv.draw.isNodeNameShapeExtra);
    for (var j = 0; j < shapesExtra.length; ++j) {
      if (typeof shapesExtra[j].stroke() !== 'undefined') {
        shapesExtra[j].stroke(drawDetails.color);
      } else if (typeof shapesExtra[j].fill() !== 'undefined') {
        // for example text
        shapesExtra[j].fill(drawDetails.color);
      }
    }
    // label
    var label = group.getChildren(dwv.draw.isNodeNameLabel)[0];
    var shadowColor = dwv.utils.getShadowColour(drawDetails.color);
    var kids = label.getChildren();
    for (var k = 0; k < kids.length; ++k) {
      var kid = kids[k];
      kid.fill(drawDetails.color);
      if (kids[k].className === 'Text') {
        var text = kids[k];
        text.shadowColor(shadowColor);
        if (typeof drawDetails.meta !== 'undefined') {
          text.meta = drawDetails.meta;
          text.setText(dwv.utils.replaceFlags(
            text.meta.textExpr, text.meta.quantification
          ));
          label.setVisible(text.meta.textExpr.length !== 0);
        }
      }
    }

    // udpate current layer
    konvaLayer.draw();
  };

  /**
   * Delete a Draw from the stage.
   *
   * @param {object} group The group to delete.
   * @param {object} cmdCallback The DeleteCommand callback.
   * @param {object} exeCallback The callback to call once the
   *  DeleteCommand has been executed.
   */
  this.deleteDrawGroup = function (group, cmdCallback, exeCallback) {
    var shape = group.getChildren(dwv.draw.isNodeNameShape)[0];
    var shapeDisplayName = dwv.tool.GetShapeDisplayName(shape);
    var delcmd = new dwv.tool.DeleteGroupCommand(
      group, shapeDisplayName, konvaLayer);
    delcmd.onExecute = cmdCallback;
    delcmd.onUndo = cmdCallback;
    delcmd.execute();
    // callback
    exeCallback(delcmd);
  };

  /**
   * Delete a Draw from the stage.
   *
   * @param {string} id The id of the group to delete.
   * @param {object} cmdCallback The DeleteCommand callback.
   * @param {object} exeCallback The callback to call once the
   *  DeleteCommand has been executed.
   * @returns {boolean} False if the group cannot be found.
   */
  this.deleteDraw = function (id, cmdCallback, exeCallback) {
    // get the group
    var group = this.getGroup(id);
    if (typeof group === 'undefined') {
      return false;
    }
    // delete
    this.deleteDrawGroup(group, cmdCallback, exeCallback);

    return true;
  };

  /**
   * Delete all Draws from the stage.
   *
   * @param {object} cmdCallback The DeleteCommand callback.
   * @param {object} exeCallback The callback to call once the
   *  DeleteCommand has been executed.
   */
  this.deleteDraws = function (cmdCallback, exeCallback) {
    var groups = konvaLayer.getChildren();
    while (groups.length) {
      this.deleteDrawGroup(groups[0], cmdCallback, exeCallback);
    }
  };

}; // class DrawController

// namespaces
var dwv = dwv || {};
dwv.ctrl = dwv.ctrl || {};

/**
 * Load controller.
 *
 * @param {string} defaultCharacterSet The default character set.
 * @class
 */
dwv.ctrl.LoadController = function (defaultCharacterSet) {
  // closure to self
  var self = this;
  // current loaders
  var currentLoaders = {};

  // load counter
  var counter = -1;

  /**
   * Get the next load id.
   *
   * @returns {number} The next id.
   */
  function getNextLoadId() {
    ++counter;
    return counter;
  }

  /**
   * Load a list of files. Can be image files or a state file.
   *
   * @param {Array} files The list of files to load.
   */
  this.loadFiles = function (files) {
    // has been checked for emptiness.
    var ext = files[0].name.split('.').pop().toLowerCase();
    if (ext === 'json') {
      loadStateFile(files[0]);
    } else {
      loadImageFiles(files);
    }
  };

  /**
   * Load a list of URLs. Can be image files or a state file.
   *
   * @param {Array} urls The list of urls to load.
   * @param {object} options The load options:
   * - requestHeaders: an array of {name, value} to use as request headers.
   * - withCredentials: credentials flag to pass to the request.
   */
  this.loadURLs = function (urls, options) {
    // has been checked for emptiness.
    var ext = urls[0].split('.').pop().toLowerCase();
    if (ext === 'json') {
      loadStateUrl(urls[0], options);
    } else {
      loadImageUrls(urls, options);
    }
  };

  /**
   * Load a list of ArrayBuffers.
   *
   * @param {Array} data The list of ArrayBuffers to load
   *   in the form of [{name: "", filename: "", data: data}].
   */
  this.loadImageObject = function (data) {
    // create IO
    var memoryIO = new dwv.io.MemoryLoader();
    // load data
    loadData(data, memoryIO, 'image');
  };

  /**
   * Abort the current loaders.
   */
  this.abort = function () {
    var keys = Object.keys(currentLoaders);
    for (var i = 0; i < keys.length; ++i) {
      currentLoaders[i].loader.abort();
      delete currentLoaders[i];
    }
  };

  // private ----------------------------------------------------------------

  /**
   * Load a list of image files.
   *
   * @param {Array} files The list of image files to load.
   * @private
   */
  function loadImageFiles(files) {
    // create IO
    var fileIO = new dwv.io.FilesLoader();
    fileIO.setDefaultCharacterSet(defaultCharacterSet);
    // load data
    loadData(files, fileIO, 'image');
  }

  /**
   * Load a list of image URLs.
   *
   * @param {Array} urls The list of urls to load.
   * @param {object} options The load options:
   * - requestHeaders: an array of {name, value} to use as request headers.
   * - withCredentials: credentials flag to pass to the request.
   * @private
   */
  function loadImageUrls(urls, options) {
    // create IO
    var urlIO = new dwv.io.UrlsLoader();
    urlIO.setDefaultCharacterSet(defaultCharacterSet);
    // load data
    loadData(urls, urlIO, 'image', options);
  }

  /**
   * Load a State file.
   *
   * @param {string} file The state file to load.
   * @private
   */
  function loadStateFile(file) {
    // create IO
    var fileIO = new dwv.io.FilesLoader();
    // load data
    loadData([file], fileIO, 'state');
  }

  /**
   * Load a State url.
   *
   * @param {string} url The state url to load.
   * @param {object} options The load options:
   * - requestHeaders: an array of {name, value} to use as request headers.
   * - withCredentials: credentials flag to pass to the request.
   * @private
   */
  function loadStateUrl(url, options) {
    // create IO
    var urlIO = new dwv.io.UrlsLoader();
    // load data
    loadData([url], urlIO, 'state', options);
  }

  /**
   * Load a list of data.
   *
   * @param {Array} data Array of data to load.
   * @param {object} loader The data loader.
   * @param {string} loadType The data load type: 'image' or 'state'.
   * @param {object} options Options passed to the final loader.
   * @private
   */
  function loadData(data, loader, loadType, options) {
    var eventInfo = {
      loadtype: loadType,
    };

    // load id
    var loadId = getNextLoadId();
    eventInfo.loadid = loadId;

    // set callbacks
    loader.onloadstart = function (event) {
      // store loader to allow abort
      currentLoaders[loadId] = {
        loader: loader,
        isFirstItem: true
      };
      // callback
      augmentCallbackEvent(self.onloadstart, eventInfo)(event);
    };
    loader.onprogress = augmentCallbackEvent(self.onprogress, eventInfo);
    loader.onloaditem = function (event) {
      var eventInfoItem = {
        loadtype: loadType,
        loadid: loadId
      };
      if (typeof currentLoaders[loadId] !== 'undefined') {
        eventInfoItem.isfirstitem = currentLoaders[loadId].isFirstItem;
      }
      // callback
      augmentCallbackEvent(self.onloaditem, eventInfoItem)(event);
      // update loader
      if (typeof currentLoaders[loadId] !== 'undefined' &&
        currentLoaders[loadId].isFirstItem) {
        currentLoaders[loadId].isFirstItem = false;
      }
    };
    loader.onload = augmentCallbackEvent(self.onload, eventInfo);
    loader.onloadend = function (event) {
      // reset current loader
      delete currentLoaders[loadId];
      // callback
      augmentCallbackEvent(self.onloadend, eventInfo)(event);
    };
    loader.onerror = augmentCallbackEvent(self.onerror, eventInfo);
    loader.onabort = augmentCallbackEvent(self.onabort, eventInfo);
    // launch load
    try {
      loader.load(data, options);
    } catch (error) {
      self.onerror({
        error: error,
        loadid: loadId
      });
      self.onloadend({
        loadid: loadId
      });
      return;
    }
  }

  /**
   * Augment a callback event: adds loadtype to the event
   *  passed to a callback.
   *
   * @param {object} callback The callback to update.
   * @param {object} info Info object to append to the event.
   * @returns {object} A function representing the modified callback.
   */
  function augmentCallbackEvent(callback, info) {
    return function (event) {
      var keys = Object.keys(info);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        event[key] = info[key];
      }
      callback(event);
    };
  }

}; // class LoadController

/**
 * Handle a load start event.
 * Default does nothing.
 *
 * @param {object} _event The load start event.
 */
dwv.ctrl.LoadController.prototype.onloadstart = function (_event) {};
/**
 * Handle a load progress event.
 * Default does nothing.
 *
 * @param {object} _event The progress event.
 */
dwv.ctrl.LoadController.prototype.onprogress = function (_event) {};
/**
 * Handle a load event.
 * Default does nothing.
 *
 * @param {object} _event The load event fired
 *   when a file has been loaded successfully.
 */
dwv.ctrl.LoadController.prototype.onload = function (_event) {};
/**
 * Handle a load end event.
 * Default does nothing.
 *
 * @param {object} _event The load end event fired
 *  when a file load has completed, successfully or not.
 */
dwv.ctrl.LoadController.prototype.onloadend = function (_event) {};
/**
 * Handle an error event.
 * Default does nothing.
 *
 * @param {object} _event The error event.
 */
dwv.ctrl.LoadController.prototype.onerror = function (_event) {};
/**
 * Handle an abort event.
 * Default does nothing.
 *
 * @param {object} _event The abort event.
 */
dwv.ctrl.LoadController.prototype.onabort = function (_event) {};

// namespaces
var dwv = dwv || {};
dwv.ctrl = dwv.ctrl || {};

/**
 * Toolbox controller.
 *
 * @param {Array} toolList The list of tool objects.
 * @class
 */
dwv.ctrl.ToolboxController = function (toolList) {
  /**
   * Selected tool.
   *
   * @type {object}
   * @private
   */
  var selectedTool = null;

  /**
   * Callback store to allow attach/detach.
   *
   * @type {Array}
   * @private
   */
  var callbackStore = [];

  /**
   * Current layers bound to tool.
   *
   * @type {object}
   * @private
   */
  var boundLayers = {};

  /**
   * Initialise.
   */
  this.init = function () {
    for (var key in toolList) {
      toolList[key].init();
    }
    // keydown listener
    window.addEventListener('keydown', getOnMouch('window', 'keydown'), true);
  };

  /**
   * Get the tool list.
   *
   * @returns {Array} The list of tool objects.
   */
  this.getToolList = function () {
    return toolList;
  };

  /**
   * Check if a tool is in the tool list.
   *
   * @param {string} name The name to check.
   * @returns {string} The tool list element for the given name.
   */
  this.hasTool = function (name) {
    return typeof this.getToolList()[name] !== 'undefined';
  };

  /**
   * Get the selected tool.
   *
   * @returns {object} The selected tool.
   */
  this.getSelectedTool = function () {
    return selectedTool;
  };

  /**
   * Get the selected tool event handler.
   *
   * @param {string} eventType The event type, for example
   *   mousedown, touchstart...
   * @returns {Function} The event handler.
   */
  this.getSelectedToolEventHandler = function (eventType) {
    return this.getSelectedTool()[eventType];
  };

  /**
   * Set the selected tool.
   *
   * @param {string} name The name of the tool.
   */
  this.setSelectedTool = function (name) {
    // check if we have it
    if (!this.hasTool(name)) {
      throw new Error('Unknown tool: \'' + name + '\'');
    }
    // de-activate previous
    if (selectedTool) {
      selectedTool.activate(false);
    }
    // set internal var
    selectedTool = toolList[name];
    // activate new tool
    selectedTool.activate(true);
  };

  /**
   * Set the selected tool live features.
   *
   * @param {object} list The list of features.
   */
  this.setToolFeatures = function (list) {
    if (this.getSelectedTool()) {
      this.getSelectedTool().setFeatures(list);
    }
  };

  /**
   * Listen to layer interaction events.
   *
   * @param {object} layer The layer to listen to.
   * @param {string} layerGroupDivId The associated layer group div id.
   */
  this.bindLayer = function (layer, layerGroupDivId) {
    if (typeof boundLayers[layerGroupDivId] !== 'undefined') {
      unbindLayer(boundLayers[layerGroupDivId]);
    }
    layer.bindInteraction();
    // interaction events
    var names = dwv.gui.interactionEventNames;
    for (var i = 0; i < names.length; ++i) {
      layer.addEventListener(names[i],
        getOnMouch(layer.getId(), names[i]));
    }
    // update class var
    boundLayers[layerGroupDivId] = layer;
  };

  /**
   * Remove canvas mouse and touch listeners.
   *
   * @param {object} layer The layer to stop listening to.
   */
  function unbindLayer(layer) {
    layer.unbindInteraction();
    // interaction events
    var names = dwv.gui.interactionEventNames;
    for (var i = 0; i < names.length; ++i) {
      layer.removeEventListener(names[i],
        getOnMouch(layer.getId(), names[i]));
    }
  }

  /**
   * Mou(se) and (T)ouch event handler. This function just determines
   * the mouse/touch position relative to the canvas element.
   * It then passes it to the current tool.
   *
   * @param {string} layerId The layer id.
   * @param {string} eventType The event type.
   * @returns {object} A callback for the provided layer and event.
   * @private
   */
  function getOnMouch(layerId, eventType) {
    // augment event with converted offsets
    var augmentEventOffsets = function (event) {
      // event offset(s)
      var offsets = dwv.gui.getEventOffset(event);
      // should have at least one offset
      event._x = offsets[0].x;
      event._y = offsets[0].y;
      // possible second
      if (offsets.length === 2) {
        event._x1 = offsets[1].x;
        event._y1 = offsets[1].y;
      }
    };

    var applySelectedTool = function (event) {
      // make sure we have a tool
      if (selectedTool) {
        var func = selectedTool[event.type];
        if (func) {
          func(event);
        }
      }
    };

    if (typeof callbackStore[layerId] === 'undefined') {
      callbackStore[layerId] = [];
    }

    if (typeof callbackStore[layerId][eventType] === 'undefined') {
      var callback = null;
      if (eventType === 'keydown') {
        callback = function (event) {
          applySelectedTool(event);
        };
      } else if (eventType === 'touchend') {
        callback = function (event) {
          applySelectedTool(event);
        };
      } else {
        // mouse or touch events
        callback = function (event) {
          augmentEventOffsets(event);
          applySelectedTool(event);
        };
      }
      // store callback
      callbackStore[layerId][eventType] = callback;
    }

    return callbackStore[layerId][eventType];
  }

}; // class ToolboxController

// namespaces
var dwv = dwv || {};
dwv.ctrl = dwv.ctrl || {};

/**
 * View controller.
 *
 * @param {dwv.image.View} view The associated view.
 * @param {number} index The associated data index.
 * @class
 */
dwv.ctrl.ViewController = function (view, index) {
  // closure to self
  var self = this;
  // third dimension player ID (created by setInterval)
  var playerID = null;
  // associated data index
  var dataIndex = index;

  // check view
  if (typeof view.getImage() === 'undefined') {
    throw new Error('View does not have an image, cannot setup controller');
  }

  // setup the plane helper
  var planeHelper = new dwv.image.PlaneHelper(
    view.getImage().getGeometry().getRealSpacing(),
    view.getImage().getGeometry().getOrientation(),
    view.getOrientation()
  );

  // mask segment helper
  var maskSegmentHelper;
  if (view.getImage().getMeta().Modality === 'SEG') {
    maskSegmentHelper = new dwv.image.MaskSegmentHelper(view.getImage());
  }

  /**
   * Listener handler.
   *
   * @private
   * @type {object}
   */
  var listenerHandler = new dwv.utils.ListenerHandler();

  /**
   * Get the plane helper.
   *
   * @returns {object} The helper.
   */
  this.getPlaneHelper = function () {
    return planeHelper;
  };

  /**
   * Check is the associated image is a mask.
   *
   * @returns {boolean} True if the associated image is a mask.
   */
  this.isMask = function () {
    return typeof maskSegmentHelper !== 'undefined';
  };

  /**
   * Get the mask segment helper.
   *
   * @returns {object} The helper.
   */
  this.getMaskSegmentHelper = function () {
    return maskSegmentHelper;
  };

  /**
   * Apply the hidden segments list by setting
   * the corresponding alpha function.
   */
  this.applyHiddenSegments = function () {
    if (this.isMask) {
      this.setViewAlphaFunction(maskSegmentHelper.getAlphaFunc());
    }
  };

  /**
   * Delete a segment.
   *
   * @param {number} segmentNumber The segment number.
   * @param {Function} exeCallback The post execution callback.
   */
  this.deleteSegment = function (segmentNumber, exeCallback) {
    if (this.isMask) {
      maskSegmentHelper.deleteSegment(segmentNumber, fireEvent, exeCallback);
    }
  };

  /**
   * Initialise the controller.
   */
  this.initialise = function () {
    // set window/level to first preset
    this.setWindowLevelPresetById(0);
    // default position
    this.setCurrentPosition(this.getPositionFromPlanePoint(0, 0));
  };

  /**
   * Get the window/level presets names.
   *
   * @returns {Array} The presets names.
   */
  this.getWindowLevelPresetsNames = function () {
    return view.getWindowPresetsNames();
  };

  /**
   * Add window/level presets to the view.
   *
   * @param {object} presets A preset object.
   * @returns {object} The list of presets.
   */
  this.addWindowLevelPresets = function (presets) {
    return view.addWindowPresets(presets);
  };

  /**
   * Set the window level to the preset with the input name.
   *
   * @param {string} name The name of the preset to activate.
   */
  this.setWindowLevelPreset = function (name) {
    view.setWindowLevelPreset(name);
  };

  /**
   * Set the window level to the preset with the input id.
   *
   * @param {number} id The id of the preset to activate.
   */
  this.setWindowLevelPresetById = function (id) {
    view.setWindowLevelPresetById(id);
  };

  /**
   * Check if the controller is playing.
   *
   * @returns {boolean} True if the controler is playing.
   */
  this.isPlaying = function () {
    return (playerID !== null);
  };

  /**
   * Get the current position.
   *
   * @returns {dwv.math.Point} The position.
   */
  this.getCurrentPosition = function () {
    return view.getCurrentPosition();
  };

  /**
   * Get the current index.
   *
   * @returns {dwv.math.Index} The current index.
   */
  this.getCurrentIndex = function () {
    return view.getCurrentIndex();
  };

  /**
   * Get the current oriented index.
   *
   * @returns {dwv.math.Index} The index.
   */
  this.getCurrentOrientedIndex = function () {
    var res = view.getCurrentIndex();
    if (typeof view.getOrientation() !== 'undefined') {
      // view oriented => image de-oriented
      var vector = planeHelper.getImageDeOrientedVector3D(
        new dwv.math.Vector3D(res.get(0), res.get(1), res.get(2))
      );
      res = new dwv.math.Index([
        vector.getX(), vector.getY(), vector.getZ()
      ]);
    }
    return res;
  };

  /**
   * Get the scroll index.
   *
   * @returns {number} The index.
   */
  this.getScrollIndex = function () {
    return view.getScrollIndex();
  };

  /**
   * Get the current scroll index value.
   *
   * @returns {object} The value.
   */
  this.getCurrentScrollIndexValue = function () {
    return view.getCurrentIndex().get(view.getScrollIndex());
  };

  this.getOrigin = function (position) {
    return view.getOrigin(position);
  };

  /**
   * Get the current scroll position value.
   *
   * @returns {object} The value.
   */
  this.getCurrentScrollPosition = function () {
    var scrollIndex = view.getScrollIndex();
    return view.getCurrentPosition().get(scrollIndex);
  };

  /**
   * Generate display image data to be given to a canvas.
   *
   * @param {Array} array The array to fill in.
   * @param {dwv.math.Point} position Optional position at which to generate,
   *   otherwise generates at current position.
   */
  this.generateImageData = function (array, position) {
    view.generateImageData(array, position);
  };

  /**
   * Set the associated image.
   *
   * @param {Image} img The associated image.
   * @param {number} index The data index of the image.
   */
  this.setImage = function (img, index) {
    view.setImage(img);
    dataIndex = index;
  };

  /**
   * Get the current spacing.
   *
   * @returns {Array} The 2D spacing.
   */
  this.get2DSpacing = function () {
    var spacing = view.getImage().getGeometry().getSpacing();
    return [spacing.get(0), spacing.get(1)];
  };

  /**
   * Get the image rescaled value at the input position.
   *
   * @param {dwv.math.Point} position the input position.
   * @returns {number|undefined} The image value or undefined if out of bounds
   *   or no quantifiable (for ex RGB).
   */
  this.getRescaledImageValue = function (position) {
    var image = view.getImage();
    if (!image.canQuantify()) {
      return;
    }
    var geometry = image.getGeometry();
    var index = geometry.worldToIndex(position);
    var value;
    if (geometry.isIndexInBounds(index)) {
      value = image.getRescaledValueAtIndex(index);
    }
    return value;
  };

  /**
   * Get the image pixel unit.
   *
   * @returns {string} The unit
   */
  this.getPixelUnit = function () {
    return view.getImage().getMeta().pixelUnit;
  };

  /**
   * Get some values from the associated image in a region.
   *
   * @param {dwv.math.Point2D} min Minimum point.
   * @param {dwv.math.Point2D} max Maximum point.
   * @returns {Array} A list of values.
   */
  this.getImageRegionValues = function (min, max) {
    var image = view.getImage();
    var orientation = view.getOrientation();
    var position = this.getCurrentIndex();
    var rescaled = true;

    // created oriented slice if needed
    if (!dwv.math.isIdentityMat33(orientation)) {
      // generate slice values
      var sliceIter = dwv.image.getSliceIterator(
        image,
        position,
        rescaled,
        orientation
      );
      var sliceValues = dwv.image.getIteratorValues(sliceIter);
      // oriented geometry
      var orientedSize = image.getGeometry().getSize(orientation);
      var sizeValues = orientedSize.getValues();
      sizeValues[2] = 1;
      var sliceSize = new dwv.image.Size(sizeValues);
      var orientedSpacing = image.getGeometry().getSpacing(orientation);
      var spacingValues = orientedSpacing.getValues();
      spacingValues[2] = 1;
      var sliceSpacing = new dwv.image.Spacing(spacingValues);
      var sliceOrigin = new dwv.math.Point3D(0, 0, 0);
      var sliceGeometry =
        new dwv.image.Geometry(sliceOrigin, sliceSize, sliceSpacing);
      // slice image
      image = new dwv.image.Image(sliceGeometry, sliceValues);
      // update position
      position = new dwv.math.Index([0, 0, 0]);
      rescaled = false;
    }

    // get region values
    var iter = dwv.image.getRegionSliceIterator(
      image, position, rescaled, min, max);
    var values = [];
    if (iter) {
      values = dwv.image.getIteratorValues(iter);
    }
    return values;
  };

  /**
   * Get some values from the associated image in variable regions.
   *
   * @param {Array} regions A list of regions.
   * @returns {Array} A list of values.
   */
  this.getImageVariableRegionValues = function (regions) {
    var iter = dwv.image.getVariableRegionSliceIterator(
      view.getImage(),
      this.getCurrentIndex(),
      true, regions
    );
    var values = [];
    if (iter) {
      values = dwv.image.getIteratorValues(iter);
    }
    return values;
  };

  /**
   * Can the image values be quantified?
   *
   * @returns {boolean} True if possible.
   */
  this.canQuantifyImage = function () {
    return view.getImage().canQuantify();
  };

  /**
   * Can window and level be applied to the data?
   *
   * @returns {boolean} True if possible.
   */
  this.canWindowLevel = function () {
    return view.getImage().canWindowLevel();
  };

  /**
   * Can the data be scrolled?
   *
   * @returns {boolean} True if the data has either the third dimension
   * or above greater than one.
   */
  this.canScroll = function () {
    return view.getImage().canScroll(view.getOrientation());
  };

  /**
   * Get the image size.
   *
   * @returns {dwv.image.Size} The size.
   */
  this.getImageSize = function () {
    return view.getImage().getGeometry().getSize(view.getOrientation());
  };

  /**
   * Get the image world (mm) 2D size.
   *
   * @returns {object} The 2D size as {x,y}.
   */
  this.getImageWorldSize = function () {
    var geometry = view.getImage().getGeometry();
    var size = geometry.getSize(view.getOrientation()).get2D();
    var spacing = geometry.getSpacing(view.getOrientation()).get2D();
    return {
      x: size.x * spacing.x,
      y: size.y * spacing.y
    };
  };

  /**
   * Get the image rescaled data range.
   *
   * @returns {object} The range as {min, max}.
   */
  this.getImageRescaledDataRange = function () {
    return view.getImage().getRescaledDataRange();
  };

  /**
   * Compare the input meta data to the associated image one.
   *
   * @param {object} meta The meta data.
   * @returns {boolean} True if the associated image has equal meta data.
   */
  this.equalImageMeta = function (meta) {
    var imageMeta = view.getImage().getMeta();
    // loop through input meta keys
    var metaKeys = Object.keys(meta);
    for (var i = 0; i < metaKeys.length; ++i) {
      var metaKey = metaKeys[i];
      if (typeof imageMeta[metaKey] === 'undefined') {
        return false;
      }
      if (imageMeta[metaKey] !== meta[metaKey]) {
        return false;
      }
    }
    return true;
  };

  /**
   * Check is the provided position can be set.
   *
   * @param {dwv.math.Point} position The position.
   * @returns {boolean} True is the position is in bounds.
   */
  this.canSetPosition = function (position) {
    return view.canSetPosition(position);
  };

  /**
   * Set the current position.
   *
   * @param {dwv.math.Point} pos The position.
   * @param {boolean} silent If true, does not fire a positionchange event.
   * @returns {boolean} False if not in bounds.
   */
  this.setCurrentPosition = function (pos, silent) {
    return view.setCurrentPosition(pos, silent);
  };

  /**
   * Get a position from a 2D (x,y) position.
   *
   * @param {number} x The column position.
   * @param {number} y The row position.
   * @returns {dwv.math.Point} The associated position.
   */
  this.getPositionFromPlanePoint = function (x, y) {
    // keep third direction
    var k = this.getCurrentScrollIndexValue();
    var planePoint = new dwv.math.Point3D(x, y, k);
    // de-orient
    var point = planeHelper.getImageOrientedVector3D(planePoint);
    // ~indexToWorld to not loose precision
    var geometry = view.getImage().getGeometry();
    var point3D = geometry.pointToWorld(point);
    // merge with current position to keep extra dimensions
    return this.getCurrentPosition().mergeWith3D(point3D);
  };

  /**
   * Get a 2D (x,y) position from a position.
   *
   * @param {dwv.math.Point3D} point3D The 3D position.
   * @returns {object} The 2D position.
   */
  this.getPlanePositionFromPosition = function (point3D) {
    // orient
    var geometry = view.getImage().getGeometry();
    // ~worldToIndex to not loose precision
    var point = geometry.worldToPoint(point3D);
    var planePoint = planeHelper.getImageDeOrientedVector3D(point);
    // return
    return {
      x: planePoint.getX(),
      y: planePoint.getY(),
    };
  };

  /**
   * Set the current index.
   *
   * @param {dwv.math.Index} index The index.
   * @param {boolean} silent If true, does not fire a positionchange event.
   * @returns {boolean} False if not in bounds.
   */
  this.setCurrentIndex = function (index, silent) {
    return view.setCurrentIndex(index, silent);
  };

  /**
   * Get a plane 3D position from a plane 2D position: does not compensate
   *   for the image origin. Needed for setting the scale center...
   *
   * @param {dwv.math.Point2D} point2D The 2D position as {x,y}.
   * @returns {dwv.math.Point3D} The 3D point.
   */
  this.getPlanePositionFromPlanePoint = function (point2D) {
    // keep third direction
    var k = this.getCurrentScrollIndexValue();
    var planePoint = new dwv.math.Point3D(point2D.x, point2D.y, k);
    // de-orient
    var point = planeHelper.getTargetDeOrientedVector3D(planePoint);
    // ~indexToWorld to not loose precision
    var geometry = view.getImage().getGeometry();
    var spacing = geometry.getRealSpacing();
    return new dwv.math.Point3D(
      point.getX() * spacing.get(0),
      point.getY() * spacing.get(1),
      point.getZ() * spacing.get(2));
  };

  /**
   * Get a 3D offset from a plane one.
   *
   * @param {object} offset2D The plane offset as {x,y}.
   * @returns {dwv.math.Vector3D} The 3D world offset.
   */
  this.getOffset3DFromPlaneOffset = function (offset2D) {
    return planeHelper.getOffset3DFromPlaneOffset(offset2D);
  };

  /**
   * Increment the provided dimension.
   *
   * @param {number} dim The dimension to increment.
   * @param {boolean} silent Do not send event.
   * @returns {boolean} False if not in bounds.
   */
  this.incrementIndex = function (dim, silent) {
    return view.incrementIndex(dim, silent);
  };

  /**
   * Decrement the provided dimension.
   *
   * @param {number} dim The dimension to increment.
   * @param {boolean} silent Do not send event.
   * @returns {boolean} False if not in bounds.
   */
  this.decrementIndex = function (dim, silent) {
    return view.decrementIndex(dim, silent);
  };

  /**
   * Decrement the scroll dimension index.
   *
   * @param {boolean} silent Do not send event.
   * @returns {boolean} False if not in bounds.
   */
  this.decrementScrollIndex = function (silent) {
    return view.decrementScrollIndex(silent);
  };

  /**
   * Increment the scroll dimension index.
   *
   * @param {boolean} silent Do not send event.
   * @returns {boolean} False if not in bounds.
   */
  this.incrementScrollIndex = function (silent) {
    return view.incrementScrollIndex(silent);
  };

  /**
   * Scroll play: loop through all slices.
   */
  this.play = function () {
    // ensure data is scrollable: dim >= 3
    if (!this.canScroll()) {
      return;
    }
    if (playerID === null) {
      var image = view.getImage();
      var recommendedDisplayFrameRate =
        image.getMeta().RecommendedDisplayFrameRate;
      var milliseconds = view.getPlaybackMilliseconds(
        recommendedDisplayFrameRate);
      var size = image.getGeometry().getSize();
      var canScroll3D = size.canScroll3D();

      playerID = setInterval(function () {
        var canDoMore = false;
        if (canScroll3D) {
          canDoMore = self.incrementScrollIndex();
        } else {
          canDoMore = self.incrementIndex(3);
        }
        // end of scroll, loop back
        if (!canDoMore) {
          var pos1 = self.getCurrentIndex();
          var values = pos1.getValues();
          var orientation = view.getOrientation();
          if (canScroll3D) {
            values[orientation.getThirdColMajorDirection()] = 0;
          } else {
            values[3] = 0;
          }
          var index = new dwv.math.Index(values);
          var geometry = view.getImage().getGeometry();
          self.setCurrentPosition(geometry.indexToWorld(index));
        }
      }, milliseconds);
    } else {
      this.stop();
    }
  };

  /**
   * Stop scroll playing.
   */
  this.stop = function () {
    if (playerID !== null) {
      clearInterval(playerID);
      playerID = null;
    }
  };

  /**
   * Get the window/level.
   *
   * @returns {object} The window center and width.
   */
  this.getWindowLevel = function () {
    return {
      width: view.getCurrentWindowLut().getWindowLevel().getWidth(),
      center: view.getCurrentWindowLut().getWindowLevel().getCenter()
    };
  };

  /**
   * Set the window/level.
   *
   * @param {number} wc The window center.
   * @param {number} ww The window width.
   */
  this.setWindowLevel = function (wc, ww) {
    view.setWindowLevel(wc, ww);
  };

  /**
   * Get the colour map.
   *
   * @returns {object} The colour map.
   */
  this.getColourMap = function () {
    return view.getColourMap();
  };

  /**
   * Set the colour map.
   *
   * @param {object} colourMap The colour map.
   */
  this.setColourMap = function (colourMap) {
    view.setColourMap(colourMap);
  };

  /**
   * Set the view per value alpha function.
   *
   * @param {Function} func The function.
   */
  this.setViewAlphaFunction = function (func) {
    view.setAlphaFunction(func);
  };

  /**
   * Set the colour map from a name.
   *
   * @param {string} name The name of the colour map to set.
   */
  this.setColourMapFromName = function (name) {
    // check if we have it
    if (!dwv.tool.colourMaps[name]) {
      throw new Error('Unknown colour map: \'' + name + '\'');
    }
    // enable it
    this.setColourMap(dwv.tool.colourMaps[name]);
  };

  /**
   * Add an event listener to this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type, will be called with the fired event.
   */
  this.addEventListener = function (type, callback) {
    listenerHandler.add(type, callback);
  };

  /**
   * Remove an event listener from this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type.
   */
  this.removeEventListener = function (type, callback) {
    listenerHandler.remove(type, callback);
  };

  /**
   * Fire an event: call all associated listeners with the input event object.
   *
   * @param {object} event The event to fire.
   * @private
   */
  function fireEvent(event) {
    event.dataid = dataIndex;
    listenerHandler.fireEvent(event);
  }

}; // class ViewController

// namespaces
var dwv = dwv || {};
dwv.dicom = dwv.dicom || {};

/**
 * Is the Native endianness Little Endian.
 *
 * @type {boolean}
 */
dwv.dicom.isNativeLittleEndian = function () {
  return new Int8Array(new Int16Array([1]).buffer)[0] > 0;
};

/**
 * Flip an array's endianness.
 * Inspired from [DataStream.js]{@link https://github.com/kig/DataStream.js}.
 *
 * @param {object} array The array to flip (modified).
 */
dwv.dicom.flipArrayEndianness = function (array) {
  var blen = array.byteLength;
  var u8 = new Uint8Array(array.buffer, array.byteOffset, blen);
  var bpe = array.BYTES_PER_ELEMENT;
  var tmp;
  for (var i = 0; i < blen; i += bpe) {
    for (var j = i + bpe - 1, k = i; j > k; j--, k++) {
      tmp = u8[k];
      u8[k] = u8[j];
      u8[j] = tmp;
    }
  }
};

/**
 * Data reader.
 *
 * @class
 * @param {Array} buffer The input array buffer.
 * @param {boolean} isLittleEndian Flag to tell if the data is little
 *   or big endian.
 */
dwv.dicom.DataReader = function (buffer, isLittleEndian) {
  // Set endian flag if not defined.
  if (typeof isLittleEndian === 'undefined') {
    isLittleEndian = true;
  }

  /**
   * Is the Native endianness Little Endian.
   *
   * @private
   * @type {boolean}
   */
  var isNativeLittleEndian = dwv.dicom.isNativeLittleEndian();

  /**
   * Flag to know if the TypedArray data needs flipping.
   *
   * @private
   * @type {boolean}
   */
  var needFlip = (isLittleEndian !== isNativeLittleEndian);

  /**
   * The main data view.
   *
   * @private
   * @type {DataView}
   */
  var view = new DataView(buffer);

  /**
   * Read Uint16 (2 bytes) data.
   *
   * @param {number} byteOffset The offset to start reading from.
   * @returns {number} The read data.
   */
  this.readUint16 = function (byteOffset) {
    return view.getUint16(byteOffset, isLittleEndian);
  };

  /**
   * Read Int16 (2 bytes) data.
   *
   * @param {number} byteOffset The offset to start reading from.
   * @returns {number} The read data.
   */
  this.readInt16 = function (byteOffset) {
    return view.getInt16(byteOffset, isLittleEndian);
  };

  /**
   * Read Uint32 (4 bytes) data.
   *
   * @param {number} byteOffset The offset to start reading from.
   * @returns {number} The read data.
   */
  this.readUint32 = function (byteOffset) {
    return view.getUint32(byteOffset, isLittleEndian);
  };

  /**
   * Read BigUint64 (8 bytes) data.
   *
   * @param {number} byteOffset The offset to start reading from.
   * @returns {number} The read data.
   */
  this.readBigUint64 = function (byteOffset) {
    return view.getBigUint64(byteOffset, isLittleEndian);
  };

  /**
   * Read Int32 (4 bytes) data.
   *
   * @param {number} byteOffset The offset to start reading from.
   * @returns {number} The read data.
   */
  this.readInt32 = function (byteOffset) {
    return view.getInt32(byteOffset, isLittleEndian);
  };

  /**
   * Read BigInt64 (8 bytes) data.
   *
   * @param {number} byteOffset The offset to start reading from.
   * @returns {number} The read data.
   */
  this.readBigInt64 = function (byteOffset) {
    return view.getBigInt64(byteOffset, isLittleEndian);
  };

  /**
   * Read Float32 (4 bytes) data.
   *
   * @param {number} byteOffset The offset to start reading from.
   * @returns {number} The read data.
   */
  this.readFloat32 = function (byteOffset) {
    return view.getFloat32(byteOffset, isLittleEndian);
  };

  /**
   * Read Float64 (8 bytes) data.
   *
   * @param {number} byteOffset The offset to start reading from.
   * @returns {number} The read data.
   */
  this.readFloat64 = function (byteOffset) {
    return view.getFloat64(byteOffset, isLittleEndian);
  };

  /**
   * Read binary (0/1) array.
   *
   * @param {number} byteOffset The offset to start reading from.
   * @param {number} size The size of the array.
   * @returns {Array} The read data.
   */
  this.readBinaryArray = function (byteOffset, size) {
    // input
    var bitArray = new Uint8Array(buffer, byteOffset, size);
    // result
    var byteArrayLength = 8 * bitArray.length;
    var data = new Uint8Array(byteArrayLength);
    var bitNumber = 0;
    var bitIndex = 0;
    for (var i = 0; i < byteArrayLength; ++i) {
      bitNumber = i % 8;
      bitIndex = Math.floor(i / 8);
      // see https://stackoverflow.com/questions/4854207/get-a-specific-bit-from-byte/4854257
      data[i] = 255 * ((bitArray[bitIndex] & (1 << bitNumber)) !== 0);
    }
    return data;
  };

  /**
   * Read Uint8 array.
   *
   * @param {number} byteOffset The offset to start reading from.
   * @param {number} size The size of the array.
   * @returns {Array} The read data.
   */
  this.readUint8Array = function (byteOffset, size) {
    return new Uint8Array(buffer, byteOffset, size);
  };

  /**
   * Read Int8 array.
   *
   * @param {number} byteOffset The offset to start reading from.
   * @param {number} size The size of the array.
   * @returns {Array} The read data.
   */
  this.readInt8Array = function (byteOffset, size) {
    return new Int8Array(buffer, byteOffset, size);
  };

  /**
   * Read Uint16 array.
   *
   * @param {number} byteOffset The offset to start reading from.
   * @param {number} size The size of the array.
   * @returns {Array} The read data.
   */
  this.readUint16Array = function (byteOffset, size) {
    var bpe = Uint16Array.BYTES_PER_ELEMENT;
    var arraySize = size / bpe;
    var data = null;
    // byteOffset should be a multiple of Uint16Array.BYTES_PER_ELEMENT (=2)
    if (byteOffset % bpe === 0) {
      data = new Uint16Array(buffer, byteOffset, arraySize);
      if (needFlip) {
        dwv.dicom.flipArrayEndianness(data);
      }
    } else {
      data = new Uint16Array(arraySize);
      for (var i = 0; i < arraySize; ++i) {
        data[i] = this.readUint16(byteOffset + bpe * i);
      }
    }
    return data;
  };

  /**
   * Read Int16 array.
   *
   * @param {number} byteOffset The offset to start reading from.
   * @param {number} size The size of the array.
   * @returns {Array} The read data.
   */
  this.readInt16Array = function (byteOffset, size) {
    var bpe = Int16Array.BYTES_PER_ELEMENT;
    var arraySize = size / bpe;
    var data = null;
    // byteOffset should be a multiple of Int16Array.BYTES_PER_ELEMENT (=2)
    if (byteOffset % bpe === 0) {
      data = new Int16Array(buffer, byteOffset, arraySize);
      if (needFlip) {
        dwv.dicom.flipArrayEndianness(data);
      }
    } else {
      data = new Int16Array(arraySize);
      for (var i = 0; i < arraySize; ++i) {
        data[i] = this.readInt16(byteOffset + bpe * i);
      }
    }
    return data;
  };

  /**
   * Read Uint32 array.
   *
   * @param {number} byteOffset The offset to start reading from.
   * @param {number} size The size of the array.
   * @returns {Array} The read data.
   */
  this.readUint32Array = function (byteOffset, size) {
    var bpe = Uint32Array.BYTES_PER_ELEMENT;
    var arraySize = size / bpe;
    var data = null;
    // byteOffset should be a multiple of Uint32Array.BYTES_PER_ELEMENT (=4)
    if (byteOffset % bpe === 0) {
      data = new Uint32Array(buffer, byteOffset, arraySize);
      if (needFlip) {
        dwv.dicom.flipArrayEndianness(data);
      }
    } else {
      data = new Uint32Array(arraySize);
      for (var i = 0; i < arraySize; ++i) {
        data[i] = this.readUint32(byteOffset + bpe * i);
      }
    }
    return data;
  };

  /**
   * Read Uint64 array.
   *
   * @param {number} byteOffset The offset to start reading from.
   * @param {number} size The size of the array.
   * @returns {Array} The read data.
   */
  this.readUint64Array = function (byteOffset, size) {
    var bpe = BigUint64Array.BYTES_PER_ELEMENT;
    var arraySize = size / bpe;
    var data = null;
    // byteOffset should be a multiple of BigUint64Array.BYTES_PER_ELEMENT (=8)
    if (byteOffset % bpe === 0) {
      data = new BigUint64Array(buffer, byteOffset, arraySize);
      if (needFlip) {
        dwv.dicom.flipArrayEndianness(data);
      }
    } else {
      data = new BigUint64Array(arraySize);
      for (var i = 0; i < arraySize; ++i) {
        data[i] = this.readBigUint64(byteOffset + bpe * i);
      }
    }
    return data;
  };

  /**
   * Read Int32 array.
   *
   * @param {number} byteOffset The offset to start reading from.
   * @param {number} size The size of the array.
   * @returns {Array} The read data.
   */
  this.readInt32Array = function (byteOffset, size) {
    var bpe = Int32Array.BYTES_PER_ELEMENT;
    var arraySize = size / bpe;
    var data = null;
    // byteOffset should be a multiple of Int32Array.BYTES_PER_ELEMENT (=4)
    if (byteOffset % bpe === 0) {
      data = new Int32Array(buffer, byteOffset, arraySize);
      if (needFlip) {
        dwv.dicom.flipArrayEndianness(data);
      }
    } else {
      data = new Int32Array(arraySize);
      for (var i = 0; i < arraySize; ++i) {
        data[i] = this.readInt32(byteOffset + bpe * i);
      }
    }
    return data;
  };

  /**
   * Read Int64 array.
   *
   * @param {number} byteOffset The offset to start reading from.
   * @param {number} size The size of the array.
   * @returns {Array} The read data.
   */
  this.readInt64Array = function (byteOffset, size) {
    var bpe = BigInt64Array.BYTES_PER_ELEMENT;
    var arraySize = size / bpe;
    var data = null;
    // byteOffset should be a multiple of BigInt64Array.BYTES_PER_ELEMENT (=8)
    if (byteOffset % bpe === 0) {
      data = new BigInt64Array(buffer, byteOffset, arraySize);
      if (needFlip) {
        dwv.dicom.flipArrayEndianness(data);
      }
    } else {
      data = new BigInt64Array(arraySize);
      for (var i = 0; i < arraySize; ++i) {
        data[i] = this.readBigInt64(byteOffset + bpe * i);
      }
    }
    return data;
  };

  /**
   * Read Float32 array.
   *
   * @param {number} byteOffset The offset to start reading from.
   * @param {number} size The size of the array.
   * @returns {Array} The read data.
   */
  this.readFloat32Array = function (byteOffset, size) {
    var bpe = Float32Array.BYTES_PER_ELEMENT;
    var arraySize = size / bpe;
    var data = null;
    // byteOffset should be a multiple of Float32Array.BYTES_PER_ELEMENT (=4)
    if (byteOffset % bpe === 0) {
      data = new Float32Array(buffer, byteOffset, arraySize);
      if (needFlip) {
        dwv.dicom.flipArrayEndianness(data);
      }
    } else {
      data = new Float32Array(arraySize);
      for (var i = 0; i < arraySize; ++i) {
        data[i] = this.readFloat32(byteOffset + bpe * i);
      }
    }
    return data;
  };

  /**
   * Read Float64 array.
   *
   * @param {number} byteOffset The offset to start reading from.
   * @param {number} size The size of the array.
   * @returns {Array} The read data.
   */
  this.readFloat64Array = function (byteOffset, size) {
    var bpe = Float64Array.BYTES_PER_ELEMENT;
    var arraySize = size / bpe;
    var data = null;
    // byteOffset should be a multiple of Float64Array.BYTES_PER_ELEMENT (=8)
    if (byteOffset % bpe === 0) {
      data = new Float64Array(buffer, byteOffset, arraySize);
      if (needFlip) {
        dwv.dicom.flipArrayEndianness(data);
      }
    } else {
      data = new Float64Array(arraySize);
      for (var i = 0; i < arraySize; ++i) {
        data[i] = this.readFloat64(byteOffset + bpe * i);
      }
    }
    return data;
  };
}; // class DataReader

/**
 * Read data as an hexadecimal string.
 *
 * @param {number} byteOffset The offset to start reading from.
 * @returns {Array} The read data.
 */
dwv.dicom.DataReader.prototype.readHex = function (byteOffset) {
  // read and convert to hex string
  var str = this.readUint16(byteOffset).toString(16);
  // return padded
  return '0x0000'.substring(0, 6 - str.length) + str.toUpperCase();
};

// namespaces
var dwv = dwv || {};
dwv.dicom = dwv.dicom || {};

/**
 * Data writer.
 *
 * @class
 * @param {Array} buffer The input array buffer.
 * @param {boolean} isLittleEndian Flag to tell if the data is
 *   little or big endian.
 */
dwv.dicom.DataWriter = function (buffer, isLittleEndian) {
  // Set endian flag if not defined.
  if (typeof isLittleEndian === 'undefined') {
    isLittleEndian = true;
  }

  // private DataView
  var view = new DataView(buffer);

  // flag to use VR=UN for private sequences, default to false
  // (mainly used in tests)
  this.useUnVrForPrivateSq = false;

  /**
   * Write Uint8 data.
   *
   * @param {number} byteOffset The offset to start writing from.
   * @param {number} value The data to write.
   * @returns {number} The new offset position.
   */
  this.writeUint8 = function (byteOffset, value) {
    view.setUint8(byteOffset, value);
    return byteOffset + Uint8Array.BYTES_PER_ELEMENT;
  };

  /**
   * Write Int8 data.
   *
   * @param {number} byteOffset The offset to start writing from.
   * @param {number} value The data to write.
   * @returns {number} The new offset position.
   */
  this.writeInt8 = function (byteOffset, value) {
    view.setInt8(byteOffset, value);
    return byteOffset + Int8Array.BYTES_PER_ELEMENT;
  };

  /**
   * Write Uint16 data.
   *
   * @param {number} byteOffset The offset to start writing from.
   * @param {number} value The data to write.
   * @returns {number} The new offset position.
   */
  this.writeUint16 = function (byteOffset, value) {
    view.setUint16(byteOffset, value, isLittleEndian);
    return byteOffset + Uint16Array.BYTES_PER_ELEMENT;
  };

  /**
   * Write Int16 data.
   *
   * @param {number} byteOffset The offset to start writing from.
   * @param {number} value The data to write.
   * @returns {number} The new offset position.
   */
  this.writeInt16 = function (byteOffset, value) {
    view.setInt16(byteOffset, value, isLittleEndian);
    return byteOffset + Int16Array.BYTES_PER_ELEMENT;
  };

  /**
   * Write Uint32 data.
   *
   * @param {number} byteOffset The offset to start writing from.
   * @param {number} value The data to write.
   * @returns {number} The new offset position.
   */
  this.writeUint32 = function (byteOffset, value) {
    view.setUint32(byteOffset, value, isLittleEndian);
    return byteOffset + Uint32Array.BYTES_PER_ELEMENT;
  };

  /**
   * Write Uint64 data.
   *
   * @param {number} byteOffset The offset to start writing from.
   * @param {number} value The data to write.
   * @returns {number} The new offset position.
   */
  this.writeUint64 = function (byteOffset, value) {
    view.setBigUint64(byteOffset, value, isLittleEndian);
    return byteOffset + BigUint64Array.BYTES_PER_ELEMENT;
  };

  /**
   * Write Int32 data.
   *
   * @param {number} byteOffset The offset to start writing from.
   * @param {number} value The data to write.
   * @returns {number} The new offset position.
   */
  this.writeInt32 = function (byteOffset, value) {
    view.setInt32(byteOffset, value, isLittleEndian);
    return byteOffset + Int32Array.BYTES_PER_ELEMENT;
  };

  /**
   * Write Int64 data.
   *
   * @param {number} byteOffset The offset to start writing from.
   * @param {number} value The data to write.
   * @returns {number} The new offset position.
   */
  this.writeInt64 = function (byteOffset, value) {
    view.setBigInt64(byteOffset, value, isLittleEndian);
    return byteOffset + BigInt64Array.BYTES_PER_ELEMENT;
  };

  /**
   * Write Float32 data.
   *
   * @param {number} byteOffset The offset to start writing from.
   * @param {number} value The data to write.
   * @returns {number} The new offset position.
   */
  this.writeFloat32 = function (byteOffset, value) {
    view.setFloat32(byteOffset, value, isLittleEndian);
    return byteOffset + Float32Array.BYTES_PER_ELEMENT;
  };

  /**
   * Write Float64 data.
   *
   * @param {number} byteOffset The offset to start writing from.
   * @param {number} value The data to write.
   * @returns {number} The new offset position.
   */
  this.writeFloat64 = function (byteOffset, value) {
    view.setFloat64(byteOffset, value, isLittleEndian);
    return byteOffset + Float64Array.BYTES_PER_ELEMENT;
  };

  /**
   * Write string data as hexadecimal.
   *
   * @param {number} byteOffset The offset to start writing from.
   * @param {number} str The padded hexadecimal string to write ('0x####').
   * @returns {number} The new offset position.
   */
  this.writeHex = function (byteOffset, str) {
    // remove first two chars and parse
    var value = parseInt(str.substring(2), 16);
    view.setUint16(byteOffset, value, isLittleEndian);
    return byteOffset + Uint16Array.BYTES_PER_ELEMENT;
  };

}; // class DataWriter

/**
 * Write a boolean array as binary.
 *
 * @param {number} byteOffset The offset to start writing from.
 * @param {Array} array The array to write.
 * @returns {number} The new offset position.
 */
dwv.dicom.DataWriter.prototype.writeBinaryArray = function (byteOffset, array) {
  if (array.length % 8 !== 0) {
    throw new Error('Cannot write boolean array as binary.');
  }
  var byte = null;
  var val = null;
  for (var i = 0, len = array.length; i < len; i += 8) {
    byte = 0;
    for (var j = 0; j < 8; ++j) {
      val = array[i + j] === 0 ? 0 : 1;
      byte += val << j;
    }
    byteOffset = this.writeUint8(byteOffset, byte);
  }
  return byteOffset;
};

/**
 * Write Uint8 array.
 *
 * @param {number} byteOffset The offset to start writing from.
 * @param {Array} array The array to write.
 * @returns {number} The new offset position.
 */
dwv.dicom.DataWriter.prototype.writeUint8Array = function (byteOffset, array) {
  for (var i = 0, len = array.length; i < len; ++i) {
    byteOffset = this.writeUint8(byteOffset, array[i]);
  }
  return byteOffset;
};

/**
 * Write Int8 array.
 *
 * @param {number} byteOffset The offset to start writing from.
 * @param {Array} array The array to write.
 * @returns {number} The new offset position.
 */
dwv.dicom.DataWriter.prototype.writeInt8Array = function (byteOffset, array) {
  for (var i = 0, len = array.length; i < len; ++i) {
    byteOffset = this.writeInt8(byteOffset, array[i]);
  }
  return byteOffset;
};

/**
 * Write Uint16 array.
 *
 * @param {number} byteOffset The offset to start writing from.
 * @param {Array} array The array to write.
 * @returns {number} The new offset position.
 */
dwv.dicom.DataWriter.prototype.writeUint16Array = function (byteOffset, array) {
  for (var i = 0, len = array.length; i < len; ++i) {
    byteOffset = this.writeUint16(byteOffset, array[i]);
  }
  return byteOffset;
};

/**
 * Write Int16 array.
 *
 * @param {number} byteOffset The offset to start writing from.
 * @param {Array} array The array to write.
 * @returns {number} The new offset position.
 */
dwv.dicom.DataWriter.prototype.writeInt16Array = function (byteOffset, array) {
  for (var i = 0, len = array.length; i < len; ++i) {
    byteOffset = this.writeInt16(byteOffset, array[i]);
  }
  return byteOffset;
};

/**
 * Write Uint32 array.
 *
 * @param {number} byteOffset The offset to start writing from.
 * @param {Array} array The array to write.
 * @returns {number} The new offset position.
 */
dwv.dicom.DataWriter.prototype.writeUint32Array = function (byteOffset, array) {
  for (var i = 0, len = array.length; i < len; ++i) {
    byteOffset = this.writeUint32(byteOffset, array[i]);
  }
  return byteOffset;
};

/**
 * Write Uint64 array.
 *
 * @param {number} byteOffset The offset to start writing from.
 * @param {Array} array The array to write.
 * @returns {number} The new offset position.
 */
dwv.dicom.DataWriter.prototype.writeUint64Array = function (byteOffset, array) {
  for (var i = 0, len = array.length; i < len; ++i) {
    byteOffset = this.writeUint64(byteOffset, array[i]);
  }
  return byteOffset;
};

/**
 * Write Int32 array.
 *
 * @param {number} byteOffset The offset to start writing from.
 * @param {Array} array The array to write.
 * @returns {number} The new offset position.
 */
dwv.dicom.DataWriter.prototype.writeInt32Array = function (byteOffset, array) {
  for (var i = 0, len = array.length; i < len; ++i) {
    byteOffset = this.writeInt32(byteOffset, array[i]);
  }
  return byteOffset;
};

/**
 * Write Int64 array.
 *
 * @param {number} byteOffset The offset to start writing from.
 * @param {Array} array The array to write.
 * @returns {number} The new offset position.
 */
dwv.dicom.DataWriter.prototype.writeInt64Array = function (byteOffset, array) {
  for (var i = 0, len = array.length; i < len; ++i) {
    byteOffset = this.writeInt64(byteOffset, array[i]);
  }
  return byteOffset;
};

/**
 * Write Float32 array.
 *
 * @param {number} byteOffset The offset to start writing from.
 * @param {Array} array The array to write.
 * @returns {number} The new offset position.
 */
dwv.dicom.DataWriter.prototype.writeFloat32Array = function (
  byteOffset, array) {
  for (var i = 0, len = array.length; i < len; ++i) {
    byteOffset = this.writeFloat32(byteOffset, array[i]);
  }
  return byteOffset;
};

/**
 * Write Float64 array.
 *
 * @param {number} byteOffset The offset to start writing from.
 * @param {Array} array The array to write.
 * @returns {number} The new offset position.
 */
dwv.dicom.DataWriter.prototype.writeFloat64Array = function (
  byteOffset, array) {
  for (var i = 0, len = array.length; i < len; ++i) {
    byteOffset = this.writeFloat64(byteOffset, array[i]);
  }
  return byteOffset;
};

// namespaces
var dwv = dwv || {};
dwv.dicom = dwv.dicom || {};

/**
 * DicomElements wrapper.
 *
 * @class
 * @param {Array} dicomElements The elements to wrap.
 */
dwv.dicom.DicomElementsWrapper = function (dicomElements) {

  /**
   * Get a DICOM Element value from a group/element key.
   *
   * @param {string} groupElementKey The key to retrieve.
   * @returns {object} The DICOM element.
   */
  this.getDEFromKey = function (groupElementKey) {
    return dicomElements[groupElementKey];
  };

  /**
   * Get a DICOM Element value from a group/element key.
   *
   * @param {string} groupElementKey The key to retrieve.
   * @param {boolean} asArray Get the value as an Array.
   * @returns {object} The DICOM element value.
   */
  this.getFromKey = function (groupElementKey, asArray) {
    // default
    if (typeof asArray === 'undefined') {
      asArray = false;
    }
    var value = null;
    var dElement = dicomElements[groupElementKey];
    if (typeof dElement !== 'undefined') {
      // raw value if only one
      if (dElement.value.length === 1 && asArray === false) {
        value = dElement.value[0];
      } else {
        value = dElement.value;
      }
    }
    return value;
  };

  /**
   * Dump the DICOM tags to an object.
   *
   * @returns {object} The DICOM tags as an object.
   */
  this.dumpToObject = function () {
    var keys = Object.keys(dicomElements);
    var obj = {};
    var dicomElement = null;
    for (var i = 0, leni = keys.length; i < leni; ++i) {
      dicomElement = dicomElements[keys[i]];
      obj[this.getTagName(dicomElement.tag)] =
        this.getElementAsObject(dicomElement);
    }
    return obj;
  };

  /**
   * Get a tag string name from the dictionary.
   *
   * @param {object} tag The DICOM tag object.
   * @returns {string} The tag name.
   */
  this.getTagName = function (tag) {
    var name = tag.getNameFromDictionary();
    if (name === null) {
      name = tag.getKey2();
    }
    return name;
  };

  /**
   * Get a DICOM element as a simple object.
   *
   * @param {object} dicomElement The DICOM element.
   * @returns {object} The element as a simple object.
   */
  this.getElementAsObject = function (dicomElement) {
    // element value
    var value = null;

    var isPixel = dwv.dicom.isPixelDataTag(dicomElement.tag);

    var vr = dicomElement.vr;
    if (vr === 'SQ' &&
      typeof dicomElement.value !== 'undefined' &&
      !isPixel) {
      value = [];
      var items = dicomElement.value;
      var itemValues = null;
      for (var i = 0; i < items.length; ++i) {
        itemValues = {};
        var keys = Object.keys(items[i]);
        for (var k = 0; k < keys.length; ++k) {
          var itemElement = items[i][keys[k]];
          var key = this.getTagName(itemElement.tag);
          // do not inclure Item elements
          if (key !== 'Item') {
            itemValues[key] = this.getElementAsObject(itemElement);
          }
        }
        value.push(itemValues);
      }
    } else {
      value = this.getElementValueAsString(dicomElement);
    }

    // return
    return {
      value: value,
      group: dicomElement.tag.getGroup(),
      element: dicomElement.tag.getElement(),
      vr: vr,
      vl: dicomElement.vl
    };
  };

  /**
   * Dump the DICOM tags to a string.
   *
   * @returns {string} The dumped file.
   */
  this.dump = function () {
    var keys = Object.keys(dicomElements);
    var result = '\n';
    result += '# Dicom-File-Format\n';
    result += '\n';
    result += '# Dicom-Meta-Information-Header\n';
    result += '# Used TransferSyntax: ';
    if (dwv.dicom.isNativeLittleEndian()) {
      result += 'Little Endian Explicit\n';
    } else {
      result += 'NOT Little Endian Explicit\n';
    }
    var dicomElement = null;
    var checkHeader = true;
    for (var i = 0, leni = keys.length; i < leni; ++i) {
      dicomElement = dicomElements[keys[i]];
      if (checkHeader && dicomElement.tag.getGroup() !== '0x0002') {
        result += '\n';
        result += '# Dicom-Data-Set\n';
        result += '# Used TransferSyntax: ';
        var syntax = dwv.dicom.cleanString(dicomElements.x00020010.value[0]);
        result += dwv.dicom.getTransferSyntaxName(syntax);
        result += '\n';
        checkHeader = false;
      }
      result += this.getElementAsString(dicomElement) + '\n';
    }
    return result;
  };

};

/**
 * Get a data element value as a string.
 *
 * @param {object} dicomElement The DICOM element.
 * @param {boolean} pretty When set to true, returns a 'pretified' content.
 * @returns {string} A string representation of the DICOM element.
 */
dwv.dicom.DicomElementsWrapper.prototype.getElementValueAsString = function (
  dicomElement, pretty) {
  var str = '';
  var strLenLimit = 65;

  // dafault to pretty output
  if (typeof pretty === 'undefined') {
    pretty = true;
  }
  // check dicom element input
  if (typeof dicomElement === 'undefined' || dicomElement === null) {
    return str;
  }

  // Polyfill for Number.isInteger.
  var isInteger = Number.isInteger || function (value) {
    return typeof value === 'number' &&
      isFinite(value) &&
      Math.floor(value) === value;
  };

  // TODO Support sequences.

  if (dicomElement.vr !== 'SQ' &&
    dicomElement.value.length === 1 && dicomElement.value[0] === '') {
    str += '(no value available)';
  } else if (dwv.dicom.isPixelDataTag(dicomElement.tag) &&
    dicomElement.undefinedLength) {
    str = '(PixelSequence)';
  } else if (dicomElement.vr === 'DA' && pretty) {
    var daValue = dicomElement.value[0];
    // Two possible date formats:
    // - standard 'YYYYMMDD'
    // - non-standard 'YYYY.MM.DD' (previous ACR-NEMA)
    var monthBeginIndex = 4;
    var dayBeginIndex = 6;
    if (daValue.length !== 8) {
      monthBeginIndex = 5;
      dayBeginIndex = 8;
    }
    var da = new Date(
      parseInt(daValue.substring(0, 4), 10),
      parseInt(daValue.substring(
        monthBeginIndex, monthBeginIndex + 2), 10) - 1, // 0-11 range
      parseInt(daValue.substring(
        dayBeginIndex, dayBeginIndex + 2), 10));
    str = da.toLocaleDateString();
  } else if (dicomElement.vr === 'TM' && pretty) {
    var tmValue = dicomElement.value[0];
    var tmHour = tmValue.substring(0, 2);
    var tmMinute = tmValue.length >= 4 ? tmValue.substring(2, 4) : '00';
    var tmSeconds = tmValue.length >= 6 ? tmValue.substring(4, 6) : '00';
    str = tmHour + ':' + tmMinute + ':' + tmSeconds;
  } else {
    var isOtherVR = false;
    if (dicomElement.vr.length !== 0) {
      isOtherVR = (dicomElement.vr[0].toUpperCase() === 'O');
    }
    var isFloatNumberVR = (dicomElement.vr === 'FL' ||
      dicomElement.vr === 'FD' ||
      dicomElement.vr === 'DS');
    var valueStr = '';
    for (var k = 0, lenk = dicomElement.value.length; k < lenk; ++k) {
      valueStr = '';
      if (k !== 0) {
        valueStr += '\\';
      }
      if (isFloatNumberVR) {
        var val = dicomElement.value[k];
        if (typeof val === 'string') {
          val = dwv.dicom.cleanString(val);
        }
        var num = Number(val);
        if (!isInteger(num) && pretty) {
          valueStr += num.toPrecision(4);
        } else {
          valueStr += num.toString();
        }
      } else if (isOtherVR) {
        var tmp = dicomElement.value[k].toString(16);
        if (dicomElement.vr === 'OB') {
          tmp = '00'.substring(0, 2 - tmp.length) + tmp;
        } else {
          tmp = '0000'.substring(0, 4 - tmp.length) + tmp;
        }
        valueStr += tmp;
      } else if (typeof dicomElement.value[k] === 'string') {
        valueStr += dwv.dicom.cleanString(dicomElement.value[k]);
      } else {
        valueStr += dicomElement.value[k];
      }
      // check length
      if (str.length + valueStr.length <= strLenLimit) {
        str += valueStr;
      } else {
        str += '...';
        break;
      }
    }
  }
  return str;
};

/**
 * Get a data element value as a string.
 *
 * @param {string} groupElementKey The key to retrieve.
 * @returns {string} The element as a string.
 */
dwv.dicom.DicomElementsWrapper.prototype.getElementValueAsStringFromKey =
function (groupElementKey) {
  return this.getElementValueAsString(this.getDEFromKey(groupElementKey));
};

/**
 * Get a data element as a string.
 *
 * @param {object} dicomElement The DICOM element.
 * @param {string} prefix A string to prepend this one.
 * @returns {string} The element as a string.
 */
dwv.dicom.DicomElementsWrapper.prototype.getElementAsString = function (
  dicomElement, prefix) {
  // default prefix
  prefix = prefix || '';

  // get tag anme from dictionary
  var tag = dicomElement.tag;
  var tagName = tag.getNameFromDictionary();

  var deSize = dicomElement.value.length;
  var isOtherVR = false;
  if (dicomElement.vr.length !== 0) {
    isOtherVR = (dicomElement.vr[0].toUpperCase() === 'O');
  }

  // no size for delimitations
  if (dwv.dicom.isItemDelimitationItemTag(dicomElement.tag) ||
    dwv.dicom.isSequenceDelimitationItemTag(dicomElement.tag)) {
    deSize = 0;
  } else if (isOtherVR) {
    deSize = 1;
  }

  var isPixSequence = (dwv.dicom.isPixelDataTag(dicomElement.tag) &&
    dicomElement.undefinedLength);

  var line = null;

  // (group,element)
  line = '(';
  line += dicomElement.tag.getGroup().substring(2).toLowerCase();
  line += ',';
  line += dicomElement.tag.getElement().substring(2).toLowerCase();
  line += ') ';
  // value representation
  line += dicomElement.vr;
  // value
  if (dicomElement.vr !== 'SQ' &&
    dicomElement.value.length === 1 &&
    dicomElement.value[0] === '') {
    line += ' (no value available)';
    deSize = 0;
  } else {
    // simple number display
    if (dicomElement.vr === 'na') {
      line += ' ';
      line += dicomElement.value[0];
    } else if (isPixSequence) {
      // pixel sequence
      line += ' (PixelSequence #=' + deSize + ')';
    } else if (dicomElement.vr === 'SQ') {
      line += ' (Sequence with';
      if (dicomElement.undefinedLength) {
        line += ' undefined';
      } else {
        line += ' explicit';
      }
      line += ' length #=';
      line += dicomElement.value.length;
      line += ')';
    } else if (isOtherVR ||
        dicomElement.vr === 'pi' ||
        dicomElement.vr === 'UL' ||
        dicomElement.vr === 'US' ||
        dicomElement.vr === 'SL' ||
        dicomElement.vr === 'SS' ||
        dicomElement.vr === 'FL' ||
        dicomElement.vr === 'FD' ||
        dicomElement.vr === 'AT') {
      // 'O'ther array, limited display length
      line += ' ';
      line += this.getElementValueAsString(dicomElement, false);
    } else {
      // default
      line += ' [';
      line += this.getElementValueAsString(dicomElement, false);
      line += ']';
    }
  }

  // align #
  var nSpaces = 55 - line.length;
  if (nSpaces > 0) {
    for (var s = 0; s < nSpaces; ++s) {
      line += ' ';
    }
  }
  line += ' # ';
  if (dicomElement.vl < 100) {
    line += ' ';
  }
  if (dicomElement.vl < 10) {
    line += ' ';
  }
  line += dicomElement.vl;
  line += ', ';
  line += deSize; //dictElement[1];
  line += ' ';
  if (tagName !== null) {
    line += tagName;
  } else {
    line += 'Unknown Tag & Data';
  }

  var message = null;

  // continue for sequence
  if (dicomElement.vr === 'SQ') {
    var item = null;
    for (var l = 0, lenl = dicomElement.value.length; l < lenl; ++l) {
      item = dicomElement.value[l];
      var itemKeys = Object.keys(item);
      if (itemKeys.length === 0) {
        continue;
      }

      // get the item element
      var itemElement = item.xFFFEE000;
      message = '(Item with';
      if (itemElement.undefinedLength) {
        message += ' undefined';
      } else {
        message += ' explicit';
      }
      message += ' length #=' + (itemKeys.length - 1) + ')';
      itemElement.value = [message];
      itemElement.vr = 'na';

      line += '\n';
      line += this.getElementAsString(itemElement, prefix + '  ');

      for (var m = 0, lenm = itemKeys.length; m < lenm; ++m) {
        if (itemKeys[m] !== 'xFFFEE000') {
          line += '\n';
          line += this.getElementAsString(item[itemKeys[m]], prefix + '    ');
        }
      }

      message = '(ItemDelimitationItem';
      if (!itemElement.undefinedLength) {
        message += ' for re-encoding';
      }
      message += ')';
      var itemDelimElement = {
        tag: dwv.dicom.getItemDelimitationItemTag(),
        vr: 'na',
        vl: '0',
        value: [message]
      };
      line += '\n';
      line += this.getElementAsString(itemDelimElement, prefix + '  ');

    }

    message = '(SequenceDelimitationItem';
    if (!dicomElement.undefinedLength) {
      message += ' for re-encod.';
    }
    message += ')';
    var sqDelimElement = {
      tag: dwv.dicom.getSequenceDelimitationItemTag(),
      vr: 'na',
      vl: '0',
      value: [message]
    };
    line += '\n';
    line += this.getElementAsString(sqDelimElement, prefix);
  } else if (isPixSequence) {
    // pixel sequence
    var pixItem = null;
    for (var n = 0, lenn = dicomElement.value.length; n < lenn; ++n) {
      pixItem = dicomElement.value[n];
      line += '\n';
      pixItem.vr = 'pi';
      line += this.getElementAsString(pixItem, prefix + '  ');
    }

    var pixDelimElement = {
      tag: dwv.dicom.getSequenceDelimitationItemTag(),
      vr: 'na',
      vl: '0',
      value: ['(SequenceDelimitationItem)']
    };
    line += '\n';
    line += this.getElementAsString(pixDelimElement, prefix);
  }

  return prefix + line;
};

/**
 * Get a DICOM Element value from a group and an element.
 *
 * @param {number} group The group.
 * @param {number} element The element.
 * @returns {object} The DICOM element value.
 */
dwv.dicom.DicomElementsWrapper.prototype.getFromGroupElement = function (
  group, element) {
  return this.getFromKey(new dwv.dicom.Tag(group, element).getKey());
};

/**
 * Get a DICOM Element value from a tag name.
 * Uses the DICOM dictionary.
 *
 * @param {string} name The tag name.
 * @returns {object} The DICOM element value.
 */
dwv.dicom.DicomElementsWrapper.prototype.getFromName = function (name) {
  var value = null;
  var tag = dwv.dicom.getTagFromDictionary(name);
  // check that we are not at the end of the dictionary
  if (tag !== null) {
    value = this.getFromKey(tag.getKey());
  }
  return value;
};

/**
 * Extract a size from dicom elements.
 *
 * @returns {object} The size.
 */
dwv.dicom.DicomElementsWrapper.prototype.getImageSize = function () {
  // rows
  var rows = this.getFromKey('x00280010');
  if (!rows) {
    throw new Error('Missing or empty DICOM image number of rows');
  }
  // columns
  var columns = this.getFromKey('x00280011');
  if (!columns) {
    throw new Error('Missing or empty DICOM image number of columns');
  }
  return new dwv.image.Size([columns, rows, 1]);
};


/**
 * Get the pixel spacing from the different spacing tags.
 *
 * @returns {object} The read spacing or the default [1,1].
 */
dwv.dicom.DicomElementsWrapper.prototype.getPixelSpacing = function () {
  // default
  var rowSpacing = 1;
  var columnSpacing = 1;

  // 1. PixelSpacing
  // 2. ImagerPixelSpacing
  // 3. NominalScannedPixelSpacing
  // 4. PixelAspectRatio
  var keys = ['x00280030', 'x00181164', 'x00182010', 'x00280034'];
  for (var k = 0; k < keys.length; ++k) {
    var spacing = this.getFromKey(keys[k], true);
    if (spacing && spacing.length === 2) {
      rowSpacing = parseFloat(spacing[0]);
      columnSpacing = parseFloat(spacing[1]);
      break;
    }
  }

  // check
  if (columnSpacing === 0) {
    dwv.logger.warn('Zero column spacing.');
    columnSpacing = 1;
  }
  if (rowSpacing === 0) {
    dwv.logger.warn('Zero row spacing.');
    rowSpacing = 1;
  }

  // return
  // (slice spacing will be calculated using the image position patient)
  return new dwv.image.Spacing([columnSpacing, rowSpacing, 1]);
};

/**
 * Get the time.
 *
 * @returns {number|undefined} The time value if available.
 */
dwv.dicom.DicomElementsWrapper.prototype.getTime = function () {
  // default returns undefined
  return undefined;
};

/**
 * Get the pixel data unit.
 *
 * @returns {string|null} The unit value if available.
 */
dwv.dicom.DicomElementsWrapper.prototype.getPixelUnit = function () {
  // RescaleType
  var unit = this.getFromKey('x00281054');
  if (!unit) {
    // Units (for PET)
    unit = this.getFromKey('x00541001');
  }
  // default rescale type for CT
  if (!unit) {
    var modality = this.getFromKey('x00080060');
    if (modality === 'CT') {
      unit = 'HU';
    }
  }
  return unit;
};

/**
 * Get the file list from a DICOMDIR
 *
 * @param {object} data The buffer data of the DICOMDIR
 * @returns {Array|undefined} The file list as an array ordered by
 *   STUDY > SERIES > IMAGES.
 */
dwv.dicom.getFileListFromDicomDir = function (data) {
  // parse file
  var parser = new dwv.dicom.DicomParser();
  parser.parse(data);
  var elements = parser.getRawDicomElements();

  // Directory Record Sequence
  if (typeof elements.x00041220 === 'undefined' ||
    typeof elements.x00041220.value === 'undefined') {
    dwv.logger.warn('No Directory Record Sequence found in DICOMDIR.');
    return undefined;
  }
  var dirSeq = elements.x00041220.value;

  if (dirSeq.length === 0) {
    dwv.logger.warn('The Directory Record Sequence of the DICOMDIR is empty.');
    return undefined;
  }

  var records = [];
  var series = null;
  var study = null;
  for (var i = 0; i < dirSeq.length; ++i) {
    // Directory Record Type
    if (typeof dirSeq[i].x00041430 === 'undefined' ||
      typeof dirSeq[i].x00041430.value === 'undefined') {
      continue;
    }
    var recType = dwv.dicom.cleanString(dirSeq[i].x00041430.value[0]);

    // supposed to come in order...
    if (recType === 'STUDY') {
      study = [];
      records.push(study);
    } else if (recType === 'SERIES') {
      series = [];
      study.push(series);
    } else if (recType === 'IMAGE') {
      // Referenced File ID
      if (typeof dirSeq[i].x00041500 === 'undefined' ||
        typeof dirSeq[i].x00041500.value === 'undefined') {
        continue;
      }
      var refFileIds = dirSeq[i].x00041500.value;
      // clean and join ids
      var refFileId = '';
      for (var j = 0; j < refFileIds.length; ++j) {
        if (j !== 0) {
          refFileId += '/';
        }
        refFileId += dwv.dicom.cleanString(refFileIds[j]);
      }
      series.push(refFileId);
    }
  }
  return records;
};

// namespaces
var dwv = dwv || {};
/** @namespace */
dwv.dicom = dwv.dicom || {};

/**
 * Get the version of the library.
 *
 * @returns {string} The version of the library.
 */
dwv.getVersion = function () {
  return '0.31.2';
};

/**
 * Check that an input buffer includes the DICOM prefix 'DICM'
 * after the 128 bytes preamble.
 * Ref: [DICOM File Meta]{@link https://dicom.nema.org/dicom/2013/output/chtml/part10/chapter_7.html#sect_7.1}
 *
 * @param {ArrayBuffer} buffer The buffer to check.
 * @returns {boolean} True if the buffer includes the prefix.
 */
dwv.dicom.hasDicomPrefix = function (buffer) {
  var prefixArray = new Uint8Array(buffer, 128, 4);
  var stringReducer = function (previous, current) {
    return previous += String.fromCharCode(current);
  };
  return prefixArray.reduce(stringReducer, '') === 'DICM';
};

/**
 * Clean string: trim and remove ending.
 *
 * @param {string} inputStr The string to clean.
 * @returns {string} The cleaned string.
 */
dwv.dicom.cleanString = function (inputStr) {
  var res = inputStr;
  if (inputStr) {
    // trim spaces
    res = inputStr.trim();
    // get rid of ending zero-width space (u200B)
    if (res[res.length - 1] === String.fromCharCode('u200B')) {
      res = res.substring(0, res.length - 1);
    }
  }
  return res;
};

/**
 * Get the utfLabel (used by the TextDecoder) from a character set term
 * References:
 * - DICOM [Value Encoding]{@link http://dicom.nema.org/dicom/2013/output/chtml/part05/chapter_6.html}
 * - DICOM [Specific Character Set]{@link http://dicom.nema.org/dicom/2013/output/chtml/part03/sect_C.12.html#sect_C.12.1.1.2}
 * - [TextDecoder#Parameters]{@link https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder/TextDecoder#Parameters}
 *
 * @param {string} charSetTerm The DICOM character set.
 * @returns {string} The corresponding UTF label.
 */
dwv.dicom.getUtfLabel = function (charSetTerm) {
  var label = 'utf-8';
  if (charSetTerm === 'ISO_IR 100') {
    label = 'iso-8859-1';
  } else if (charSetTerm === 'ISO_IR 101') {
    label = 'iso-8859-2';
  } else if (charSetTerm === 'ISO_IR 109') {
    label = 'iso-8859-3';
  } else if (charSetTerm === 'ISO_IR 110') {
    label = 'iso-8859-4';
  } else if (charSetTerm === 'ISO_IR 144') {
    label = 'iso-8859-5';
  } else if (charSetTerm === 'ISO_IR 127') {
    label = 'iso-8859-6';
  } else if (charSetTerm === 'ISO_IR 126') {
    label = 'iso-8859-7';
  } else if (charSetTerm === 'ISO_IR 138') {
    label = 'iso-8859-8';
  } else if (charSetTerm === 'ISO_IR 148') {
    label = 'iso-8859-9';
  } else if (charSetTerm === 'ISO_IR 13') {
    label = 'shift-jis';
  } else if (charSetTerm === 'ISO_IR 166') {
    label = 'iso-8859-11';
  } else if (charSetTerm === 'ISO 2022 IR 87') {
    label = 'iso-2022-jp';
  } else if (charSetTerm === 'ISO 2022 IR 149') {
    // not supported by TextDecoder when it says it should...
    //label = "iso-2022-kr";
  } else if (charSetTerm === 'ISO 2022 IR 58') {
    // not supported by TextDecoder...
    //label = "iso-2022-cn";
  } else if (charSetTerm === 'ISO_IR 192') {
    label = 'utf-8';
  } else if (charSetTerm === 'GB18030') {
    label = 'gb18030';
  } else if (charSetTerm === 'GB2312') {
    label = 'gb2312';
  } else if (charSetTerm === 'GBK') {
    label = 'chinese';
  }
  return label;
};

/**
 * Default text decoder
 */
dwv.dicom.DefaultTextDecoder = function () {
  /**
   * Decode an input string buffer.
   *
   * @param {Uint8Array} buffer The buffer to decode.
   * @returns {string} The decoded string.
   */
  this.decode = function (buffer) {
    var result = '';
    for (var i = 0, leni = buffer.length; i < leni; ++i) {
      result += String.fromCharCode(buffer[i]);
    }
    return result;
  };
};

/**
 * Get patient orientation label in the reverse direction.
 *
 * @param {string} ori Patient Orientation value.
 * @returns {string} Reverse Orientation Label.
 */
dwv.dicom.getReverseOrientation = function (ori) {
  if (!ori) {
    return null;
  }
  // reverse labels
  var rlabels = {
    L: 'R',
    R: 'L',
    A: 'P',
    P: 'A',
    H: 'F',
    F: 'H'
  };

  var rori = '';
  for (var n = 0; n < ori.length; n++) {
    var o = ori.substring(n, n + 1);
    var r = rlabels[o];
    if (r) {
      rori += r;
    }
  }
  // return
  return rori;
};

/**
 * Get the name of an image orientation patient.
 *
 * @param {Array} orientation The image orientation patient.
 * @returns {string} The orientation name: axial, coronal or sagittal.
 */
dwv.dicom.getOrientationName = function (orientation) {
  var axialOrientation = [1, 0, 0, 0, 1, 0];
  var coronalOrientation = [1, 0, 0, 0, 0, -1];
  var sagittalOrientation = [0, 1, 0, 0, 0, -1];
  var name;
  if (dwv.utils.arrayEquals(orientation, axialOrientation)) {
    name = 'axial';
  } else if (dwv.utils.arrayEquals(orientation, coronalOrientation)) {
    name = 'coronal';
  } else if (dwv.utils.arrayEquals(orientation, sagittalOrientation)) {
    name = 'sagittal';
  }
  return name;
};

/**
 * Tell if a given syntax is an implicit one (element with no VR).
 *
 * @param {string} syntax The transfer syntax to test.
 * @returns {boolean} True if an implicit syntax.
 */
dwv.dicom.isImplicitTransferSyntax = function (syntax) {
  return syntax === '1.2.840.10008.1.2';
};

/**
 * Tell if a given syntax is a big endian syntax.
 *
 * @param {string} syntax The transfer syntax to test.
 * @returns {boolean} True if a big endian syntax.
 */
dwv.dicom.isBigEndianTransferSyntax = function (syntax) {
  return syntax === '1.2.840.10008.1.2.2';
};

/**
 * Tell if a given syntax is a JPEG baseline one.
 *
 * @param {string} syntax The transfer syntax to test.
 * @returns {boolean} True if a jpeg baseline syntax.
 */
dwv.dicom.isJpegBaselineTransferSyntax = function (syntax) {
  return syntax === '1.2.840.10008.1.2.4.50' ||
    syntax === '1.2.840.10008.1.2.4.51';
};

/**
 * Tell if a given syntax is a retired JPEG one.
 *
 * @param {string} syntax The transfer syntax to test.
 * @returns {boolean} True if a retired jpeg syntax.
 */
dwv.dicom.isJpegRetiredTransferSyntax = function (syntax) {
  return (syntax.match(/1.2.840.10008.1.2.4.5/) !== null &&
    !dwv.dicom.isJpegBaselineTransferSyntax() &&
    !dwv.dicom.isJpegLosslessTransferSyntax()) ||
    syntax.match(/1.2.840.10008.1.2.4.6/) !== null;
};

/**
 * Tell if a given syntax is a JPEG Lossless one.
 *
 * @param {string} syntax The transfer syntax to test.
 * @returns {boolean} True if a jpeg lossless syntax.
 */
dwv.dicom.isJpegLosslessTransferSyntax = function (syntax) {
  return syntax === '1.2.840.10008.1.2.4.57' ||
    syntax === '1.2.840.10008.1.2.4.70';
};

/**
 * Tell if a given syntax is a JPEG-LS one.
 *
 * @param {string} syntax The transfer syntax to test.
 * @returns {boolean} True if a jpeg-ls syntax.
 */
dwv.dicom.isJpeglsTransferSyntax = function (syntax) {
  return syntax.match(/1.2.840.10008.1.2.4.8/) !== null;
};

/**
 * Tell if a given syntax is a JPEG 2000 one.
 *
 * @param {string} syntax The transfer syntax to test.
 * @returns {boolean} True if a jpeg 2000 syntax.
 */
dwv.dicom.isJpeg2000TransferSyntax = function (syntax) {
  return syntax.match(/1.2.840.10008.1.2.4.9/) !== null;
};

/**
 * Tell if a given syntax is a RLE (Run-length encoding) one.
 *
 * @param {string} syntax The transfer syntax to test.
 * @returns {boolean} True if a RLE syntax.
 */
dwv.dicom.isRleTransferSyntax = function (syntax) {
  return syntax.match(/1.2.840.10008.1.2.5/) !== null;
};

/**
 * Tell if a given syntax needs decompression.
 *
 * @param {string} syntax The transfer syntax to test.
 * @returns {string} The name of the decompression algorithm.
 */
dwv.dicom.getSyntaxDecompressionName = function (syntax) {
  var algo = null;
  if (dwv.dicom.isJpeg2000TransferSyntax(syntax)) {
    algo = 'jpeg2000';
  } else if (dwv.dicom.isJpegBaselineTransferSyntax(syntax)) {
    algo = 'jpeg-baseline';
  } else if (dwv.dicom.isJpegLosslessTransferSyntax(syntax)) {
    algo = 'jpeg-lossless';
  } else if (dwv.dicom.isRleTransferSyntax(syntax)) {
    algo = 'rle';
  }
  return algo;
};

/**
 * Tell if a given syntax is supported for reading.
 *
 * @param {string} syntax The transfer syntax to test.
 * @returns {boolean} True if a supported syntax.
 */
dwv.dicom.isReadSupportedTransferSyntax = function (syntax) {

  // Unsupported:
  // "1.2.840.10008.1.2.1.99": Deflated Explicit VR - Little Endian
  // "1.2.840.10008.1.2.4.100": MPEG2 Image Compression
  // dwv.dicom.isJpegRetiredTransferSyntax(syntax): non supported JPEG
  // dwv.dicom.isJpeglsTransferSyntax(syntax): JPEG-LS

  return (syntax === '1.2.840.10008.1.2' || // Implicit VR - Little Endian
    syntax === '1.2.840.10008.1.2.1' || // Explicit VR - Little Endian
    syntax === '1.2.840.10008.1.2.2' || // Explicit VR - Big Endian
    dwv.dicom.isJpegBaselineTransferSyntax(syntax) || // JPEG baseline
    dwv.dicom.isJpegLosslessTransferSyntax(syntax) || // JPEG Lossless
    dwv.dicom.isJpeg2000TransferSyntax(syntax) || // JPEG 2000
    dwv.dicom.isRleTransferSyntax(syntax)); // RLE
};

/**
 * Get the transfer syntax name.
 * Reference: [UID Values]{@link http://dicom.nema.org/dicom/2013/output/chtml/part06/chapter_A.html}.
 *
 * @param {string} syntax The transfer syntax.
 * @returns {string} The name of the transfer syntax.
 */
dwv.dicom.getTransferSyntaxName = function (syntax) {
  var name = 'Unknown';
  if (syntax === '1.2.840.10008.1.2') {
    // Implicit VR - Little Endian
    name = 'Little Endian Implicit';
  } else if (syntax === '1.2.840.10008.1.2.1') {
    // Explicit VR - Little Endian
    name = 'Little Endian Explicit';
  } else if (syntax === '1.2.840.10008.1.2.1.99') {
    // Deflated Explicit VR - Little Endian
    name = 'Little Endian Deflated Explicit';
  } else if (syntax === '1.2.840.10008.1.2.2') {
    // Explicit VR - Big Endian
    name = 'Big Endian Explicit';
  } else if (dwv.dicom.isJpegBaselineTransferSyntax(syntax)) {
    // JPEG baseline
    if (syntax === '1.2.840.10008.1.2.4.50') {
      name = 'JPEG Baseline';
    } else { // *.51
      name = 'JPEG Extended, Process 2+4';
    }
  } else if (dwv.dicom.isJpegLosslessTransferSyntax(syntax)) {
    // JPEG Lossless
    if (syntax === '1.2.840.10008.1.2.4.57') {
      name = 'JPEG Lossless, Nonhierarchical (Processes 14)';
    } else { // *.70
      name = 'JPEG Lossless, Non-hierarchical, 1st Order Prediction';
    }
  } else if (dwv.dicom.isJpegRetiredTransferSyntax(syntax)) {
    // Retired JPEG
    name = 'Retired JPEG';
  } else if (dwv.dicom.isJpeglsTransferSyntax(syntax)) {
    // JPEG-LS
    name = 'JPEG-LS';
  } else if (dwv.dicom.isJpeg2000TransferSyntax(syntax)) {
    // JPEG 2000
    if (syntax === '1.2.840.10008.1.2.4.91') {
      name = 'JPEG 2000 (Lossless or Lossy)';
    } else { // *.90
      name = 'JPEG 2000 (Lossless only)';
    }
  } else if (syntax === '1.2.840.10008.1.2.4.100') {
    // MPEG2 Image Compression
    name = 'MPEG2';
  } else if (dwv.dicom.isRleTransferSyntax(syntax)) {
    // RLE (lossless)
    name = 'RLE';
  }
  // return
  return name;
};

/**
 * Guess the transfer syntax from the first data element.
 * See https://github.com/ivmartel/dwv/issues/188
 *   (Allow to load DICOM with no DICM preamble) for more details.
 *
 * @param {object} firstDataElement The first data element of the DICOM header.
 * @returns {object} The transfer syntax data element.
 */
dwv.dicom.guessTransferSyntax = function (firstDataElement) {
  var oEightGroupBigEndian = '0x0800';
  var oEightGroupLittleEndian = '0x0008';
  // check that group is 0x0008
  var group = firstDataElement.tag.getGroup();
  if (group !== oEightGroupBigEndian &&
    group !== oEightGroupLittleEndian) {
    throw new Error(
      'Not a valid DICOM file (no magic DICM word found' +
        ' and first element not in 0x0008 group)'
    );
  }
  // reasonable assumption: 2 uppercase characters => explicit vr
  var vr = firstDataElement.vr;
  var vr0 = vr.charCodeAt(0);
  var vr1 = vr.charCodeAt(1);
  var implicit = (vr0 >= 65 && vr0 <= 90 && vr1 >= 65 && vr1 <= 90)
    ? false : true;
  // guess transfer syntax
  var syntax = null;
  if (group === oEightGroupLittleEndian) {
    if (implicit) {
      // ImplicitVRLittleEndian
      syntax = '1.2.840.10008.1.2';
    } else {
      // ExplicitVRLittleEndian
      syntax = '1.2.840.10008.1.2.1';
    }
  } else {
    if (implicit) {
      // ImplicitVRBigEndian: impossible
      throw new Error(
        'Not a valid DICOM file (no magic DICM word found' +
        'and implicit VR big endian detected)'
      );
    } else {
      // ExplicitVRBigEndian
      syntax = '1.2.840.10008.1.2.2';
    }
  }
  // set transfer syntax data element
  var dataElement = {
    tag: new dwv.dicom.Tag('0x0002', '0x0010'),
    vr: 'UI'
  };
  dataElement.value = [syntax + ' ']; // even length
  dataElement.vl = dataElement.value[0].length;
  dataElement.startOffset = firstDataElement.startOffset;
  dataElement.endOffset = dataElement.startOffset + dataElement.vl;

  return dataElement;
};

/**
 * Get the appropriate TypedArray in function of arguments.
 *
 * @param {number} bitsAllocated The number of bites used to store
 *   the data: [8, 16, 32].
 * @param {number} pixelRepresentation The pixel representation,
 *   0:unsigned;1:signed.
 * @param {dwv.image.Size} size The size of the new array.
 * @returns {Array} The good typed array.
 */
dwv.dicom.getTypedArray = function (bitsAllocated, pixelRepresentation, size) {
  var res = null;
  try {
    if (bitsAllocated === 8) {
      if (pixelRepresentation === 0) {
        res = new Uint8Array(size);
      } else {
        res = new Int8Array(size);
      }
    } else if (bitsAllocated === 16) {
      if (pixelRepresentation === 0) {
        res = new Uint16Array(size);
      } else {
        res = new Int16Array(size);
      }
    } else if (bitsAllocated === 32) {
      if (pixelRepresentation === 0) {
        res = new Uint32Array(size);
      } else {
        res = new Int32Array(size);
      }
    }
  } catch (error) {
    if (error instanceof RangeError) {
      var powerOf2 = Math.floor(Math.log(size) / Math.log(2));
      dwv.logger.error('Cannot allocate array of size: ' +
        size + ' (>2^' + powerOf2 + ').');
    }
  }
  return res;
};

/**
 * Does this Value Representation (VR) have a 32bit Value Length (VL).
 * Ref: [Data Element explicit]{@link http://dicom.nema.org/dicom/2013/output/chtml/part05/chapter_7.html#table_7.1-1}.
 *
 * @param {string} vr The data Value Representation (VR).
 * @returns {boolean} True if this VR has a 32-bit VL.
 */
dwv.dicom.is32bitVLVR = function (vr) {
  return dwv.dicom.vr32bitVL.includes(vr);
};

/**
 * Get the number of bytes occupied by a data element prefix,
 *   i.e. without its value.
 *
 * @param {string} vr The Value Representation of the element.
 * @param {boolean} isImplicit Does the data use implicit VR?
 * @returns {number} The size of the element prefix.
 * WARNING: this is valid for tags with a VR, if not sure use
 *   the 'isTagWithVR' function first.
 * Reference:
 * - [Data Element explicit]{@link http://dicom.nema.org/dicom/2013/output/chtml/part05/chapter_7.html#table_7.1-1},
 * - [Data Element implicit]{@link http://dicom.nema.org/dicom/2013/output/chtml/part05/sect_7.5.html#table_7.5-1}.
 *
 * | Tag | VR  | VL | Value |
 * | 4   | 2   | 2  | X     | -> regular explicit: 8 + X
 * | 4   | 2+2 | 4  | X     | -> 32bit VL: 12 + X
 *
 * | Tag | VL | Value |
 * | 4   | 4  | X     | -> implicit (32bit VL): 8 + X
 *
 * | Tag | Len | Value |
 * | 4   | 4   | X     | -> item: 8 + X
 */
dwv.dicom.getDataElementPrefixByteSize = function (vr, isImplicit) {
  return isImplicit ? 8 : dwv.dicom.is32bitVLVR(vr) ? 12 : 8;
};

/**
 * DicomParser class.
 *
 * @class
 * @example
 * // XMLHttpRequest onload callback
 * var onload = function (event) {
 *   // setup the dicom parser
 *   var dicomParser = new dwv.dicom.DicomParser();
 *   // parse the buffer
 *   dicomParser.parse(event.target.response);
 *   // get the wrapped dicom tags
 *   // (raw tags are available via 'getRawDicomElements')
 *   var tags = dicomParser.getDicomElements();
 *   // display the modality
 *   var div = document.getElementById('dwv');
 *   div.appendChild(document.createTextNode(
 *     'Modality: ' + tags.getFromName('Modality')
 *   ));
 * };
 * // DICOM file request
 * var request = new XMLHttpRequest();
 * var url = 'https://raw.githubusercontent.com/ivmartel/dwv/master/tests/data/bbmri-53323851.dcm';
 * request.open('GET', url);
 * request.responseType = 'arraybuffer';
 * request.onload = onload;
 * request.send();
 */
dwv.dicom.DicomParser = function () {
  /**
   * The list of DICOM elements.
   *
   * @type {Array}
   */
  this.dicomElements = {};

  /**
   * Default character set (optional).
   *
   * @private
   * @type {string}
   */
  var defaultCharacterSet;

  /**
   * Default text decoder.
   *
   * @private
   * @type {dwv.dicom.DefaultTextDecoder}
   */
  var defaultTextDecoder = new dwv.dicom.DefaultTextDecoder();

  /**
   * Special text decoder.
   *
   * @private
   * @type {dwv.dicom.DefaultTextDecoder|TextDecoder}
   */
  var textDecoder = defaultTextDecoder;

  /**
   * Decode an input string buffer using the default text decoder.
   *
   * @param {Uint8Array} buffer The buffer to decode.
   * @returns {string} The decoded string.
   */
  this.decodeString = function (buffer) {
    return defaultTextDecoder.decode(buffer);
  };

  /**
   * Decode an input string buffer using the 'special' text decoder.
   *
   * @param {Uint8Array} buffer The buffer to decode.
   * @returns {string} The decoded string.
   */
  this.decodeSpecialString = function (buffer) {
    return textDecoder.decode(buffer);
  };

  /**
   * Get the default character set.
   *
   * @returns {string} The default character set.
   */
  this.getDefaultCharacterSet = function () {
    return defaultCharacterSet;
  };

  /**
   * Set the default character set.
   *
   * @param {string} characterSet The input character set.
   */
  this.setDefaultCharacterSet = function (characterSet) {
    defaultCharacterSet = characterSet;
    this.setCharacterSet(characterSet);
  };

  /**
   * Set the text decoder character set.
   *
   * @param {string} characterSet The input character set.
   */
  this.setDecoderCharacterSet = function (characterSet) {
    /**
     * The text decoder.
     *
     * @external TextDecoder
     * @see https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder
     */
    textDecoder = new TextDecoder(characterSet);
  };
};

/**
 * Get the raw DICOM data elements.
 *
 * @returns {object} The raw DICOM elements.
 */
dwv.dicom.DicomParser.prototype.getRawDicomElements = function () {
  return this.dicomElements;
};

/**
 * Get the DICOM data elements.
 *
 * @returns {object} The DICOM elements.
 */
dwv.dicom.DicomParser.prototype.getDicomElements = function () {
  return new dwv.dicom.DicomElementsWrapper(this.dicomElements);
};

/**
 * Read a DICOM tag.
 *
 * @param {dwv.dicom.DataReader} reader The raw data reader.
 * @param {number} offset The offset where to start to read.
 * @returns {object} An object containing the tag and the end offset.
 */
dwv.dicom.DicomParser.prototype.readTag = function (reader, offset) {
  // group
  var group = reader.readHex(offset);
  offset += Uint16Array.BYTES_PER_ELEMENT;
  // element
  var element = reader.readHex(offset);
  offset += Uint16Array.BYTES_PER_ELEMENT;
  // return
  return {
    tag: new dwv.dicom.Tag(group, element),
    endOffset: offset
  };
};

/**
 * Read an item data element.
 *
 * @param {dwv.dicom.DataReader} reader The raw data reader.
 * @param {number} offset The offset where to start to read.
 * @param {boolean} implicit Is the DICOM VR implicit?
 * @returns {object} The item data as a list of data elements.
 */
dwv.dicom.DicomParser.prototype.readItemDataElement = function (
  reader, offset, implicit) {
  var itemData = {};

  // read the first item
  var item = this.readDataElement(reader, offset, implicit);
  offset = item.endOffset;

  // exit if it is a sequence delimitation item
  if (dwv.dicom.isSequenceDelimitationItemTag(item.tag)) {
    return {
      data: itemData,
      endOffset: item.endOffset,
      isSeqDelim: true
    };
  }

  // store item (mainly to keep vl)
  itemData[item.tag.getKey()] = {
    tag: item.tag,
    vr: 'NONE',
    vl: item.vl,
    undefinedLength: item.undefinedLength
  };

  if (!item.undefinedLength) {
    // explicit VR item: read until the end offset
    var endOffset = offset;
    offset -= item.vl;
    while (offset < endOffset) {
      item = this.readDataElement(reader, offset, implicit);
      offset = item.endOffset;
      itemData[item.tag.getKey()] = item;
    }
  } else {
    // implicit VR item: read until the item delimitation item
    var isItemDelim = false;
    while (!isItemDelim) {
      item = this.readDataElement(reader, offset, implicit);
      offset = item.endOffset;
      isItemDelim = dwv.dicom.isItemDelimitationItemTag(item.tag);
      if (!isItemDelim) {
        itemData[item.tag.getKey()] = item;
      }
    }
  }

  return {
    data: itemData,
    endOffset: offset,
    isSeqDelim: false
  };
};

/**
 * Read the pixel item data element.
 * Ref: [Single frame fragments]{@link http://dicom.nema.org/dicom/2013/output/chtml/part05/sect_A.4.html#table_A.4-1}.
 *
 * @param {dwv.dicom.DataReader} reader The raw data reader.
 * @param {number} offset The offset where to start to read.
 * @param {boolean} implicit Is the DICOM VR implicit?
 * @returns {Array} The item data as an array of data elements.
 */
dwv.dicom.DicomParser.prototype.readPixelItemDataElement = function (
  reader, offset, implicit) {
  var itemData = [];

  // first item: basic offset table
  var item = this.readDataElement(reader, offset, implicit);
  var offsetTableVl = item.vl;
  offset = item.endOffset;

  // read until the sequence delimitation item
  var isSeqDelim = false;
  while (!isSeqDelim) {
    item = this.readDataElement(reader, offset, implicit);
    offset = item.endOffset;
    isSeqDelim = dwv.dicom.isSequenceDelimitationItemTag(item.tag);
    if (!isSeqDelim) {
      // force pixel item vr to OB
      item.vr = 'OB';
      itemData.push(item);
    }
  }

  return {
    data: itemData,
    endOffset: offset,
    offsetTableVl: offsetTableVl
  };
};

/**
 * Read a DICOM data element.
 * Reference: [DICOM VRs]{@link http://dicom.nema.org/dicom/2013/output/chtml/part05/sect_6.2.html#table_6.2-1}.
 *
 * @param {dwv.dicom.DataReader} reader The raw data reader.
 * @param {number} offset The offset where to start to read.
 * @param {boolean} implicit Is the DICOM VR implicit?
 * @returns {object} An object containing the element
 *   'tag', 'vl', 'vr', 'data' and 'endOffset'.
 */
dwv.dicom.DicomParser.prototype.readDataElement = function (
  reader, offset, implicit) {
  // Tag: group, element
  var readTagRes = this.readTag(reader, offset);
  var tag = readTagRes.tag;
  offset = readTagRes.endOffset;

  // Value Representation (VR)
  var vr = null;
  var is32bitVLVR = false;
  if (tag.isWithVR()) {
    // implicit VR
    if (implicit) {
      vr = tag.getVrFromDictionary();
      if (vr === null) {
        vr = 'UN';
      }
      is32bitVLVR = true;
    } else {
      vr = this.decodeString(reader.readUint8Array(offset, 2));
      offset += 2 * Uint8Array.BYTES_PER_ELEMENT;
      is32bitVLVR = dwv.dicom.is32bitVLVR(vr);
      // reserved 2 bytes
      if (is32bitVLVR) {
        offset += 2 * Uint8Array.BYTES_PER_ELEMENT;
      }
    }
  } else {
    vr = 'NONE';
    is32bitVLVR = true;
  }

  // Value Length (VL)
  var vl = 0;
  if (is32bitVLVR) {
    vl = reader.readUint32(offset);
    offset += Uint32Array.BYTES_PER_ELEMENT;
  } else {
    vl = reader.readUint16(offset);
    offset += Uint16Array.BYTES_PER_ELEMENT;
  }

  // check the value of VL
  var undefinedLength = false;
  if (vl === 0xffffffff) {
    undefinedLength = true;
    vl = 0;
  }

  // treat private tag with unknown VR and zero VL as a sequence (see #799)
  if (tag.isPrivate() && vr === 'UN' && vl === 0) {
    vr = 'SQ';
  }

  var startOffset = offset;
  var endOffset = startOffset + vl;

  // read sequence elements
  var data = null;
  if (dwv.dicom.isPixelDataTag(tag) && undefinedLength) {
    // pixel data sequence (implicit)
    var pixItemData = this.readPixelItemDataElement(reader, offset, implicit);
    offset = pixItemData.endOffset;
    startOffset += pixItemData.offsetTableVl;
    data = pixItemData.data;
    endOffset = offset;
    vl = offset - startOffset;
  } else if (vr === 'SQ') {
    // sequence
    data = [];
    var itemData;
    if (!undefinedLength) {
      if (vl !== 0) {
        // explicit VR sequence: read until the end offset
        var sqEndOffset = offset + vl;
        while (offset < sqEndOffset) {
          itemData = this.readItemDataElement(reader, offset, implicit);
          data.push(itemData.data);
          offset = itemData.endOffset;
        }
        endOffset = offset;
        vl = offset - startOffset;
      }
    } else {
      // implicit VR sequence: read until the sequence delimitation item
      var isSeqDelim = false;
      while (!isSeqDelim) {
        itemData = this.readItemDataElement(reader, offset, implicit);
        isSeqDelim = itemData.isSeqDelim;
        offset = itemData.endOffset;
        // do not store the delimitation item
        if (!isSeqDelim) {
          data.push(itemData.data);
        }
      }
      endOffset = offset;
      vl = offset - startOffset;
    }
  }

  // return
  var element = {
    tag: tag,
    vr: vr,
    vl: vl,
    startOffset: startOffset,
    endOffset: endOffset
  };
  // only set if true (only for sequences and items)
  if (undefinedLength) {
    element.undefinedLength = undefinedLength;
  }
  if (data) {
    element.items = data;
  }
  return element;
};

/**
 * Interpret the data of an element.
 *
 * @param {object} element The data element.
 * @param {dwv.dicom.DataReader} reader The raw data reader.
 * @param {number} pixelRepresentation PixelRepresentation 0->unsigned,
 *   1->signed (needed for pixel data or VR=xs).
 * @param {number} bitsAllocated Bits allocated (needed for pixel data).
 * @returns {object} The interpreted data.
 */
dwv.dicom.DicomParser.prototype.interpretElement = function (
  element, reader, pixelRepresentation, bitsAllocated) {

  var tag = element.tag;
  var vl = element.vl;
  var vr = element.vr;
  var offset = element.startOffset;

  // data
  var data = null;
  var isPixelDataTag = dwv.dicom.isPixelDataTag(tag);
  var vrType = dwv.dicom.vrTypes[vr];
  if (isPixelDataTag) {
    if (element.undefinedLength) {
      // implicit pixel data sequence
      data = [];
      for (var j = 0; j < element.items.length; ++j) {
        data.push(this.interpretElement(
          element.items[j], reader,
          pixelRepresentation, bitsAllocated));
      }
      // remove non parsed items
      delete element.items;
    } else {
      // check bits allocated and VR
      // https://dicom.nema.org/medical/dicom/2022a/output/chtml/part05/sect_A.2.html
      if (bitsAllocated > 8 && vr === 'OB') {
        dwv.logger.warn(
          'Reading DICOM pixel data with bitsAllocated>8 and OB VR.'
        );
      }
      // read
      data = [];
      if (bitsAllocated === 1) {
        data.push(reader.readBinaryArray(offset, vl));
      } else if (bitsAllocated === 8) {
        if (pixelRepresentation === 0) {
          data.push(reader.readUint8Array(offset, vl));
        } else {
          data.push(reader.readInt8Array(offset, vl));
        }
      } else if (bitsAllocated === 16) {
        if (pixelRepresentation === 0) {
          data.push(reader.readUint16Array(offset, vl));
        } else {
          data.push(reader.readInt16Array(offset, vl));
        }
      } else {
        throw new Error('Unsupported bits allocated: ' + bitsAllocated);
      }
    }
  } else if (typeof vrType !== 'undefined') {
    if (vrType === 'Uint8') {
      data = reader.readUint8Array(offset, vl);
    } else if (vrType === 'Uint16') {
      data = reader.readUint16Array(offset, vl);
    } else if (vrType === 'Uint32') {
      data = reader.readUint32Array(offset, vl);
    } else if (vrType === 'Uint64') {
      data = reader.readUint64Array(offset, vl);
    } else if (vrType === 'Int16') {
      data = reader.readInt16Array(offset, vl);
    } else if (vrType === 'Int32') {
      data = reader.readInt32Array(offset, vl);
    } else if (vrType === 'Int64') {
      data = reader.readInt64Array(offset, vl);
    } else if (vrType === 'Float32') {
      data = reader.readFloat32Array(offset, vl);
    } else if (vrType === 'Float64') {
      data = reader.readFloat64Array(offset, vl);
    } else if (vrType === 'string') {
      var stream = reader.readUint8Array(offset, vl);
      if (dwv.dicom.charSetString.includes(vr)) {
        data = this.decodeSpecialString(stream);
      } else {
        data = this.decodeString(stream);
      }
      data = data.split('\\');
    } else {
      throw Error('Unknown VR type: ' + vrType);
    }
  } else if (vr === 'ox') {
    // OB or OW
    if (bitsAllocated === 8) {
      data = reader.readUint8Array(offset, vl);
    } else {
      data = reader.readUint16Array(offset, vl);
    }
  } else if (vr === 'xs') {
    // US or SS
    if (pixelRepresentation === 0) {
      data = reader.readUint16Array(offset, vl);
    } else {
      data = reader.readInt16Array(offset, vl);
    }
  } else if (vr === 'AT') {
    // attribute
    var raw = reader.readUint16Array(offset, vl);
    data = [];
    for (var i = 0, leni = raw.length; i < leni; i += 2) {
      var stri = raw[i].toString(16);
      var stri1 = raw[i + 1].toString(16);
      var str = '(';
      str += '0000'.substring(0, 4 - stri.length) + stri.toUpperCase();
      str += ',';
      str += '0000'.substring(0, 4 - stri1.length) + stri1.toUpperCase();
      str += ')';
      data.push(str);
    }
  } else if (vr === 'SQ') {
    // sequence
    data = [];
    for (var k = 0; k < element.items.length; ++k) {
      var item = element.items[k];
      var itemData = {};
      var keys = Object.keys(item);
      for (var l = 0; l < keys.length; ++l) {
        var subElement = item[keys[l]];
        subElement.value = this.interpretElement(
          subElement, reader,
          pixelRepresentation, bitsAllocated);
        itemData[keys[l]] = subElement;
      }
      data.push(itemData);
    }
    // remove non parsed elements
    delete element.items;
  } else if (vr === 'NONE') {
    // no VR -> no data
    data = [];
  } else {
    dwv.logger.warn('Unknown VR: ' + vr);
  }

  return data;
};

/**
 * Interpret the data of a list of elements.
 *
 * @param {Array} elements A list of data elements.
 * @param {dwv.dicom.DataReader} reader The raw data reader.
 * @param {number} pixelRepresentation PixelRepresentation 0->unsigned,
 *   1->signed.
 * @param {number} bitsAllocated Bits allocated.
 */
dwv.dicom.DicomParser.prototype.interpret = function (
  elements, reader,
  pixelRepresentation, bitsAllocated) {

  var keys = Object.keys(elements);
  for (var i = 0; i < keys.length; ++i) {
    var element = elements[keys[i]];
    if (typeof element.value === 'undefined') {
      element.value = this.interpretElement(
        element, reader, pixelRepresentation, bitsAllocated);
    }
    // delete interpretation specific properties
    delete element.startOffset;
    delete element.endOffset;
  }
};

/**
 * Parse the complete DICOM file (given as input to the class).
 * Fills in the member object 'dicomElements'.
 *
 * @param {object} buffer The input array buffer.
 */
dwv.dicom.DicomParser.prototype.parse = function (buffer) {
  var offset = 0;
  var syntax = '';
  var dataElement = null;
  // default readers
  var metaReader = new dwv.dicom.DataReader(buffer);
  var dataReader = new dwv.dicom.DataReader(buffer);

  // 128 -> 132: magic word
  offset = 128;
  var magicword = this.decodeString(metaReader.readUint8Array(offset, 4));
  offset += 4 * Uint8Array.BYTES_PER_ELEMENT;
  if (magicword === 'DICM') {
    // 0x0002, 0x0000: FileMetaInformationGroupLength
    dataElement = this.readDataElement(metaReader, offset, false);
    dataElement.value = this.interpretElement(dataElement, metaReader);
    // increment offset
    offset = dataElement.endOffset;
    // store the data element
    this.dicomElements[dataElement.tag.getKey()] = dataElement;
    // get meta length
    var metaLength = parseInt(dataElement.value[0], 10);

    // meta elements
    var metaEnd = offset + metaLength;
    while (offset < metaEnd) {
      // get the data element
      dataElement = this.readDataElement(metaReader, offset, false);
      offset = dataElement.endOffset;
      // store the data element
      this.dicomElements[dataElement.tag.getKey()] = dataElement;
    }

    // check the TransferSyntaxUID (has to be there!)
    dataElement = this.dicomElements.x00020010;
    if (typeof dataElement === 'undefined') {
      throw new Error('Not a valid DICOM file (no TransferSyntaxUID found)');
    }
    dataElement.value = this.interpretElement(dataElement, metaReader);
    syntax = dwv.dicom.cleanString(dataElement.value[0]);

  } else {
    dwv.logger.warn('No DICM prefix, trying to guess tansfer syntax.');
    // read first element
    dataElement = this.readDataElement(dataReader, 0, false);
    // guess transfer syntax
    var tsElement = dwv.dicom.guessTransferSyntax(dataElement);
    // store
    this.dicomElements[tsElement.tag.getKey()] = tsElement;
    syntax = dwv.dicom.cleanString(tsElement.value[0]);
    // reset offset
    offset = 0;
  }

  // check transfer syntax support
  if (!dwv.dicom.isReadSupportedTransferSyntax(syntax)) {
    throw new Error('Unsupported DICOM transfer syntax: \'' + syntax +
      '\' (' + dwv.dicom.getTransferSyntaxName(syntax) + ')');
  }

  // set implicit flag
  var implicit = false;
  if (dwv.dicom.isImplicitTransferSyntax(syntax)) {
    implicit = true;
  }

  // Big Endian
  if (dwv.dicom.isBigEndianTransferSyntax(syntax)) {
    dataReader = new dwv.dicom.DataReader(buffer, false);
  }

  // DICOM data elements
  while (offset < buffer.byteLength) {
    // get the data element
    dataElement = this.readDataElement(dataReader, offset, implicit);
    // increment offset
    offset = dataElement.endOffset;
    // store the data element
    if (typeof this.dicomElements[dataElement.tag.getKey()] === 'undefined') {
      this.dicomElements[dataElement.tag.getKey()] = dataElement;
    } else {
      dwv.logger.warn('Not saving duplicate tag: ' + dataElement.tag.getKey());
    }
  }

  // safety checks...
  if (isNaN(offset)) {
    throw new Error('Problem while parsing, bad offset');
  }
  if (buffer.byteLength !== offset) {
    dwv.logger.warn('Did not reach the end of the buffer: ' +
      offset + ' != ' + buffer.byteLength);
  }

  //-------------------------------------------------
  // values needed for data interpretation

  // pixel specific
  if (typeof this.dicomElements.x7FE00010 !== 'undefined') {
    // PixelRepresentation 0->unsigned, 1->signed
    var pixelRepresentation = 0;
    dataElement = this.dicomElements.x00280103;
    if (typeof dataElement !== 'undefined') {
      dataElement.value = this.interpretElement(dataElement, dataReader);
      pixelRepresentation = dataElement.value[0];
    } else {
      dwv.logger.warn(
        'Reading DICOM pixel data with default pixelRepresentation.');
    }

    // BitsAllocated
    var bitsAllocated = 16;
    dataElement = this.dicomElements.x00280100;
    if (typeof dataElement !== 'undefined') {
      dataElement.value = this.interpretElement(dataElement, dataReader);
      bitsAllocated = dataElement.value[0];
    } else {
      dwv.logger.warn('Reading DICOM pixel data with default bitsAllocated.');
    }
  }

  // default character set
  if (typeof this.getDefaultCharacterSet() !== 'undefined') {
    this.setDecoderCharacterSet(this.getDefaultCharacterSet());
  }

  // SpecificCharacterSet
  dataElement = this.dicomElements.x00080005;
  if (typeof dataElement !== 'undefined') {
    dataElement.value = this.interpretElement(dataElement, dataReader);
    var charSetTerm;
    if (dataElement.value.length === 1) {
      charSetTerm = dwv.dicom.cleanString(dataElement.value[0]);
    } else {
      charSetTerm = dwv.dicom.cleanString(dataElement.value[1]);
      dwv.logger.warn('Unsupported character set with code extensions: \'' +
        charSetTerm + '\'.');
    }
    this.setDecoderCharacterSet(dwv.dicom.getUtfLabel(charSetTerm));
  }

  // interpret the dicom elements
  this.interpret(
    this.dicomElements, dataReader,
    pixelRepresentation, bitsAllocated
  );

  // handle fragmented pixel buffer
  // Reference: http://dicom.nema.org/dicom/2013/output/chtml/part05/sect_8.2.html
  // (third note, "Depending on the transfer syntax...")
  dataElement = this.dicomElements.x7FE00010;
  if (typeof dataElement !== 'undefined') {
    if (dataElement.undefinedLength) {
      var numberOfFrames = 1;
      if (typeof this.dicomElements.x00280008 !== 'undefined') {
        numberOfFrames = dwv.dicom.cleanString(
          this.dicomElements.x00280008.value[0]);
      }
      var pixItems = dataElement.value;
      if (pixItems.length > 1 && pixItems.length > numberOfFrames) {
        // concatenate pixel data items
        // concat does not work on typed arrays
        //this.pixelBuffer = this.pixelBuffer.concat( dataElement.data );
        // manual concat...
        var nItemPerFrame = pixItems.length / numberOfFrames;
        var newPixItems = [];
        var index = 0;
        for (var f = 0; f < numberOfFrames; ++f) {
          index = f * nItemPerFrame;
          // calculate the size of a frame
          var size = 0;
          for (var i = 0; i < nItemPerFrame; ++i) {
            size += pixItems[index + i].length;
          }
          // create new buffer
          var newBuffer = new pixItems[0].constructor(size);
          // fill new buffer
          var fragOffset = 0;
          for (var j = 0; j < nItemPerFrame; ++j) {
            newBuffer.set(pixItems[index + j], fragOffset);
            fragOffset += pixItems[index + j].length;
          }
          newPixItems[f] = newBuffer;
        }
        // store as pixel data
        dataElement.value = newPixItems;
      }
    }
  }
};

// namespaces
var dwv = dwv || {};
dwv.dicom = dwv.dicom || {};

/**
 * Immutable tag.
 *
 * @class
 * @param {string} group The tag group as '0x####'.
 * @param {string} element The tag element as '0x####'.
 */
dwv.dicom.Tag = function (group, element) {
  if (!group || typeof group === 'undefined') {
    throw new Error('Cannot create tag with no group.');
  }
  if (group.length !== 6 || !group.startsWith('0x')) {
    throw new Error('Cannot create tag with badly formed group.');
  }
  if (!element || typeof element === 'undefined') {
    throw new Error('Cannot create tag with no element.');
  }
  if (element.length !== 6 || !element.startsWith('0x')) {
    throw new Error('Cannot create tag with badly formed element.');
  }
  /**
   * Get the tag group.
   *
   * @returns {string} The tag group.
   */
  this.getGroup = function () {
    return group;
  };
  /**
   * Get the tag element.
   *
   * @returns {string} The tag element.
   */
  this.getElement = function () {
    return element;
  };
}; // Tag class

/**
 * Check for Tag equality.
 *
 * @param {dwv.dicom.Tag} rhs The other tag to compare to.
 * @returns {boolean} True if both tags are equal.
 */
dwv.dicom.Tag.prototype.equals = function (rhs) {
  return rhs !== null &&
    typeof rhs !== 'undefined' &&
    this.getGroup() === rhs.getGroup() &&
    this.getElement() === rhs.getElement();
};

/**
 * Tag compare function.
 *
 * @param {dwv.dicom.Tag} a The first tag.
 * @param {dwv.dicom.Tag} b The second tag.
 * @returns {number} The result of the tag comparison,
 *   positive for b before a, negative for a before b and
 *   zero to keep same order.
 */
dwv.dicom.tagCompareFunction = function (a, b) {
  // first by group
  var res = parseInt(a.getGroup()) - parseInt(b.getGroup());
  if (res === 0) {
    // by element if same group
    res = parseInt(a.getElement()) - parseInt(b.getElement());
  }
  return res;
};

/**
 * Get the group-element key used to store DICOM elements.
 *
 * @returns {string} The key as 'x########'.
 */
dwv.dicom.Tag.prototype.getKey = function () {
  // group and element are in the '0x####' form
  return 'x' + this.getGroup().substring(2) + this.getElement().substring(2);
};

/**
 * Get a simplified group-element key.
 *
 * @returns {string} The key as '########'.
 */
dwv.dicom.Tag.prototype.getKey2 = function () {
  // group and element are in the '0x####' form
  return this.getGroup().substring(2) + this.getElement().substring(2);
};

/**
 * Get the group name as defined in dwv.dicom.TagGroups.
 *
 * @returns {string} The name.
 */
dwv.dicom.Tag.prototype.getGroupName = function () {
  // group is in the '0x####' form
  // TagGroups include the x
  return dwv.dicom.TagGroups[this.getGroup().substring(1)];
};


/**
 * Split a group-element key used to store DICOM elements.
 *
 * @param {string} key The key in form "x00280102" as generated by tag::getKey.
 * @returns {object} The DICOM tag.
 */
dwv.dicom.getTagFromKey = function (key) {
  return new dwv.dicom.Tag(
    '0x' + key.substring(1, 5),
    '0x' + key.substring(5, 9));
};

/**
 * Does this tag have a VR.
 * Basically the Item, ItemDelimitationItem and SequenceDelimitationItem tags.
 *
 * @returns {boolean} True if this tag has a VR.
 */
dwv.dicom.Tag.prototype.isWithVR = function () {
  var element = this.getElement();
  return !(this.getGroup() === '0xFFFE' &&
    (element === '0xE000' || element === '0xE00D' || element === '0xE0DD')
  );
};

/**
 * Is the tag group a private tag group ?
 * see: http://dicom.nema.org/medical/dicom/2015a/output/html/part05.html#sect_7.8
 *
 * @returns {boolean} True if the tag group is private,
 *   ie if its group is an odd number.
 */
dwv.dicom.Tag.prototype.isPrivate = function () {
  // group is in the '0x####' form
  var groupNumber = parseInt(this.getGroup().substring(2), 16);
  return groupNumber % 2 === 1;
};

/**
 * Get the tag info from the dicom dictionary.
 *
 * @returns {Array} The info as [vr, multiplicity, name].
 */
dwv.dicom.Tag.prototype.getInfoFromDictionary = function () {
  var info = null;
  if (typeof dwv.dicom.dictionary[this.getGroup()] !== 'undefined' &&
    typeof dwv.dicom.dictionary[this.getGroup()][this.getElement()] !==
      'undefined') {
    info = dwv.dicom.dictionary[this.getGroup()][this.getElement()];
  }
  return info;
};

/**
 * Get the tag Value Representation (VR) from the dicom dictionary.
 *
 * @returns {string} The VR.
 */
dwv.dicom.Tag.prototype.getVrFromDictionary = function () {
  var vr = null;
  var info = this.getInfoFromDictionary();
  if (info !== null) {
    vr = info[0];
  }
  return vr;
};

/**
 * Get the tag name from the dicom dictionary.
 *
 * @returns {string} The VR.
 */
dwv.dicom.Tag.prototype.getNameFromDictionary = function () {
  var name = null;
  var info = this.getInfoFromDictionary();
  if (info !== null) {
    name = info[2];
  }
  return name;
};

/**
 * Get the TransferSyntaxUID Tag.
 *
 * @returns {object} The tag.
 */
dwv.dicom.getTransferSyntaxUIDTag = function () {
  return new dwv.dicom.Tag('0x0002', '0x0010');
};

/**
 * Get the FileMetaInformationGroupLength Tag.
 *
 * @returns {object} The tag.
 */
dwv.dicom.getFileMetaInformationGroupLengthTag = function () {
  return new dwv.dicom.Tag('0x0002', '0x0000');
};

/**
 * Is the input tag the FileMetaInformationGroupLength Tag.
 *
 * @param {dwv.dicom.Tag} tag The tag to test.
 * @returns {boolean} True if the asked tag.
 */
dwv.dicom.isFileMetaInformationGroupLengthTag = function (tag) {
  return tag.equals(dwv.dicom.getFileMetaInformationGroupLengthTag());
};

/**
 * Get the Item Tag.
 *
 * @returns {dwv.dicom.Tag} The tag.
 */
dwv.dicom.getItemTag = function () {
  return new dwv.dicom.Tag('0xFFFE', '0xE000');
};

/**
 * Is the input tag the Item Tag.
 *
 * @param {dwv.dicom.Tag} tag The tag to test.
 * @returns {boolean} True if the asked tag.
 */
dwv.dicom.isItemTag = function (tag) {
  return tag.equals(dwv.dicom.getItemTag());
};

/**
 * Get the ItemDelimitationItem Tag.
 *
 * @returns {dwv.dicom.Tag} The tag.
 */
dwv.dicom.getItemDelimitationItemTag = function () {
  return new dwv.dicom.Tag('0xFFFE', '0xE00D');
};

/**
 * Is the input tag the ItemDelimitationItem Tag.
 *
 * @param {dwv.dicom.Tag} tag The tag to test.
 * @returns {boolean} True if the asked tag.
 */
dwv.dicom.isItemDelimitationItemTag = function (tag) {
  return tag.equals(dwv.dicom.getItemDelimitationItemTag());
};

/**
 * Get the SequenceDelimitationItem Tag.
 *
 * @returns {dwv.dicom.Tag} The tag.
 */
dwv.dicom.getSequenceDelimitationItemTag = function () {
  return new dwv.dicom.Tag('0xFFFE', '0xE0DD');
};

/**
 * Is the input tag the SequenceDelimitationItem Tag.
 *
 * @param {dwv.dicom.Tag} tag The tag to test.
 * @returns {boolean} True if the asked tag.
 */
dwv.dicom.isSequenceDelimitationItemTag = function (tag) {
  return tag.equals(dwv.dicom.getSequenceDelimitationItemTag());
};

/**
 * Get the PixelData Tag.
 *
 * @returns {dwv.dicom.Tag} The tag.
 */
dwv.dicom.getPixelDataTag = function () {
  return new dwv.dicom.Tag('0x7FE0', '0x0010');
};

/**
 * Is the input tag the PixelData Tag.
 *
 * @param {dwv.dicom.Tag} tag The tag to test.
 * @returns {boolean} True if the asked tag.
 */
dwv.dicom.isPixelDataTag = function (tag) {
  return tag.equals(dwv.dicom.getPixelDataTag());
};

/**
 * Get a tag from the dictionary using a tag string name.
 *
 * @param {string} tagName The tag string name.
 * @returns {object|null} The tag object or null if not found.
 */
dwv.dicom.getTagFromDictionary = function (tagName) {
  if (typeof tagName === 'undefined' || tagName === null) {
    return null;
  }
  var group = null;
  var element = null;
  var dict = dwv.dicom.dictionary;
  var keys0 = Object.keys(dict);
  var keys1 = null;
  var foundTag = false;
  // search through dictionary
  for (var k0 = 0, lenK0 = keys0.length; k0 < lenK0; ++k0) {
    group = keys0[k0];
    keys1 = Object.keys(dict[group]);
    for (var k1 = 0, lenK1 = keys1.length; k1 < lenK1; ++k1) {
      element = keys1[k1];
      if (dict[group][element][2] === tagName) {
        foundTag = true;
        break;
      }
    }
    if (foundTag) {
      break;
    }
  }
  var tag = null;
  if (foundTag) {
    tag = new dwv.dicom.Tag(group, element);
  }
  return tag;
};

// namespaces
var dwv = dwv || {};
dwv.dicom = dwv.dicom || {};

/**
 * Get the dwv UID prefix.
 * Issued by Medical Connections Ltd (www.medicalconnections.co.uk)
 *   on 25/10/2017.
 *
 * @returns {string} The dwv UID prefix.
 */
dwv.dicom.getDwvUIDPrefix = function () {
  return '1.2.826.0.1.3680043.9.7278.1';
};

// local generated uid counter
var _uidCount = 0;

/**
 * Get a UID for a DICOM tag.
 * Note: Use https://github.com/uuidjs/uuid?
 *
 * @see http://dicom.nema.org/dicom/2013/output/chtml/part05/chapter_9.html
 * @see http://dicomiseasy.blogspot.com/2011/12/chapter-4-dicom-objects-in-chapter-3.html
 * @see https://stackoverflow.com/questions/46304306/how-to-generate-unique-dicom-uid
 * @param {string} tagName The input tag.
 * @returns {string} The corresponding UID.
 */
dwv.dicom.getUID = function (tagName) {
  var prefix = dwv.dicom.getDwvUIDPrefix() + '.';
  var uid = '';
  if (tagName === 'ImplementationClassUID') {
    uid = prefix + dwv.getVersion();
  } else {
    // date (only numbers), do not keep milliseconds
    var date = (new Date()).toISOString().replace(/\D/g, '');
    var datePart = '.' + date.substring(0, 14);
    // count
    _uidCount += 1;
    var countPart = '.' + _uidCount;

    // uid = prefix . tag . date . count
    uid = prefix;

    // limit tag part to not exceed 64 length
    var nonTagLength = prefix.length + countPart.length + datePart.length;
    var leni = Math.min(tagName.length, 64 - nonTagLength);
    if (leni > 1) {
      var tagNumber = '';
      for (var i = 0; i < leni; ++i) {
        tagNumber += tagName.charCodeAt(i);
      }
      uid += tagNumber.substring(0, leni);
    }

    // finish
    uid += datePart + countPart;
  }
  return uid;
};

/**
 * Return true if the input number is even.
 *
 * @param {number} number The number to check.
 * @returns {boolean} True is the number is even.
 */
dwv.dicom.isEven = function (number) {
  return number % 2 === 0;
};

/**
 * Is the input VR a VR that stores data in a typed array.
 * TODO: include ox and xs?
 *
 * @param {string} vr The element VR.
 * @returns {boolean} True if the VR is a typed array one.
 */
dwv.dicom.isTypedArrayVr = function (vr) {
  var vrType = dwv.dicom.vrTypes[vr];
  return typeof vrType !== 'undefined' &&
    vrType !== 'string';
};

/**
 * Is the input VR a string VR.
 *
 * @param {string} vr The element VR.
 * @returns {boolean} True if the VR is a string one.
 */
dwv.dicom.isStringVr = function (vr) {
  var vrType = dwv.dicom.vrTypes[vr];
  return typeof vrType !== 'undefined' &&
    vrType === 'string';
};

/**
 * Is the input VR a VR that could need padding.
 * see http://dicom.nema.org/dicom/2013/output/chtml/part05/sect_6.2.html
 *
 * @param {string} vr The element VR.
 * @returns {boolean} True if the VR needs padding.
 */
dwv.dicom.isVrToPad = function (vr) {
  return dwv.dicom.isStringVr(vr) || vr === 'OB';
};

/**
 * Get the VR specific padding value.
 *
 * @param {string} vr The element VR.
 * @returns {boolean} The value used to pad.
 */
dwv.dicom.getVrPad = function (vr) {
  var pad = 0;
  if (dwv.dicom.isStringVr(vr)) {
    if (vr === 'UI') {
      pad = '\0';
    } else {
      pad = ' ';
    }
  }
  return pad;
};

/**
 * Push a value at the end of an input Uint8Array.
 *
 * @param {Uint8Array} arr The input array.
 * @param {number} value The value to push.
 * @returns {Uint8Array} The new array.
 */
dwv.dicom.uint8ArrayPush = function (arr, value) {
  var newArr = new Uint8Array(arr.length + 1);
  newArr.set(arr);
  newArr.set(value, arr.length);
  return newArr;
};

/**
 * Pad an input OB value.
 *
 * @param {Array|Uint8Array} value The input value.
 * @returns {Array|Uint8Array} The padded input.
 */
dwv.dicom.padOBValue = function (value) {
  if (value !== null &&
    typeof value !== 'undefined' &&
    typeof value.length !== 'undefined') {
    // calculate size and pad if needed
    if (value.length !== 0 &&
      typeof value[0].length !== 'undefined') {
      // handle array of array
      var size = 0;
      for (var i = 0; i < value.length; ++i) {
        size += value[i].length;
      }
      if (!dwv.dicom.isEven(size)) {
        value[value.length - 1] = dwv.dicom.uint8ArrayPush(
          value[value.length - 1], 0);
      }
    } else {
      if (!dwv.dicom.isEven(value.length)) {
        value = dwv.dicom.uint8ArrayPush(value, 0);
      }
    }
  } else {
    throw new Error('Cannot pad undefined or null OB value.');
  }
  // uint8ArrayPush may create a new array so we
  // need to return it
  return value;
};

/**
 * Helper method to flatten an array of typed arrays to 2D typed array
 *
 * @param {Array} initialArray array of typed arrays
 * @returns {object} a typed array containing all values
 */
dwv.dicom.flattenArrayOfTypedArrays = function (initialArray) {
  var initialArrayLength = initialArray.length;
  var arrayLength = initialArray[0].length;
  // If this is not a array of arrays, just return the initial one:
  if (typeof arrayLength === 'undefined') {
    return initialArray;
  }

  var flattenendArrayLength = initialArrayLength * arrayLength;

  var flattenedArray = new initialArray[0].constructor(flattenendArrayLength);

  for (var i = 0; i < initialArrayLength; i++) {
    var indexFlattenedArray = i * arrayLength;
    flattenedArray.set(initialArray[i], indexFlattenedArray);
  }
  return flattenedArray;
};

/**
 * Default text encoder.
 */
dwv.dicom.DefaultTextEncoder = function () {
  /**
   * Encode an input string.
   *
   * @param {string} str The string to encode.
   * @returns {Uint8Array} The encoded string.
   */
  this.encode = function (str) {
    var result = new Uint8Array(str.length);
    for (var i = 0, leni = str.length; i < leni; ++i) {
      result[i] = str.charCodeAt(i);
    }
    return result;
  };
};

/**
 * DICOM writer.
 *
 * Example usage:
 *   var parser = new dwv.dicom.DicomParser();
 *   parser.parse(this.response);
 *
 *   var writer = new dwv.dicom.DicomWriter(parser.getRawDicomElements());
 *   var blob = new Blob([writer.getBuffer()], {type: 'application/dicom'});
 *
 *   var element = document.getElementById("download");
 *   element.href = URL.createObjectURL(blob);
 *   element.download = "anonym.dcm";
 *
 * @class
 */
dwv.dicom.DicomWriter = function () {

  // flag to use VR=UN for private sequences, default to false
  // (mainly used in tests)
  this.useUnVrForPrivateSq = false;

  // possible tag actions
  var actions = {
    copy: function (item) {
      return item;
    },
    remove: function () {
      return null;
    },
    clear: function (item) {
      item.value = [];
      return item;
    },
    replace: function (item, value) {
      item.value = [value];
      return item;
    }
  };

  // default rules: just copy
  var defaultRules = {
    default: {action: 'copy', value: null}
  };

  /**
   * Public (modifiable) rules.
   * Set of objects as:
   *   name : { action: 'actionName', value: 'optionalValue }
   * The names are either 'default', tagName or groupName.
   * Each DICOM element will be checked to see if a rule is applicable.
   * First checked by tagName and then by groupName,
   * if nothing is found the default rule is applied.
   */
  this.rules = defaultRules;

  /**
   * Default text encoder.
   *
   * @private
   * @type {dwv.dicom.DefaultTextEncoder}
   */
  var defaultTextEncoder = new dwv.dicom.DefaultTextEncoder();

  /**
   * Special text encoder.
   *
   * @private
   * @type {dwv.dicom.DefaultTextEncoder|TextEncoder}
   */
  var textEncoder = defaultTextEncoder;

  /**
   * Encode string data.
   *
   * @param {number} str The string to encode.
   * @returns {Uint8Array} The encoded string.
   */
  this.encodeString = function (str) {
    return defaultTextEncoder.encode(str);
  };

  /**
   * Encode data as a UTF-8.
   *
   * @param {number} str The string to write.
   * @returns {Uint8Array} The encoded string.
   */
  this.encodeSpecialString = function (str) {
    return textEncoder.encode(str);
  };

  /**
   * Use a TextEncoder instead of the default text decoder.
   */
  this.useSpecialTextEncoder = function () {
    /**
     * The text encoder.
     *
     * @external TextEncoder
     * @see https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder
     */
    textEncoder = new TextEncoder();
  };

  /**
   * Example anonymisation rules.
   */
  this.anonymisationRules = {
    default: {action: 'remove', value: null},
    PatientName: {action: 'replace', value: 'Anonymized'}, // tag
    'Meta Element': {action: 'copy', value: null}, // group 'x0002'
    Acquisition: {action: 'copy', value: null}, // group 'x0018'
    'Image Presentation': {action: 'copy', value: null}, // group 'x0028'
    Procedure: {action: 'copy', value: null}, // group 'x0040'
    'Pixel Data': {action: 'copy', value: null} // group 'x7fe0'
  };

  /**
   * Get the element to write according to the class rules.
   * Priority order: tagName, groupName, default.
   *
   * @param {object} element The element to check
   * @returns {object} The element to write, can be null.
   */
  this.getElementToWrite = function (element) {
    // get group and tag string name
    var groupName = element.tag.getGroupName();
    var tagName = element.tag.getNameFromDictionary();

    // apply rules:
    var rule;
    if (typeof this.rules[element.tag.getKey()] !== 'undefined') {
      // 1. tag itself
      rule = this.rules[element.tag.getKey()];
    } else if (tagName !== null && typeof this.rules[tagName] !== 'undefined') {
      // 2. tag name
      rule = this.rules[tagName];
    } else if (typeof this.rules[groupName] !== 'undefined') {
      // 3. group name
      rule = this.rules[groupName];
    } else {
      // 4. default
      rule = this.rules['default'];
    }
    // apply action on element and return
    return actions[rule.action](element, rule.value);
  };
};

/**
 * Write a list of items.
 *
 * @param {dwv.dicom.DataWriter} writer The raw data writer.
 * @param {number} byteOffset The offset to start writing from.
 * @param {Array} items The list of items to write.
 * @param {boolean} isImplicit Is the DICOM VR implicit?
 * @returns {number} The new offset position.
 */
dwv.dicom.DicomWriter.prototype.writeDataElementItems = function (
  writer, byteOffset, items, isImplicit) {
  var item = null;
  for (var i = 0; i < items.length; ++i) {
    item = items[i];
    var itemKeys = Object.keys(item);
    if (itemKeys.length === 0) {
      continue;
    }
    // item element (create new to not modify original)
    var undefinedLength = false;
    if (typeof item.xFFFEE000.undefinedLength !== 'undefined') {
      undefinedLength = item.xFFFEE000.undefinedLength;
    }
    var itemElement = {
      tag: dwv.dicom.getItemTag(),
      vr: 'NONE',
      vl: undefinedLength ? 0xffffffff : item.xFFFEE000.vl,
      value: []
    };
    byteOffset = this.writeDataElement(
      writer, itemElement, byteOffset, isImplicit);
    // write rest
    for (var m = 0; m < itemKeys.length; ++m) {
      if (itemKeys[m] !== 'xFFFEE000' && itemKeys[m] !== 'xFFFEE00D') {
        byteOffset = this.writeDataElement(
          writer, item[itemKeys[m]], byteOffset, isImplicit);
      }
    }
    // item delimitation
    if (undefinedLength) {
      var itemDelimElement = {
        tag: dwv.dicom.getItemDelimitationItemTag(),
        vr: 'NONE',
        vl: 0,
        value: []
      };
      byteOffset = this.writeDataElement(
        writer, itemDelimElement, byteOffset, isImplicit);
    }
  }

  // return new offset
  return byteOffset;
};

/**
 * Write data with a specific Value Representation (VR).
 *
 * @param {dwv.dicom.DataWriter} writer The raw data writer.
 * @param {object} element The element to write.
 * @param {number} byteOffset The offset to start writing from.
 * @param {Array} value The array to write.
 * @param {boolean} isImplicit Is the DICOM VR implicit?
 * @returns {number} The new offset position.
 */
dwv.dicom.DicomWriter.prototype.writeDataElementValue = function (
  writer, element, byteOffset, value, isImplicit) {

  var startOffset = byteOffset;

  if (element.vr === 'NONE') {
    // nothing to do!
  } else if (value instanceof Uint8Array) {
    // binary data has been expanded 8 times at read
    if (value.length === 8 * element.vl) {
      byteOffset = writer.writeBinaryArray(byteOffset, value);
    } else {
      byteOffset = writer.writeUint8Array(byteOffset, value);
    }
  } else if (value instanceof Int8Array) {
    byteOffset = writer.writeInt8Array(byteOffset, value);
  } else if (value instanceof Uint16Array) {
    byteOffset = writer.writeUint16Array(byteOffset, value);
  } else if (value instanceof Int16Array) {
    byteOffset = writer.writeInt16Array(byteOffset, value);
  } else if (value instanceof Uint32Array) {
    byteOffset = writer.writeUint32Array(byteOffset, value);
  } else if (value instanceof Int32Array) {
    byteOffset = writer.writeInt32Array(byteOffset, value);
  } else if (value instanceof BigUint64Array) {
    byteOffset = writer.writeUint64Array(byteOffset, value);
  } else if (value instanceof BigInt64Array) {
    byteOffset = writer.writeInt64Array(byteOffset, value);
  } else {
    // switch according to VR if input type is undefined
    var vrType = dwv.dicom.vrTypes[element.vr];
    if (typeof vrType !== 'undefined') {
      if (vrType === 'Uint8') {
        byteOffset = writer.writeUint8Array(byteOffset, value);
      } else if (vrType === 'Uint16') {
        byteOffset = writer.writeUint16Array(byteOffset, value);
      } else if (vrType === 'Int16') {
        byteOffset = writer.writeInt16Array(byteOffset, value);
      } else if (vrType === 'Uint32') {
        byteOffset = writer.writeUint32Array(byteOffset, value);
      } else if (vrType === 'Int32') {
        byteOffset = writer.writeInt32Array(byteOffset, value);
      } else if (vrType === 'Uint64') {
        byteOffset = writer.writeUint64Array(byteOffset, value);
      } else if (vrType === 'Int64') {
        byteOffset = writer.writeInt64Array(byteOffset, value);
      } else if (vrType === 'Float32') {
        byteOffset = writer.writeFloat32Array(byteOffset, value);
      } else if (vrType === 'Float64') {
        byteOffset = writer.writeFloat64Array(byteOffset, value);
      } else if (vrType === 'string') {
        byteOffset = writer.writeUint8Array(byteOffset, value);
      } else {
        throw Error('Unknown VR type: ' + vrType);
      }
    } else if (element.vr === 'SQ') {
      byteOffset = this.writeDataElementItems(
        writer, byteOffset, value, isImplicit);
    } else if (element.vr === 'AT') {
      for (var i = 0; i < value.length; ++i) {
        var hexString = value[i] + '';
        var hexString1 = hexString.substring(1, 5);
        var hexString2 = hexString.substring(6, 10);
        var dec1 = parseInt(hexString1, 16);
        var dec2 = parseInt(hexString2, 16);
        var atValue = new Uint16Array([dec1, dec2]);
        byteOffset = writer.writeUint16Array(byteOffset, atValue);
      }
    } else {
      dwv.logger.warn('Unknown VR: ' + element.vr);
    }
  }

  if (element.vr !== 'SQ' && element.vr !== 'NONE') {
    var diff = byteOffset - startOffset;
    if (diff !== element.vl) {
      dwv.logger.warn('Offset difference and VL are not equal: ' +
        diff + ' != ' + element.vl + ', vr:' + element.vr);
    }
  }

  // return new offset
  return byteOffset;
};

/**
 * Write a pixel data element.
 *
 * @param {dwv.dicom.DataWriter} writer The raw data writer.
 * @param {object} element The element to write.
 * @param {number} byteOffset The offset to start writing from.
 * @param {Array} value The array to write.
 * @param {boolean} isImplicit Is the DICOM VR implicit?
 * @returns {number} The new offset position.
 */
dwv.dicom.DicomWriter.prototype.writePixelDataElementValue = function (
  writer, element, byteOffset, value, isImplicit) {
  // undefined length flag
  var undefinedLength = false;
  if (typeof element.undefinedLength !== 'undefined') {
    undefinedLength = element.undefinedLength;
  }
  // explicit length
  if (!undefinedLength) {
    var finalValue = value[0];
    // flatten multi frame
    if (value.length > 1) {
      finalValue = dwv.dicom.flattenArrayOfTypedArrays(value);
    }
    // write
    byteOffset = this.writeDataElementValue(
      writer, element, byteOffset, finalValue, isImplicit);
  } else {
    // pixel data as sequence
    var item = {};
    // first item: basic offset table
    item.xFFFEE000 = {
      tag: dwv.dicom.getItemTag(),
      vr: 'NONE',
      vl: 0,
      value: []
    };
    // data
    for (var i = 0; i < value.length; ++i) {
      item[i] = {
        tag: dwv.dicom.getItemTag(),
        vr: element.vr,
        vl: value[i].length,
        value: value[i]
      };
    }
    // write
    byteOffset = this.writeDataElementItems(
      writer, byteOffset, [item], isImplicit);
  }

  // return new offset
  return byteOffset;
};

/**
 * Write a data element.
 *
 * @param {dwv.dicom.DataWriter} writer The raw data writer.
 * @param {object} element The DICOM data element to write.
 * @param {number} byteOffset The offset to start writing from.
 * @param {boolean} isImplicit Is the DICOM VR implicit?
 * @returns {number} The new offset position.
 */
dwv.dicom.DicomWriter.prototype.writeDataElement = function (
  writer, element, byteOffset, isImplicit) {
  var isTagWithVR = element.tag.isWithVR();
  var is32bitVLVR = (isImplicit || !isTagWithVR)
    ? true : dwv.dicom.is32bitVLVR(element.vr);
  // group
  byteOffset = writer.writeHex(byteOffset, element.tag.getGroup());
  // element
  byteOffset = writer.writeHex(byteOffset, element.tag.getElement());
  // VR
  var vr = element.vr;
  // use VR=UN for private sequence
  if (this.useUnVrForPrivateSq &&
    element.tag.isPrivate() &&
    vr === 'SQ') {
    dwv.logger.warn('Write element using VR=UN for private sequence.');
    vr = 'UN';
  }
  if (isTagWithVR && !isImplicit) {
    byteOffset = writer.writeUint8Array(byteOffset, this.encodeString(vr));
    // reserved 2 bytes for 32bit VL
    if (is32bitVLVR) {
      byteOffset += 2;
    }
  }

  var undefinedLengthSequence = false;
  if (element.vr === 'SQ' ||
    dwv.dicom.isPixelDataTag(element.tag)) {
    if (typeof element.undefinedLength !== 'undefined') {
      undefinedLengthSequence = element.undefinedLength;
    }
  }
  var undefinedLengthItem = false;
  if (dwv.dicom.isItemTag(element.tag)) {
    if (typeof element.undefinedLength !== 'undefined') {
      undefinedLengthItem = element.undefinedLength;
    }
  }

  // update vl for sequence or item with undefined length
  var vl = element.vl;
  if (undefinedLengthSequence || undefinedLengthItem) {
    vl = 0xffffffff;
  }
  // VL
  if (is32bitVLVR) {
    byteOffset = writer.writeUint32(byteOffset, vl);
  } else {
    byteOffset = writer.writeUint16(byteOffset, vl);
  }

  // value
  var value = element.value;
  // check value
  if (typeof value === 'undefined') {
    value = [];
  }
  // write
  if (dwv.dicom.isPixelDataTag(element.tag)) {
    byteOffset = this.writePixelDataElementValue(
      writer, element, byteOffset, value, isImplicit);
  } else {
    byteOffset = this.writeDataElementValue(
      writer, element, byteOffset, value, isImplicit);
  }

  // sequence delimitation item for sequence with undefined length
  if (undefinedLengthSequence) {
    var seqDelimElement = {
      tag: dwv.dicom.getSequenceDelimitationItemTag(),
      vr: 'NONE',
      vl: 0,
      value: []
    };
    byteOffset = this.writeDataElement(
      writer, seqDelimElement, byteOffset, isImplicit);
  }

  // return new offset
  return byteOffset;
};

/**
 * Get the ArrayBuffer corresponding to input DICOM elements.
 *
 * @param {Array} dicomElements The wrapped elements to write.
 * @returns {ArrayBuffer} The elements as a buffer.
 */
dwv.dicom.DicomWriter.prototype.getBuffer = function (dicomElements) {
  // Transfer Syntax
  var syntax = dwv.dicom.cleanString(dicomElements.x00020010.value[0]);
  var isImplicit = dwv.dicom.isImplicitTransferSyntax(syntax);
  var isBigEndian = dwv.dicom.isBigEndianTransferSyntax(syntax);
  // Specific CharacterSet
  if (typeof dicomElements.x00080005 !== 'undefined') {
    var oldscs = dwv.dicom.cleanString(dicomElements.x00080005.value[0]);
    // force UTF-8 if not default character set
    if (typeof oldscs !== 'undefined' && oldscs !== 'ISO-IR 6') {
      dwv.logger.debug('Change charset to UTF, was: ' + oldscs);
      this.useSpecialTextEncoder();
      dicomElements.x00080005.value = ['ISO_IR 192'];
    }
  }
  // Bits Allocated (for image data)
  var bitsAllocated;
  if (typeof dicomElements.x00280100 !== 'undefined') {
    bitsAllocated = dicomElements.x00280100.value[0];
  }

  // calculate buffer size and split elements (meta and non meta)
  var totalSize = 128 + 4; // DICM
  var localSize = 0;
  var metaElements = [];
  var rawElements = [];
  var element;
  var groupName;
  var metaLength = 0;
  // FileMetaInformationGroupLength
  var fmiglTag = dwv.dicom.getFileMetaInformationGroupLengthTag();
  // FileMetaInformationVersion
  var fmivTag = new dwv.dicom.Tag('0x0002', '0x0001');
  // ImplementationClassUID
  var icUIDTag = new dwv.dicom.Tag('0x0002', '0x0012');
  // ImplementationVersionName
  var ivnTag = new dwv.dicom.Tag('0x0002', '0x0013');

  // loop through elements to get the buffer size
  var keys = Object.keys(dicomElements);
  for (var i = 0, leni = keys.length; i < leni; ++i) {
    element = this.getElementToWrite(dicomElements[keys[i]]);
    if (element !== null &&
       !fmiglTag.equals(element.tag) &&
       !fmivTag.equals(element.tag) &&
       !icUIDTag.equals(element.tag) &&
       !ivnTag.equals(element.tag)) {
      localSize = 0;

      // XB7 2020-04-17
      // Check if UN can be converted to correct VR.
      // This check must be done BEFORE calculating totalSize,
      // otherwise there may be extra null bytes at the end of the file
      // (dcmdump may crash because of these bytes)
      dwv.dicom.checkUnknownVR(element);

      // update value and vl
      this.setElementValue(
        element, element.value, isImplicit, bitsAllocated);

      // tag group name
      groupName = element.tag.getGroupName();

      // prefix
      if (groupName === 'Meta Element') {
        localSize += dwv.dicom.getDataElementPrefixByteSize(element.vr, false);
      } else {
        localSize += dwv.dicom.getDataElementPrefixByteSize(
          element.vr, isImplicit);
      }

      // value
      localSize += element.vl;

      // sort elements
      if (groupName === 'Meta Element') {
        metaElements.push(element);
        metaLength += localSize;
      } else {
        rawElements.push(element);
      }

      // add to total size
      totalSize += localSize;
    }
  }

  // FileMetaInformationVersion
  var fmiv = dwv.dicom.getDicomElement('FileMetaInformationVersion');
  var fmivSize = dwv.dicom.getDataElementPrefixByteSize(fmiv.vr, false);
  fmivSize += this.setElementValue(fmiv, [0, 1], false);
  metaElements.push(fmiv);
  metaLength += fmivSize;
  totalSize += fmivSize;
  // ImplementationClassUID
  var icUID = dwv.dicom.getDicomElement('ImplementationClassUID');
  var icUIDSize = dwv.dicom.getDataElementPrefixByteSize(icUID.vr, false);
  icUIDSize += this.setElementValue(
    icUID, [dwv.dicom.getUID('ImplementationClassUID')], false);
  metaElements.push(icUID);
  metaLength += icUIDSize;
  totalSize += icUIDSize;
  // ImplementationVersionName
  var ivn = dwv.dicom.getDicomElement('ImplementationVersionName');
  var ivnSize = dwv.dicom.getDataElementPrefixByteSize(ivn.vr, false);
  var ivnValue = 'DWV_' + dwv.getVersion();
  ivnSize += this.setElementValue(ivn, [ivnValue], false);
  metaElements.push(ivn);
  metaLength += ivnSize;
  totalSize += ivnSize;

  // sort elements
  var elemSortFunc = function (a, b) {
    return dwv.dicom.tagCompareFunction(a.tag, b.tag);
  };
  metaElements.sort(elemSortFunc);
  rawElements.sort(elemSortFunc);

  // create the FileMetaInformationGroupLength element
  var fmigl = dwv.dicom.getDicomElement('FileMetaInformationGroupLength');
  var fmiglSize = dwv.dicom.getDataElementPrefixByteSize(fmigl.vr, false);
  fmiglSize += this.setElementValue(
    fmigl, new Uint32Array([metaLength]), false);
  totalSize += fmiglSize;

  // create buffer
  var buffer = new ArrayBuffer(totalSize);
  var metaWriter = new dwv.dicom.DataWriter(buffer);
  var dataWriter = new dwv.dicom.DataWriter(buffer, !isBigEndian);

  var offset = 128;
  // DICM
  offset = metaWriter.writeUint8Array(offset, this.encodeString('DICM'));
  // FileMetaInformationGroupLength
  offset = this.writeDataElement(metaWriter, fmigl, offset, false);
  // write meta
  for (var j = 0, lenj = metaElements.length; j < lenj; ++j) {
    offset = this.writeDataElement(metaWriter, metaElements[j], offset, false);
  }

  // check meta position
  var preambleSize = 128 + 4;
  var metaOffset = preambleSize + fmiglSize + metaLength;
  if (offset !== metaOffset) {
    dwv.logger.warn('Bad size calculation... meta offset: ' + offset +
      ', calculated size:' + metaOffset +
      ' (diff:' + (offset - metaOffset) + ')');
  }

  // pass flag to writer
  dataWriter.useUnVrForPrivateSq = this.useUnVrForPrivateSq;
  // write non meta
  for (var k = 0, lenk = rawElements.length; k < lenk; ++k) {
    offset = this.writeDataElement(
      dataWriter, rawElements[k], offset, isImplicit);
  }

  // check final position
  if (offset !== totalSize) {
    dwv.logger.warn('Bad size calculation... final offset: ' + offset +
      ', calculated size:' + totalSize +
      ' (diff:' + (offset - totalSize) + ')');
  }
  // return
  return buffer;
};

/**
 * Fix for broken DICOM elements: Replace "UN" with correct VR if the
 * element exists in dictionary
 *
 * @param {object} element The DICOM element.
 */
dwv.dicom.checkUnknownVR = function (element) {
  if (element.vr === 'UN') {
    var dictVr = element.tag.getVrFromDictionary();
    if (dictVr !== null && element.vr !== dictVr) {
      element.vr = dictVr;
      dwv.logger.info('Element ' + element.tag.getGroup() +
        ' ' + element.tag.getElement() +
        ' VR changed from UN to ' + element.vr);
    }
  }
};

/**
 * Get a DICOM element from its tag name (value set separatly).
 *
 * @param {string} tagName The string tag name.
 * @returns {object} The DICOM element.
 */
dwv.dicom.getDicomElement = function (tagName) {
  var tag = dwv.dicom.getTagFromDictionary(tagName);
  return {
    tag: tag,
    vr: tag.getVrFromDictionary()
  };
};

/**
 * Get the number of bytes per element for a given VR type.
 *
 * @param {string} vrType The VR type as defined in the dictionary.
 * @returns {number} The bytes per element.
 */
dwv.dicom.getBpeForVrType = function (vrType) {
  var bpe;
  if (vrType === 'Uint8') {
    bpe = Uint8Array.BYTES_PER_ELEMENT;
  } else if (vrType === 'Uint16') {
    bpe = Uint16Array.BYTES_PER_ELEMENT;
  } else if (vrType === 'Int16') {
    bpe = Int16Array.BYTES_PER_ELEMENT;
  } else if (vrType === 'Uint32') {
    bpe = Uint32Array.BYTES_PER_ELEMENT;
  } else if (vrType === 'Int32') {
    bpe = Int32Array.BYTES_PER_ELEMENT;
  } else if (vrType === 'Float32') {
    bpe = Float32Array.BYTES_PER_ELEMENT;
  } else if (vrType === 'Float64') {
    bpe = Float64Array.BYTES_PER_ELEMENT;
  } else if (vrType === 'Uint64') {
    bpe = BigUint64Array.BYTES_PER_ELEMENT;
  } else if (vrType === 'Int64') {
    bpe = BigInt64Array.BYTES_PER_ELEMENT;
  }
  return bpe;
};

/**
 * Set a DICOM element value according to its VR (Value Representation).
 *
 * @param {object} element The DICOM element to set the value.
 * @param {object} value The value to set.
 * @param {boolean} isImplicit Does the data use implicit VR?
 * @param {number} bitsAllocated Bits allocated used for pixel data.
 * @returns {number} The total element size.
 */
dwv.dicom.DicomWriter.prototype.setElementValue = function (
  element, value, isImplicit, bitsAllocated) {
  // byte size of the element
  var size = 0;
  // special sequence case
  if (element.vr === 'SQ') {

    if (value !== null && value !== 0) {
      var newItems = [];
      var name;

      // explicit or undefined length sequence
      var undefinedLength = false;
      if (typeof element.undefinedLength !== 'undefined') {
        undefinedLength = element.undefinedLength;
        delete element.undefinedLength;
      }

      // items
      for (var i = 0; i < value.length; ++i) {
        var oldItemElements = value[i];
        var newItemElements = {};
        var subSize = 0;

        // check data
        if (oldItemElements === null || oldItemElements === 0) {
          continue;
        }

        // elements
        var itemKeys = Object.keys(oldItemElements);
        for (var j = 0, lenj = itemKeys.length; j < lenj; ++j) {
          var itemKey = itemKeys[j];
          var subElement = oldItemElements[itemKey];
          if (dwv.dicom.isItemTag(subElement.tag)) {
            continue;
          }
          // set item value
          subSize += this.setElementValue(
            subElement, subElement.value, isImplicit, bitsAllocated);
          newItemElements[itemKey] = subElement;
          // add prefix size
          subSize += dwv.dicom.getDataElementPrefixByteSize(
            subElement.vr, isImplicit);
        }

        // add item element (used to store its size)
        var itemElement = {
          tag: dwv.dicom.getItemTag(),
          vr: 'NONE',
          vl: subSize,
          value: []
        };
        if (undefinedLength) {
          itemElement.undefinedLength = undefinedLength;
        }
        name = itemElement.tag.getKey();
        newItemElements[name] = itemElement;
        subSize += dwv.dicom.getDataElementPrefixByteSize(
          itemElement.vr, isImplicit);

        // add item delimitation size
        if (undefinedLength) {
          subSize += dwv.dicom.getDataElementPrefixByteSize(
            'NONE', isImplicit);
        }

        size += subSize;
        newItems.push(newItemElements);
      }

      // add sequence delimitation size
      if (undefinedLength) {
        size += dwv.dicom.getDataElementPrefixByteSize('NONE', isImplicit);
      }

      // update sequence element
      element.value = newItems;
      element.vl = size;
      if (undefinedLength) {
        element.undefinedLength = undefinedLength;
      }
    }
  } else {
    // pad if necessary
    if (dwv.dicom.isVrToPad(element.vr)) {
      var pad = dwv.dicom.getVrPad(element.vr);
      // encode string
      // TODO: not sure for UN...
      if (dwv.dicom.isStringVr(element.vr)) {
        if (dwv.dicom.charSetString.includes(element.vr)) {
          value = this.encodeSpecialString(value.join('\\'));
          pad = this.encodeSpecialString(pad);
        } else {
          value = this.encodeString(value.join('\\'));
          pad = this.encodeString(pad);
        }
        if (!dwv.dicom.isEven(value.length)) {
          value = dwv.dicom.uint8ArrayPush(value, pad);
        }
      } else if (element.vr === 'OB') {
        value = dwv.dicom.padOBValue(value);
      }
    }

    // calculate byte size
    size = 0;
    if (element.vr === 'AT') {
      size = 4 * value.length;
    } else if (element.vr === 'xs') {
      size = value.length * Uint16Array.BYTES_PER_ELEMENT;
    } else if (dwv.dicom.isTypedArrayVr(element.vr) || element.vr === 'ox') {
      if (dwv.dicom.isPixelDataTag(element.tag) &&
        Array.isArray(value)) {
        size = 0;
        for (var b = 0; b < value.length; ++b) {
          size += value[b].length;
        }
      } else {
        size = value.length;
      }

      // convert size to bytes
      var vrType = dwv.dicom.vrTypes[element.vr];
      if (dwv.dicom.isPixelDataTag(element.tag) || element.vr === 'ox') {
        if (element.undefinedLength) {
          var itemPrefixSize =
            dwv.dicom.getDataElementPrefixByteSize('NONE', isImplicit);
          // offset table
          size += itemPrefixSize;
          // pixel items
          size += itemPrefixSize * value.length;
          // add sequence delimitation size
          size += itemPrefixSize;
        } else {
          // use bitsAllocated for pixel data
          // no need to multiply for 8 bits
          if (typeof bitsAllocated !== 'undefined') {
            if (bitsAllocated === 1) {
              // binary data
              size /= 8;
            } else if (bitsAllocated === 16) {
              size *= Uint16Array.BYTES_PER_ELEMENT;
            }
          }
        }
      } else if (typeof vrType !== 'undefined') {
        var bpe = dwv.dicom.getBpeForVrType(vrType);
        if (typeof bpe !== 'undefined') {
          size *= bpe;
        } else {
          throw Error('Unknown bytes per element for VR type: ' + vrType);
        }
      } else {
        throw Error('Unsupported element: ' + element.vr);
      }
    } else {
      size = value.length;
    }

    element.value = value;
    element.vl = size;
  }

  // return the size of that data
  return size;
};

/**
 * Get the DICOM elements from a DICOM json tags object.
 * The json is a simplified version of the oficial DICOM json with
 * tag names instead of keys and direct values (no value property) for
 * simple tags.
 *
 * @param {object} jsonTags The DICOM json tags object.
 * @returns {object} The DICOM elements.
 */
dwv.dicom.getElementsFromJSONTags = function (jsonTags) {
  var keys = Object.keys(jsonTags);
  var dicomElements = {};
  for (var k = 0, len = keys.length; k < len; ++k) {
    // get the DICOM element definition from its name
    var tag = dwv.dicom.getTagFromDictionary(keys[k]);
    if (!tag) {
      continue;
    }
    var vr = tag.getVrFromDictionary();
    // tag value
    var value;
    var undefinedLength = false;
    var jsonTag = jsonTags[keys[k]];
    if (vr === 'SQ') {
      var items = [];
      if (typeof jsonTag.undefinedLength !== 'undefined') {
        undefinedLength = jsonTag.undefinedLength;
      }
      if (typeof jsonTag.value !== 'undefined' &&
        jsonTag.value !== null) {
        for (var i = 0; i < jsonTag.value.length; ++i) {
          items.push(dwv.dicom.getElementsFromJSONTags(jsonTag.value[i]));
        }
      } else {
        dwv.logger.trace('Undefined or null jsonTag SQ value.');
      }
      value = items;
    } else {
      if (Array.isArray(jsonTag)) {
        value = jsonTag;
      } else {
        value = [jsonTag];
      }
    }
    // create element
    var dicomElement = {
      tag: tag,
      vr: vr,
      value: value
    };
    if (undefinedLength) {
      dicomElement.undefinedLength = undefinedLength;
    }
    // store
    dicomElements[tag.getKey()] = dicomElement;
  }
  // return
  return dicomElements;
};

/*eslint max-len:0*/
// namespaces
var dwv = dwv || {};
dwv.dicom = dwv.dicom || {};

/**
 * DICOM tag dictionary 2022a.
 * Generated using xml standard conversion from {@link https://github.com/ivmartel/dcmStdToJs} v0.1.0.
 * Conversion changes:
 * - (vr) 'See Note' -> 'NONE', 'OB or OW' -> 'ox', 'US or SS' -> 'xs'
 * - added 'GenericGroupLength' element to each group
 * Local changes:
 * - tag numbers with 'xx' were replaced with '00', 'xxx' with '001' and
 *  'xxxx' with '0004'
 */
dwv.dicom.dictionary = {
  '0x0000': {
    '0x0000': ['UL', '1', 'CommandGroupLength'],
    '0x0001': ['UL', '1', 'CommandLengthToEnd'],
    '0x0002': ['UI', '1', 'AffectedSOPClassUID'],
    '0x0003': ['UI', '1', 'RequestedSOPClassUID'],
    '0x0010': ['SH', '1', 'CommandRecognitionCode'],
    '0x0100': ['US', '1', 'CommandField'],
    '0x0110': ['US', '1', 'MessageID'],
    '0x0120': ['US', '1', 'MessageIDBeingRespondedTo'],
    '0x0200': ['AE', '1', 'Initiator'],
    '0x0300': ['AE', '1', 'Receiver'],
    '0x0400': ['AE', '1', 'FindLocation'],
    '0x0600': ['AE', '1', 'MoveDestination'],
    '0x0700': ['US', '1', 'Priority'],
    '0x0800': ['US', '1', 'CommandDataSetType'],
    '0x0850': ['US', '1', 'NumberOfMatches'],
    '0x0860': ['US', '1', 'ResponseSequenceNumber'],
    '0x0900': ['US', '1', 'Status'],
    '0x0901': ['AT', '1-n', 'OffendingElement'],
    '0x0902': ['LO', '1', 'ErrorComment'],
    '0x0903': ['US', '1', 'ErrorID'],
    '0x1000': ['UI', '1', 'AffectedSOPInstanceUID'],
    '0x1001': ['UI', '1', 'RequestedSOPInstanceUID'],
    '0x1002': ['US', '1', 'EventTypeID'],
    '0x1005': ['AT', '1-n', 'AttributeIdentifierList'],
    '0x1008': ['US', '1', 'ActionTypeID'],
    '0x1020': ['US', '1', 'NumberOfRemainingSuboperations'],
    '0x1021': ['US', '1', 'NumberOfCompletedSuboperations'],
    '0x1022': ['US', '1', 'NumberOfFailedSuboperations'],
    '0x1023': ['US', '1', 'NumberOfWarningSuboperations'],
    '0x1030': ['AE', '1', 'MoveOriginatorApplicationEntityTitle'],
    '0x1031': ['US', '1', 'MoveOriginatorMessageID'],
    '0x4000': ['LT', '1', 'DialogReceiver'],
    '0x4010': ['LT', '1', 'TerminalType'],
    '0x5010': ['SH', '1', 'MessageSetID'],
    '0x5020': ['SH', '1', 'EndMessageID'],
    '0x5110': ['LT', '1', 'DisplayFormat'],
    '0x5120': ['LT', '1', 'PagePositionID'],
    '0x5130': ['CS', '1', 'TextFormatID'],
    '0x5140': ['CS', '1', 'NormalReverse'],
    '0x5150': ['CS', '1', 'AddGrayScale'],
    '0x5160': ['CS', '1', 'Borders'],
    '0x5170': ['IS', '1', 'Copies'],
    '0x5180': ['CS', '1', 'CommandMagnificationType'],
    '0x5190': ['CS', '1', 'Erase'],
    '0x51A0': ['CS', '1', 'Print'],
    '0x51B0': ['US', '1-n', 'Overlays']
  },
  '0x0002': {
    '0x0000': ['UL', '1', 'FileMetaInformationGroupLength'],
    '0x0001': ['OB', '1', 'FileMetaInformationVersion'],
    '0x0002': ['UI', '1', 'MediaStorageSOPClassUID'],
    '0x0003': ['UI', '1', 'MediaStorageSOPInstanceUID'],
    '0x0010': ['UI', '1', 'TransferSyntaxUID'],
    '0x0012': ['UI', '1', 'ImplementationClassUID'],
    '0x0013': ['SH', '1', 'ImplementationVersionName'],
    '0x0016': ['AE', '1', 'SourceApplicationEntityTitle'],
    '0x0017': ['AE', '1', 'SendingApplicationEntityTitle'],
    '0x0018': ['AE', '1', 'ReceivingApplicationEntityTitle'],
    '0x0026': ['UR', '1', 'SourcePresentationAddress'],
    '0x0027': ['UR', '1', 'SendingPresentationAddress'],
    '0x0028': ['UR', '1', 'ReceivingPresentationAddress'],
    '0x0031': ['OB', '1', 'RTVMetaInformationVersion'],
    '0x0032': ['UI', '1', 'RTVCommunicationSOPClassUID'],
    '0x0033': ['UI', '1', 'RTVCommunicationSOPInstanceUID'],
    '0x0035': ['OB', '1', 'RTVSourceIdentifier'],
    '0x0036': ['OB', '1', 'RTVFlowIdentifier'],
    '0x0037': ['UL', '1', 'RTVFlowRTPSamplingRate'],
    '0x0038': ['FD', '1', 'RTVFlowActualFrameDuration'],
    '0x0100': ['UI', '1', 'PrivateInformationCreatorUID'],
    '0x0102': ['OB', '1', 'PrivateInformation']
  },
  '0x0004': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x1130': ['CS', '1', 'FileSetID'],
    '0x1141': ['CS', '1-8', 'FileSetDescriptorFileID'],
    '0x1142': ['CS', '1', 'SpecificCharacterSetOfFileSetDescriptorFile'],
    '0x1200': ['UL', '1', 'OffsetOfTheFirstDirectoryRecordOfTheRootDirectoryEntity'],
    '0x1202': ['UL', '1', 'OffsetOfTheLastDirectoryRecordOfTheRootDirectoryEntity'],
    '0x1212': ['US', '1', 'FileSetConsistencyFlag'],
    '0x1220': ['SQ', '1', 'DirectoryRecordSequence'],
    '0x1400': ['UL', '1', 'OffsetOfTheNextDirectoryRecord'],
    '0x1410': ['US', '1', 'RecordInUseFlag'],
    '0x1420': ['UL', '1', 'OffsetOfReferencedLowerLevelDirectoryEntity'],
    '0x1430': ['CS', '1', 'DirectoryRecordType'],
    '0x1432': ['UI', '1', 'PrivateRecordUID'],
    '0x1500': ['CS', '1-8', 'ReferencedFileID'],
    '0x1504': ['UL', '1', 'MRDRDirectoryRecordOffset'],
    '0x1510': ['UI', '1', 'ReferencedSOPClassUIDInFile'],
    '0x1511': ['UI', '1', 'ReferencedSOPInstanceUIDInFile'],
    '0x1512': ['UI', '1', 'ReferencedTransferSyntaxUIDInFile'],
    '0x151A': ['UI', '1-n', 'ReferencedRelatedGeneralSOPClassUIDInFile'],
    '0x1600': ['UL', '1', 'NumberOfReferences']
  },
  '0x0008': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0001': ['UL', '1', 'LengthToEnd'],
    '0x0005': ['CS', '1-n', 'SpecificCharacterSet'],
    '0x0006': ['SQ', '1', 'LanguageCodeSequence'],
    '0x0008': ['CS', '2-n', 'ImageType'],
    '0x0010': ['SH', '1', 'RecognitionCode'],
    '0x0012': ['DA', '1', 'InstanceCreationDate'],
    '0x0013': ['TM', '1', 'InstanceCreationTime'],
    '0x0014': ['UI', '1', 'InstanceCreatorUID'],
    '0x0015': ['DT', '1', 'InstanceCoercionDateTime'],
    '0x0016': ['UI', '1', 'SOPClassUID'],
    '0x0018': ['UI', '1', 'SOPInstanceUID'],
    '0x001A': ['UI', '1-n', 'RelatedGeneralSOPClassUID'],
    '0x001B': ['UI', '1', 'OriginalSpecializedSOPClassUID'],
    '0x0020': ['DA', '1', 'StudyDate'],
    '0x0021': ['DA', '1', 'SeriesDate'],
    '0x0022': ['DA', '1', 'AcquisitionDate'],
    '0x0023': ['DA', '1', 'ContentDate'],
    '0x0024': ['DA', '1', 'OverlayDate'],
    '0x0025': ['DA', '1', 'CurveDate'],
    '0x002A': ['DT', '1', 'AcquisitionDateTime'],
    '0x0030': ['TM', '1', 'StudyTime'],
    '0x0031': ['TM', '1', 'SeriesTime'],
    '0x0032': ['TM', '1', 'AcquisitionTime'],
    '0x0033': ['TM', '1', 'ContentTime'],
    '0x0034': ['TM', '1', 'OverlayTime'],
    '0x0035': ['TM', '1', 'CurveTime'],
    '0x0040': ['US', '1', 'DataSetType'],
    '0x0041': ['LO', '1', 'DataSetSubtype'],
    '0x0042': ['CS', '1', 'NuclearMedicineSeriesType'],
    '0x0050': ['SH', '1', 'AccessionNumber'],
    '0x0051': ['SQ', '1', 'IssuerOfAccessionNumberSequence'],
    '0x0052': ['CS', '1', 'QueryRetrieveLevel'],
    '0x0053': ['CS', '1', 'QueryRetrieveView'],
    '0x0054': ['AE', '1-n', 'RetrieveAETitle'],
    '0x0055': ['AE', '1', 'StationAETitle'],
    '0x0056': ['CS', '1', 'InstanceAvailability'],
    '0x0058': ['UI', '1-n', 'FailedSOPInstanceUIDList'],
    '0x0060': ['CS', '1', 'Modality'],
    '0x0061': ['CS', '1-n', 'ModalitiesInStudy'],
    '0x0062': ['UI', '1-n', 'SOPClassesInStudy'],
    '0x0063': ['SQ', '1', 'AnatomicRegionsInStudyCodeSequence'],
    '0x0064': ['CS', '1', 'ConversionType'],
    '0x0068': ['CS', '1', 'PresentationIntentType'],
    '0x0070': ['LO', '1', 'Manufacturer'],
    '0x0080': ['LO', '1', 'InstitutionName'],
    '0x0081': ['ST', '1', 'InstitutionAddress'],
    '0x0082': ['SQ', '1', 'InstitutionCodeSequence'],
    '0x0090': ['PN', '1', 'ReferringPhysicianName'],
    '0x0092': ['ST', '1', 'ReferringPhysicianAddress'],
    '0x0094': ['SH', '1-n', 'ReferringPhysicianTelephoneNumbers'],
    '0x0096': ['SQ', '1', 'ReferringPhysicianIdentificationSequence'],
    '0x009C': ['PN', '1-n', 'ConsultingPhysicianName'],
    '0x009D': ['SQ', '1', 'ConsultingPhysicianIdentificationSequence'],
    '0x0100': ['SH', '1', 'CodeValue'],
    '0x0101': ['LO', '1', 'ExtendedCodeValue'],
    '0x0102': ['SH', '1', 'CodingSchemeDesignator'],
    '0x0103': ['SH', '1', 'CodingSchemeVersion'],
    '0x0104': ['LO', '1', 'CodeMeaning'],
    '0x0105': ['CS', '1', 'MappingResource'],
    '0x0106': ['DT', '1', 'ContextGroupVersion'],
    '0x0107': ['DT', '1', 'ContextGroupLocalVersion'],
    '0x0108': ['LT', '1', 'ExtendedCodeMeaning'],
    '0x0109': ['SQ', '1', 'CodingSchemeResourcesSequence'],
    '0x010A': ['CS', '1', 'CodingSchemeURLType'],
    '0x010B': ['CS', '1', 'ContextGroupExtensionFlag'],
    '0x010C': ['UI', '1', 'CodingSchemeUID'],
    '0x010D': ['UI', '1', 'ContextGroupExtensionCreatorUID'],
    '0x010E': ['UR', '1', 'CodingSchemeURL'],
    '0x010F': ['CS', '1', 'ContextIdentifier'],
    '0x0110': ['SQ', '1', 'CodingSchemeIdentificationSequence'],
    '0x0112': ['LO', '1', 'CodingSchemeRegistry'],
    '0x0114': ['ST', '1', 'CodingSchemeExternalID'],
    '0x0115': ['ST', '1', 'CodingSchemeName'],
    '0x0116': ['ST', '1', 'CodingSchemeResponsibleOrganization'],
    '0x0117': ['UI', '1', 'ContextUID'],
    '0x0118': ['UI', '1', 'MappingResourceUID'],
    '0x0119': ['UC', '1', 'LongCodeValue'],
    '0x0120': ['UR', '1', 'URNCodeValue'],
    '0x0121': ['SQ', '1', 'EquivalentCodeSequence'],
    '0x0122': ['LO', '1', 'MappingResourceName'],
    '0x0123': ['SQ', '1', 'ContextGroupIdentificationSequence'],
    '0x0124': ['SQ', '1', 'MappingResourceIdentificationSequence'],
    '0x0201': ['SH', '1', 'TimezoneOffsetFromUTC'],
    '0x0202': ['', '', ''],
    '0x0220': ['SQ', '1', 'ResponsibleGroupCodeSequence'],
    '0x0221': ['CS', '1', 'EquipmentModality'],
    '0x0222': ['LO', '1', 'ManufacturerRelatedModelGroup'],
    '0x0300': ['SQ', '1', 'PrivateDataElementCharacteristicsSequence'],
    '0x0301': ['US', '1', 'PrivateGroupReference'],
    '0x0302': ['LO', '1', 'PrivateCreatorReference'],
    '0x0303': ['CS', '1', 'BlockIdentifyingInformationStatus'],
    '0x0304': ['US', '1-n', 'NonidentifyingPrivateElements'],
    '0x0305': ['SQ', '1', 'DeidentificationActionSequence'],
    '0x0306': ['US', '1-n', 'IdentifyingPrivateElements'],
    '0x0307': ['CS', '1', 'DeidentificationAction'],
    '0x0308': ['US', '1', 'PrivateDataElement'],
    '0x0309': ['UL', '1-3', 'PrivateDataElementValueMultiplicity'],
    '0x030A': ['CS', '1', 'PrivateDataElementValueRepresentation'],
    '0x030B': ['UL', '1-2', 'PrivateDataElementNumberOfItems'],
    '0x030C': ['UC', '1', 'PrivateDataElementName'],
    '0x030D': ['UC', '1', 'PrivateDataElementKeyword'],
    '0x030E': ['UT', '1', 'PrivateDataElementDescription'],
    '0x030F': ['UT', '1', 'PrivateDataElementEncoding'],
    '0x0310': ['SQ', '1', 'PrivateDataElementDefinitionSequence'],
    '0x1000': ['AE', '1', 'NetworkID'],
    '0x1010': ['SH', '1', 'StationName'],
    '0x1030': ['LO', '1', 'StudyDescription'],
    '0x1032': ['SQ', '1', 'ProcedureCodeSequence'],
    '0x103E': ['LO', '1', 'SeriesDescription'],
    '0x103F': ['SQ', '1', 'SeriesDescriptionCodeSequence'],
    '0x1040': ['LO', '1', 'InstitutionalDepartmentName'],
    '0x1041': ['SQ', '1', 'InstitutionalDepartmentTypeCodeSequence'],
    '0x1048': ['PN', '1-n', 'PhysiciansOfRecord'],
    '0x1049': ['SQ', '1', 'PhysiciansOfRecordIdentificationSequence'],
    '0x1050': ['PN', '1-n', 'PerformingPhysicianName'],
    '0x1052': ['SQ', '1', 'PerformingPhysicianIdentificationSequence'],
    '0x1060': ['PN', '1-n', 'NameOfPhysiciansReadingStudy'],
    '0x1062': ['SQ', '1', 'PhysiciansReadingStudyIdentificationSequence'],
    '0x1070': ['PN', '1-n', 'OperatorsName'],
    '0x1072': ['SQ', '1', 'OperatorIdentificationSequence'],
    '0x1080': ['LO', '1-n', 'AdmittingDiagnosesDescription'],
    '0x1084': ['SQ', '1', 'AdmittingDiagnosesCodeSequence'],
    '0x1090': ['LO', '1', 'ManufacturerModelName'],
    '0x1100': ['SQ', '1', 'ReferencedResultsSequence'],
    '0x1110': ['SQ', '1', 'ReferencedStudySequence'],
    '0x1111': ['SQ', '1', 'ReferencedPerformedProcedureStepSequence'],
    '0x1115': ['SQ', '1', 'ReferencedSeriesSequence'],
    '0x1120': ['SQ', '1', 'ReferencedPatientSequence'],
    '0x1125': ['SQ', '1', 'ReferencedVisitSequence'],
    '0x1130': ['SQ', '1', 'ReferencedOverlaySequence'],
    '0x1134': ['SQ', '1', 'ReferencedStereometricInstanceSequence'],
    '0x113A': ['SQ', '1', 'ReferencedWaveformSequence'],
    '0x1140': ['SQ', '1', 'ReferencedImageSequence'],
    '0x1145': ['SQ', '1', 'ReferencedCurveSequence'],
    '0x114A': ['SQ', '1', 'ReferencedInstanceSequence'],
    '0x114B': ['SQ', '1', 'ReferencedRealWorldValueMappingInstanceSequence'],
    '0x1150': ['UI', '1', 'ReferencedSOPClassUID'],
    '0x1155': ['UI', '1', 'ReferencedSOPInstanceUID'],
    '0x1156': ['SQ', '1', 'DefinitionSourceSequence'],
    '0x115A': ['UI', '1-n', 'SOPClassesSupported'],
    '0x1160': ['IS', '1-n', 'ReferencedFrameNumber'],
    '0x1161': ['UL', '1-n', 'SimpleFrameList'],
    '0x1162': ['UL', '3-3n', 'CalculatedFrameList'],
    '0x1163': ['FD', '2', 'TimeRange'],
    '0x1164': ['SQ', '1', 'FrameExtractionSequence'],
    '0x1167': ['UI', '1', 'MultiFrameSourceSOPInstanceUID'],
    '0x1190': ['UR', '1', 'RetrieveURL'],
    '0x1195': ['UI', '1', 'TransactionUID'],
    '0x1196': ['US', '1', 'WarningReason'],
    '0x1197': ['US', '1', 'FailureReason'],
    '0x1198': ['SQ', '1', 'FailedSOPSequence'],
    '0x1199': ['SQ', '1', 'ReferencedSOPSequence'],
    '0x119A': ['SQ', '1', 'OtherFailuresSequence'],
    '0x1200': ['SQ', '1', 'StudiesContainingOtherReferencedInstancesSequence'],
    '0x1250': ['SQ', '1', 'RelatedSeriesSequence'],
    '0x2110': ['CS', '1', 'LossyImageCompressionRetired'],
    '0x2111': ['ST', '1', 'DerivationDescription'],
    '0x2112': ['SQ', '1', 'SourceImageSequence'],
    '0x2120': ['SH', '1', 'StageName'],
    '0x2122': ['IS', '1', 'StageNumber'],
    '0x2124': ['IS', '1', 'NumberOfStages'],
    '0x2127': ['SH', '1', 'ViewName'],
    '0x2128': ['IS', '1', 'ViewNumber'],
    '0x2129': ['IS', '1', 'NumberOfEventTimers'],
    '0x212A': ['IS', '1', 'NumberOfViewsInStage'],
    '0x2130': ['DS', '1-n', 'EventElapsedTimes'],
    '0x2132': ['LO', '1-n', 'EventTimerNames'],
    '0x2133': ['SQ', '1', 'EventTimerSequence'],
    '0x2134': ['FD', '1', 'EventTimeOffset'],
    '0x2135': ['SQ', '1', 'EventCodeSequence'],
    '0x2142': ['IS', '1', 'StartTrim'],
    '0x2143': ['IS', '1', 'StopTrim'],
    '0x2144': ['IS', '1', 'RecommendedDisplayFrameRate'],
    '0x2200': ['CS', '1', 'TransducerPosition'],
    '0x2204': ['CS', '1', 'TransducerOrientation'],
    '0x2208': ['CS', '1', 'AnatomicStructure'],
    '0x2218': ['SQ', '1', 'AnatomicRegionSequence'],
    '0x2220': ['SQ', '1', 'AnatomicRegionModifierSequence'],
    '0x2228': ['SQ', '1', 'PrimaryAnatomicStructureSequence'],
    '0x2229': ['SQ', '1', 'AnatomicStructureSpaceOrRegionSequence'],
    '0x2230': ['SQ', '1', 'PrimaryAnatomicStructureModifierSequence'],
    '0x2240': ['SQ', '1', 'TransducerPositionSequence'],
    '0x2242': ['SQ', '1', 'TransducerPositionModifierSequence'],
    '0x2244': ['SQ', '1', 'TransducerOrientationSequence'],
    '0x2246': ['SQ', '1', 'TransducerOrientationModifierSequence'],
    '0x2251': ['SQ', '1', 'AnatomicStructureSpaceOrRegionCodeSequenceTrial'],
    '0x2253': ['SQ', '1', 'AnatomicPortalOfEntranceCodeSequenceTrial'],
    '0x2255': ['SQ', '1', 'AnatomicApproachDirectionCodeSequenceTrial'],
    '0x2256': ['ST', '1', 'AnatomicPerspectiveDescriptionTrial'],
    '0x2257': ['SQ', '1', 'AnatomicPerspectiveCodeSequenceTrial'],
    '0x2258': ['ST', '1', 'AnatomicLocationOfExaminingInstrumentDescriptionTrial'],
    '0x2259': ['SQ', '1', 'AnatomicLocationOfExaminingInstrumentCodeSequenceTrial'],
    '0x225A': ['SQ', '1', 'AnatomicStructureSpaceOrRegionModifierCodeSequenceTrial'],
    '0x225C': ['SQ', '1', 'OnAxisBackgroundAnatomicStructureCodeSequenceTrial'],
    '0x3001': ['SQ', '1', 'AlternateRepresentationSequence'],
    '0x3002': ['UI', '1-n', 'AvailableTransferSyntaxUID'],
    '0x3010': ['UI', '1-n', 'IrradiationEventUID'],
    '0x3011': ['SQ', '1', 'SourceIrradiationEventSequence'],
    '0x3012': ['UI', '1', 'RadiopharmaceuticalAdministrationEventUID'],
    '0x4000': ['LT', '1', 'IdentifyingComments'],
    '0x9007': ['CS', '4', 'FrameType'],
    '0x9092': ['SQ', '1', 'ReferencedImageEvidenceSequence'],
    '0x9121': ['SQ', '1', 'ReferencedRawDataSequence'],
    '0x9123': ['UI', '1', 'CreatorVersionUID'],
    '0x9124': ['SQ', '1', 'DerivationImageSequence'],
    '0x9154': ['SQ', '1', 'SourceImageEvidenceSequence'],
    '0x9205': ['CS', '1', 'PixelPresentation'],
    '0x9206': ['CS', '1', 'VolumetricProperties'],
    '0x9207': ['CS', '1', 'VolumeBasedCalculationTechnique'],
    '0x9208': ['CS', '1', 'ComplexImageComponent'],
    '0x9209': ['CS', '1', 'AcquisitionContrast'],
    '0x9215': ['SQ', '1', 'DerivationCodeSequence'],
    '0x9237': ['SQ', '1', 'ReferencedPresentationStateSequence'],
    '0x9410': ['SQ', '1', 'ReferencedOtherPlaneSequence'],
    '0x9458': ['SQ', '1', 'FrameDisplaySequence'],
    '0x9459': ['FL', '1', 'RecommendedDisplayFrameRateInFloat'],
    '0x9460': ['CS', '1', 'SkipFrameRangeFlag']
  },
  '0x0010': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0010': ['PN', '1', 'PatientName'],
    '0x0020': ['LO', '1', 'PatientID'],
    '0x0021': ['LO', '1', 'IssuerOfPatientID'],
    '0x0022': ['CS', '1', 'TypeOfPatientID'],
    '0x0024': ['SQ', '1', 'IssuerOfPatientIDQualifiersSequence'],
    '0x0026': ['SQ', '1', 'SourcePatientGroupIdentificationSequence'],
    '0x0027': ['SQ', '1', 'GroupOfPatientsIdentificationSequence'],
    '0x0028': ['US', '3', 'SubjectRelativePositionInImage'],
    '0x0030': ['DA', '1', 'PatientBirthDate'],
    '0x0032': ['TM', '1', 'PatientBirthTime'],
    '0x0033': ['LO', '1', 'PatientBirthDateInAlternativeCalendar'],
    '0x0034': ['LO', '1', 'PatientDeathDateInAlternativeCalendar'],
    '0x0035': ['CS', '1', 'PatientAlternativeCalendar'],
    '0x0040': ['CS', '1', 'PatientSex'],
    '0x0050': ['SQ', '1', 'PatientInsurancePlanCodeSequence'],
    '0x0101': ['SQ', '1', 'PatientPrimaryLanguageCodeSequence'],
    '0x0102': ['SQ', '1', 'PatientPrimaryLanguageModifierCodeSequence'],
    '0x0200': ['CS', '1', 'QualityControlSubject'],
    '0x0201': ['SQ', '1', 'QualityControlSubjectTypeCodeSequence'],
    '0x0212': ['UC', '1', 'StrainDescription'],
    '0x0213': ['LO', '1', 'StrainNomenclature'],
    '0x0214': ['LO', '1', 'StrainStockNumber'],
    '0x0215': ['SQ', '1', 'StrainSourceRegistryCodeSequence'],
    '0x0216': ['SQ', '1', 'StrainStockSequence'],
    '0x0217': ['LO', '1', 'StrainSource'],
    '0x0218': ['UT', '1', 'StrainAdditionalInformation'],
    '0x0219': ['SQ', '1', 'StrainCodeSequence'],
    '0x0221': ['SQ', '1', 'GeneticModificationsSequence'],
    '0x0222': ['UC', '1', 'GeneticModificationsDescription'],
    '0x0223': ['LO', '1', 'GeneticModificationsNomenclature'],
    '0x0229': ['SQ', '1', 'GeneticModificationsCodeSequence'],
    '0x1000': ['LO', '1-n', 'OtherPatientIDs'],
    '0x1001': ['PN', '1-n', 'OtherPatientNames'],
    '0x1002': ['SQ', '1', 'OtherPatientIDsSequence'],
    '0x1005': ['PN', '1', 'PatientBirthName'],
    '0x1010': ['AS', '1', 'PatientAge'],
    '0x1020': ['DS', '1', 'PatientSize'],
    '0x1021': ['SQ', '1', 'PatientSizeCodeSequence'],
    '0x1022': ['DS', '1', 'PatientBodyMassIndex'],
    '0x1023': ['DS', '1', 'MeasuredAPDimension'],
    '0x1024': ['DS', '1', 'MeasuredLateralDimension'],
    '0x1030': ['DS', '1', 'PatientWeight'],
    '0x1040': ['LO', '1', 'PatientAddress'],
    '0x1050': ['LO', '1-n', 'InsurancePlanIdentification'],
    '0x1060': ['PN', '1', 'PatientMotherBirthName'],
    '0x1080': ['LO', '1', 'MilitaryRank'],
    '0x1081': ['LO', '1', 'BranchOfService'],
    '0x1090': ['LO', '1', 'MedicalRecordLocator'],
    '0x1100': ['SQ', '1', 'ReferencedPatientPhotoSequence'],
    '0x2000': ['LO', '1-n', 'MedicalAlerts'],
    '0x2110': ['LO', '1-n', 'Allergies'],
    '0x2150': ['LO', '1', 'CountryOfResidence'],
    '0x2152': ['LO', '1', 'RegionOfResidence'],
    '0x2154': ['SH', '1-n', 'PatientTelephoneNumbers'],
    '0x2155': ['LT', '1', 'PatientTelecomInformation'],
    '0x2160': ['SH', '1', 'EthnicGroup'],
    '0x2180': ['SH', '1', 'Occupation'],
    '0x21A0': ['CS', '1', 'SmokingStatus'],
    '0x21B0': ['LT', '1', 'AdditionalPatientHistory'],
    '0x21C0': ['US', '1', 'PregnancyStatus'],
    '0x21D0': ['DA', '1', 'LastMenstrualDate'],
    '0x21F0': ['LO', '1', 'PatientReligiousPreference'],
    '0x2201': ['LO', '1', 'PatientSpeciesDescription'],
    '0x2202': ['SQ', '1', 'PatientSpeciesCodeSequence'],
    '0x2203': ['CS', '1', 'PatientSexNeutered'],
    '0x2210': ['CS', '1', 'AnatomicalOrientationType'],
    '0x2292': ['LO', '1', 'PatientBreedDescription'],
    '0x2293': ['SQ', '1', 'PatientBreedCodeSequence'],
    '0x2294': ['SQ', '1', 'BreedRegistrationSequence'],
    '0x2295': ['LO', '1', 'BreedRegistrationNumber'],
    '0x2296': ['SQ', '1', 'BreedRegistryCodeSequence'],
    '0x2297': ['PN', '1', 'ResponsiblePerson'],
    '0x2298': ['CS', '1', 'ResponsiblePersonRole'],
    '0x2299': ['LO', '1', 'ResponsibleOrganization'],
    '0x4000': ['LT', '1', 'PatientComments'],
    '0x9431': ['FL', '1', 'ExaminedBodyThickness']
  },
  '0x0012': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0010': ['LO', '1', 'ClinicalTrialSponsorName'],
    '0x0020': ['LO', '1', 'ClinicalTrialProtocolID'],
    '0x0021': ['LO', '1', 'ClinicalTrialProtocolName'],
    '0x0030': ['LO', '1', 'ClinicalTrialSiteID'],
    '0x0031': ['LO', '1', 'ClinicalTrialSiteName'],
    '0x0040': ['LO', '1', 'ClinicalTrialSubjectID'],
    '0x0042': ['LO', '1', 'ClinicalTrialSubjectReadingID'],
    '0x0050': ['LO', '1', 'ClinicalTrialTimePointID'],
    '0x0051': ['ST', '1', 'ClinicalTrialTimePointDescription'],
    '0x0052': ['FD', '1', 'LongitudinalTemporalOffsetFromEvent'],
    '0x0053': ['CS', '1', 'LongitudinalTemporalEventType'],
    '0x0060': ['LO', '1', 'ClinicalTrialCoordinatingCenterName'],
    '0x0062': ['CS', '1', 'PatientIdentityRemoved'],
    '0x0063': ['LO', '1-n', 'DeidentificationMethod'],
    '0x0064': ['SQ', '1', 'DeidentificationMethodCodeSequence'],
    '0x0071': ['LO', '1', 'ClinicalTrialSeriesID'],
    '0x0072': ['LO', '1', 'ClinicalTrialSeriesDescription'],
    '0x0081': ['LO', '1', 'ClinicalTrialProtocolEthicsCommitteeName'],
    '0x0082': ['LO', '1', 'ClinicalTrialProtocolEthicsCommitteeApprovalNumber'],
    '0x0083': ['SQ', '1', 'ConsentForClinicalTrialUseSequence'],
    '0x0084': ['CS', '1', 'DistributionType'],
    '0x0085': ['CS', '1', 'ConsentForDistributionFlag'],
    '0x0086': ['DA', '1', 'EthicsCommitteeApprovalEffectivenessStartDate'],
    '0x0087': ['DA', '1', 'EthicsCommitteeApprovalEffectivenessEndDate']
  },
  '0x0014': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0023': ['ST', '1', 'CADFileFormat'],
    '0x0024': ['ST', '1', 'ComponentReferenceSystem'],
    '0x0025': ['ST', '1', 'ComponentManufacturingProcedure'],
    '0x0028': ['ST', '1', 'ComponentManufacturer'],
    '0x0030': ['DS', '1-n', 'MaterialThickness'],
    '0x0032': ['DS', '1-n', 'MaterialPipeDiameter'],
    '0x0034': ['DS', '1-n', 'MaterialIsolationDiameter'],
    '0x0042': ['ST', '1', 'MaterialGrade'],
    '0x0044': ['ST', '1', 'MaterialPropertiesDescription'],
    '0x0045': ['ST', '1', 'MaterialPropertiesFileFormatRetired'],
    '0x0046': ['LT', '1', 'MaterialNotes'],
    '0x0050': ['CS', '1', 'ComponentShape'],
    '0x0052': ['CS', '1', 'CurvatureType'],
    '0x0054': ['DS', '1', 'OuterDiameter'],
    '0x0056': ['DS', '1', 'InnerDiameter'],
    '0x0100': ['LO', '1-n', 'ComponentWelderIDs'],
    '0x0101': ['CS', '1', 'SecondaryApprovalStatus'],
    '0x0102': ['DA', '1', 'SecondaryReviewDate'],
    '0x0103': ['TM', '1', 'SecondaryReviewTime'],
    '0x0104': ['PN', '1', 'SecondaryReviewerName'],
    '0x0105': ['ST', '1', 'RepairID'],
    '0x0106': ['SQ', '1', 'MultipleComponentApprovalSequence'],
    '0x0107': ['CS', '1-n', 'OtherApprovalStatus'],
    '0x0108': ['CS', '1-n', 'OtherSecondaryApprovalStatus'],
    '0x1010': ['ST', '1', 'ActualEnvironmentalConditions'],
    '0x1020': ['DA', '1', 'ExpiryDate'],
    '0x1040': ['ST', '1', 'EnvironmentalConditions'],
    '0x2002': ['SQ', '1', 'EvaluatorSequence'],
    '0x2004': ['IS', '1', 'EvaluatorNumber'],
    '0x2006': ['PN', '1', 'EvaluatorName'],
    '0x2008': ['IS', '1', 'EvaluationAttempt'],
    '0x2012': ['SQ', '1', 'IndicationSequence'],
    '0x2014': ['IS', '1', 'IndicationNumber'],
    '0x2016': ['SH', '1', 'IndicationLabel'],
    '0x2018': ['ST', '1', 'IndicationDescription'],
    '0x201A': ['CS', '1-n', 'IndicationType'],
    '0x201C': ['CS', '1', 'IndicationDisposition'],
    '0x201E': ['SQ', '1', 'IndicationROISequence'],
    '0x2030': ['SQ', '1', 'IndicationPhysicalPropertySequence'],
    '0x2032': ['SH', '1', 'PropertyLabel'],
    '0x2202': ['IS', '1', 'CoordinateSystemNumberOfAxes'],
    '0x2204': ['SQ', '1', 'CoordinateSystemAxesSequence'],
    '0x2206': ['ST', '1', 'CoordinateSystemAxisDescription'],
    '0x2208': ['CS', '1', 'CoordinateSystemDataSetMapping'],
    '0x220A': ['IS', '1', 'CoordinateSystemAxisNumber'],
    '0x220C': ['CS', '1', 'CoordinateSystemAxisType'],
    '0x220E': ['CS', '1', 'CoordinateSystemAxisUnits'],
    '0x2210': ['OB', '1', 'CoordinateSystemAxisValues'],
    '0x2220': ['SQ', '1', 'CoordinateSystemTransformSequence'],
    '0x2222': ['ST', '1', 'TransformDescription'],
    '0x2224': ['IS', '1', 'TransformNumberOfAxes'],
    '0x2226': ['IS', '1-n', 'TransformOrderOfAxes'],
    '0x2228': ['CS', '1', 'TransformedAxisUnits'],
    '0x222A': ['DS', '1-n', 'CoordinateSystemTransformRotationAndScaleMatrix'],
    '0x222C': ['DS', '1-n', 'CoordinateSystemTransformTranslationMatrix'],
    '0x3011': ['DS', '1', 'InternalDetectorFrameTime'],
    '0x3012': ['DS', '1', 'NumberOfFramesIntegrated'],
    '0x3020': ['SQ', '1', 'DetectorTemperatureSequence'],
    '0x3022': ['ST', '1', 'SensorName'],
    '0x3024': ['DS', '1', 'HorizontalOffsetOfSensor'],
    '0x3026': ['DS', '1', 'VerticalOffsetOfSensor'],
    '0x3028': ['DS', '1', 'SensorTemperature'],
    '0x3040': ['SQ', '1', 'DarkCurrentSequence'],
    '0x3050': ['ox', '1', 'DarkCurrentCounts'],
    '0x3060': ['SQ', '1', 'GainCorrectionReferenceSequence'],
    '0x3070': ['ox', '1', 'AirCounts'],
    '0x3071': ['DS', '1', 'KVUsedInGainCalibration'],
    '0x3072': ['DS', '1', 'MAUsedInGainCalibration'],
    '0x3073': ['DS', '1', 'NumberOfFramesUsedForIntegration'],
    '0x3074': ['LO', '1', 'FilterMaterialUsedInGainCalibration'],
    '0x3075': ['DS', '1', 'FilterThicknessUsedInGainCalibration'],
    '0x3076': ['DA', '1', 'DateOfGainCalibration'],
    '0x3077': ['TM', '1', 'TimeOfGainCalibration'],
    '0x3080': ['OB', '1', 'BadPixelImage'],
    '0x3099': ['LT', '1', 'CalibrationNotes'],
    '0x3100': ['LT', '1', 'LinearityCorrectionTechnique'],
    '0x3101': ['LT', '1', 'BeamHardeningCorrectionTechnique'],
    '0x4002': ['SQ', '1', 'PulserEquipmentSequence'],
    '0x4004': ['CS', '1', 'PulserType'],
    '0x4006': ['LT', '1', 'PulserNotes'],
    '0x4008': ['SQ', '1', 'ReceiverEquipmentSequence'],
    '0x400A': ['CS', '1', 'AmplifierType'],
    '0x400C': ['LT', '1', 'ReceiverNotes'],
    '0x400E': ['SQ', '1', 'PreAmplifierEquipmentSequence'],
    '0x400F': ['LT', '1', 'PreAmplifierNotes'],
    '0x4010': ['SQ', '1', 'TransmitTransducerSequence'],
    '0x4011': ['SQ', '1', 'ReceiveTransducerSequence'],
    '0x4012': ['US', '1', 'NumberOfElements'],
    '0x4013': ['CS', '1', 'ElementShape'],
    '0x4014': ['DS', '1', 'ElementDimensionA'],
    '0x4015': ['DS', '1', 'ElementDimensionB'],
    '0x4016': ['DS', '1', 'ElementPitchA'],
    '0x4017': ['DS', '1', 'MeasuredBeamDimensionA'],
    '0x4018': ['DS', '1', 'MeasuredBeamDimensionB'],
    '0x4019': ['DS', '1', 'LocationOfMeasuredBeamDiameter'],
    '0x401A': ['DS', '1', 'NominalFrequency'],
    '0x401B': ['DS', '1', 'MeasuredCenterFrequency'],
    '0x401C': ['DS', '1', 'MeasuredBandwidth'],
    '0x401D': ['DS', '1', 'ElementPitchB'],
    '0x4020': ['SQ', '1', 'PulserSettingsSequence'],
    '0x4022': ['DS', '1', 'PulseWidth'],
    '0x4024': ['DS', '1', 'ExcitationFrequency'],
    '0x4026': ['CS', '1', 'ModulationType'],
    '0x4028': ['DS', '1', 'Damping'],
    '0x4030': ['SQ', '1', 'ReceiverSettingsSequence'],
    '0x4031': ['DS', '1', 'AcquiredSoundpathLength'],
    '0x4032': ['CS', '1', 'AcquisitionCompressionType'],
    '0x4033': ['IS', '1', 'AcquisitionSampleSize'],
    '0x4034': ['DS', '1', 'RectifierSmoothing'],
    '0x4035': ['SQ', '1', 'DACSequence'],
    '0x4036': ['CS', '1', 'DACType'],
    '0x4038': ['DS', '1-n', 'DACGainPoints'],
    '0x403A': ['DS', '1-n', 'DACTimePoints'],
    '0x403C': ['DS', '1-n', 'DACAmplitude'],
    '0x4040': ['SQ', '1', 'PreAmplifierSettingsSequence'],
    '0x4050': ['SQ', '1', 'TransmitTransducerSettingsSequence'],
    '0x4051': ['SQ', '1', 'ReceiveTransducerSettingsSequence'],
    '0x4052': ['DS', '1', 'IncidentAngle'],
    '0x4054': ['ST', '1', 'CouplingTechnique'],
    '0x4056': ['ST', '1', 'CouplingMedium'],
    '0x4057': ['DS', '1', 'CouplingVelocity'],
    '0x4058': ['DS', '1', 'ProbeCenterLocationX'],
    '0x4059': ['DS', '1', 'ProbeCenterLocationZ'],
    '0x405A': ['DS', '1', 'SoundPathLength'],
    '0x405C': ['ST', '1', 'DelayLawIdentifier'],
    '0x4060': ['SQ', '1', 'GateSettingsSequence'],
    '0x4062': ['DS', '1', 'GateThreshold'],
    '0x4064': ['DS', '1', 'VelocityOfSound'],
    '0x4070': ['SQ', '1', 'CalibrationSettingsSequence'],
    '0x4072': ['ST', '1', 'CalibrationProcedure'],
    '0x4074': ['SH', '1', 'ProcedureVersion'],
    '0x4076': ['DA', '1', 'ProcedureCreationDate'],
    '0x4078': ['DA', '1', 'ProcedureExpirationDate'],
    '0x407A': ['DA', '1', 'ProcedureLastModifiedDate'],
    '0x407C': ['TM', '1-n', 'CalibrationTime'],
    '0x407E': ['DA', '1-n', 'CalibrationDate'],
    '0x4080': ['SQ', '1', 'ProbeDriveEquipmentSequence'],
    '0x4081': ['CS', '1', 'DriveType'],
    '0x4082': ['LT', '1', 'ProbeDriveNotes'],
    '0x4083': ['SQ', '1', 'DriveProbeSequence'],
    '0x4084': ['DS', '1', 'ProbeInductance'],
    '0x4085': ['DS', '1', 'ProbeResistance'],
    '0x4086': ['SQ', '1', 'ReceiveProbeSequence'],
    '0x4087': ['SQ', '1', 'ProbeDriveSettingsSequence'],
    '0x4088': ['DS', '1', 'BridgeResistors'],
    '0x4089': ['DS', '1', 'ProbeOrientationAngle'],
    '0x408B': ['DS', '1', 'UserSelectedGainY'],
    '0x408C': ['DS', '1', 'UserSelectedPhase'],
    '0x408D': ['DS', '1', 'UserSelectedOffsetX'],
    '0x408E': ['DS', '1', 'UserSelectedOffsetY'],
    '0x4091': ['SQ', '1', 'ChannelSettingsSequence'],
    '0x4092': ['DS', '1', 'ChannelThreshold'],
    '0x409A': ['SQ', '1', 'ScannerSettingsSequence'],
    '0x409B': ['ST', '1', 'ScanProcedure'],
    '0x409C': ['DS', '1', 'TranslationRateX'],
    '0x409D': ['DS', '1', 'TranslationRateY'],
    '0x409F': ['DS', '1', 'ChannelOverlap'],
    '0x40A0': ['LO', '1-n', 'ImageQualityIndicatorType'],
    '0x40A1': ['LO', '1-n', 'ImageQualityIndicatorMaterial'],
    '0x40A2': ['LO', '1-n', 'ImageQualityIndicatorSize'],
    '0x5002': ['IS', '1', 'LINACEnergy'],
    '0x5004': ['IS', '1', 'LINACOutput'],
    '0x5100': ['US', '1', 'ActiveAperture'],
    '0x5101': ['DS', '1', 'TotalAperture'],
    '0x5102': ['DS', '1', 'ApertureElevation'],
    '0x5103': ['DS', '1', 'MainLobeAngle'],
    '0x5104': ['DS', '1', 'MainRoofAngle'],
    '0x5105': ['CS', '1', 'ConnectorType'],
    '0x5106': ['SH', '1', 'WedgeModelNumber'],
    '0x5107': ['DS', '1', 'WedgeAngleFloat'],
    '0x5108': ['DS', '1', 'WedgeRoofAngle'],
    '0x5109': ['CS', '1', 'WedgeElement1Position'],
    '0x510A': ['DS', '1', 'WedgeMaterialVelocity'],
    '0x510B': ['SH', '1', 'WedgeMaterial'],
    '0x510C': ['DS', '1', 'WedgeOffsetZ'],
    '0x510D': ['DS', '1', 'WedgeOriginOffsetX'],
    '0x510E': ['DS', '1', 'WedgeTimeDelay'],
    '0x510F': ['SH', '1', 'WedgeName'],
    '0x5110': ['SH', '1', 'WedgeManufacturerName'],
    '0x5111': ['LO', '1', 'WedgeDescription'],
    '0x5112': ['DS', '1', 'NominalBeamAngle'],
    '0x5113': ['DS', '1', 'WedgeOffsetX'],
    '0x5114': ['DS', '1', 'WedgeOffsetY'],
    '0x5115': ['DS', '1', 'WedgeTotalLength'],
    '0x5116': ['DS', '1', 'WedgeInContactLength'],
    '0x5117': ['DS', '1', 'WedgeFrontGap'],
    '0x5118': ['DS', '1', 'WedgeTotalHeight'],
    '0x5119': ['DS', '1', 'WedgeFrontHeight'],
    '0x511A': ['DS', '1', 'WedgeRearHeight'],
    '0x511B': ['DS', '1', 'WedgeTotalWidth'],
    '0x511C': ['DS', '1', 'WedgeInContactWidth'],
    '0x511D': ['DS', '1', 'WedgeChamferHeight'],
    '0x511E': ['CS', '1', 'WedgeCurve'],
    '0x511F': ['DS', '1', 'RadiusAlongWedge']
  },
  '0x0016': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0001': ['DS', '1', 'WhitePoint'],
    '0x0002': ['DS', '3', 'PrimaryChromaticities'],
    '0x0003': ['UT', '1', 'BatteryLevel'],
    '0x0004': ['DS', '1', 'ExposureTimeInSeconds'],
    '0x0005': ['DS', '1', 'FNumber'],
    '0x0006': ['IS', '1', 'OECFRows'],
    '0x0007': ['IS', '1', 'OECFColumns'],
    '0x0008': ['UC', '1-n', 'OECFColumnNames'],
    '0x0009': ['DS', '1-n', 'OECFValues'],
    '0x000A': ['IS', '1', 'SpatialFrequencyResponseRows'],
    '0x000B': ['IS', '1', 'SpatialFrequencyResponseColumns'],
    '0x000C': ['UC', '1-n', 'SpatialFrequencyResponseColumnNames'],
    '0x000D': ['DS', '1-n', 'SpatialFrequencyResponseValues'],
    '0x000E': ['IS', '1', 'ColorFilterArrayPatternRows'],
    '0x000F': ['IS', '1', 'ColorFilterArrayPatternColumns'],
    '0x0010': ['DS', '1-n', 'ColorFilterArrayPatternValues'],
    '0x0011': ['US', '1', 'FlashFiringStatus'],
    '0x0012': ['US', '1', 'FlashReturnStatus'],
    '0x0013': ['US', '1', 'FlashMode'],
    '0x0014': ['US', '1', 'FlashFunctionPresent'],
    '0x0015': ['US', '1', 'FlashRedEyeMode'],
    '0x0016': ['US', '1', 'ExposureProgram'],
    '0x0017': ['UT', '1', 'SpectralSensitivity'],
    '0x0018': ['IS', '1', 'PhotographicSensitivity'],
    '0x0019': ['IS', '1', 'SelfTimerMode'],
    '0x001A': ['US', '1', 'SensitivityType'],
    '0x001B': ['IS', '1', 'StandardOutputSensitivity'],
    '0x001C': ['IS', '1', 'RecommendedExposureIndex'],
    '0x001D': ['IS', '1', 'ISOSpeed'],
    '0x001E': ['IS', '1', 'ISOSpeedLatitudeyyy'],
    '0x001F': ['IS', '1', 'ISOSpeedLatitudezzz'],
    '0x0020': ['UT', '1', 'EXIFVersion'],
    '0x0021': ['DS', '1', 'ShutterSpeedValue'],
    '0x0022': ['DS', '1', 'ApertureValue'],
    '0x0023': ['DS', '1', 'BrightnessValue'],
    '0x0024': ['DS', '1', 'ExposureBiasValue'],
    '0x0025': ['DS', '1', 'MaxApertureValue'],
    '0x0026': ['DS', '1', 'SubjectDistance'],
    '0x0027': ['US', '1', 'MeteringMode'],
    '0x0028': ['US', '1', 'LightSource'],
    '0x0029': ['DS', '1', 'FocalLength'],
    '0x002A': ['IS', '2-4', 'SubjectArea'],
    '0x002B': ['OB', '1', 'MakerNote'],
    '0x0030': ['DS', '1', 'Temperature'],
    '0x0031': ['DS', '1', 'Humidity'],
    '0x0032': ['DS', '1', 'Pressure'],
    '0x0033': ['DS', '1', 'WaterDepth'],
    '0x0034': ['DS', '1', 'Acceleration'],
    '0x0035': ['DS', '1', 'CameraElevationAngle'],
    '0x0036': ['DS', '1-2', 'FlashEnergy'],
    '0x0037': ['IS', '2', 'SubjectLocation'],
    '0x0038': ['DS', '1', 'PhotographicExposureIndex'],
    '0x0039': ['US', '1', 'SensingMethod'],
    '0x003A': ['US', '1', 'FileSource'],
    '0x003B': ['US', '1', 'SceneType'],
    '0x0041': ['US', '1', 'CustomRendered'],
    '0x0042': ['US', '1', 'ExposureMode'],
    '0x0043': ['US', '1', 'WhiteBalance'],
    '0x0044': ['DS', '1', 'DigitalZoomRatio'],
    '0x0045': ['IS', '1', 'FocalLengthIn35mmFilm'],
    '0x0046': ['US', '1', 'SceneCaptureType'],
    '0x0047': ['US', '1', 'GainControl'],
    '0x0048': ['US', '1', 'Contrast'],
    '0x0049': ['US', '1', 'Saturation'],
    '0x004A': ['US', '1', 'Sharpness'],
    '0x004B': ['OB', '1', 'DeviceSettingDescription'],
    '0x004C': ['US', '1', 'SubjectDistanceRange'],
    '0x004D': ['UT', '1', 'CameraOwnerName'],
    '0x004E': ['DS', '4', 'LensSpecification'],
    '0x004F': ['UT', '1', 'LensMake'],
    '0x0050': ['UT', '1', 'LensModel'],
    '0x0051': ['UT', '1', 'LensSerialNumber'],
    '0x0061': ['CS', '1', 'InteroperabilityIndex'],
    '0x0062': ['OB', '1', 'InteroperabilityVersion'],
    '0x0070': ['OB', '1', 'GPSVersionID'],
    '0x0071': ['CS', '1', 'GPSLatitudeRef'],
    '0x0072': ['DS', '3', 'GPSLatitude'],
    '0x0073': ['CS', '1', 'GPSLongitudeRef'],
    '0x0074': ['DS', '3', 'GPSLongitude'],
    '0x0075': ['US', '1', 'GPSAltitudeRef'],
    '0x0076': ['DS', '1', 'GPSAltitude'],
    '0x0077': ['DT', '1', 'GPSTimeStamp'],
    '0x0078': ['UT', '1', 'GPSSatellites'],
    '0x0079': ['CS', '1', 'GPSStatus'],
    '0x007A': ['CS', '1', 'GPSMeasureMode'],
    '0x007B': ['DS', '1', 'GPSDOP'],
    '0x007C': ['CS', '1', 'GPSSpeedRef'],
    '0x007D': ['DS', '1', 'GPSSpeed'],
    '0x007E': ['CS', '1', 'GPSTrackRef'],
    '0x007F': ['DS', '1', 'GPSTrack'],
    '0x0080': ['CS', '1', 'GPSImgDirectionRef'],
    '0x0081': ['DS', '1', 'GPSImgDirection'],
    '0x0082': ['UT', '1', 'GPSMapDatum'],
    '0x0083': ['CS', '1', 'GPSDestLatitudeRef'],
    '0x0084': ['DS', '3', 'GPSDestLatitude'],
    '0x0085': ['CS', '1', 'GPSDestLongitudeRef'],
    '0x0086': ['DS', '3', 'GPSDestLongitude'],
    '0x0087': ['CS', '1', 'GPSDestBearingRef'],
    '0x0088': ['DS', '1', 'GPSDestBearing'],
    '0x0089': ['CS', '1', 'GPSDestDistanceRef'],
    '0x008A': ['DS', '1', 'GPSDestDistance'],
    '0x008B': ['OB', '1', 'GPSProcessingMethod'],
    '0x008C': ['OB', '1', 'GPSAreaInformation'],
    '0x008D': ['DT', '1', 'GPSDateStamp'],
    '0x008E': ['IS', '1', 'GPSDifferential'],
    '0x1001': ['CS', '1', 'LightSourcePolarization'],
    '0x1002': ['DS', '1', 'EmitterColorTemperature'],
    '0x1003': ['CS', '1', 'ContactMethod'],
    '0x1004': ['CS', '1-n', 'ImmersionMedia'],
    '0x1005': ['DS', '1', 'OpticalMagnificationFactor']
  },
  '0x0018': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0010': ['LO', '1', 'ContrastBolusAgent'],
    '0x0012': ['SQ', '1', 'ContrastBolusAgentSequence'],
    '0x0013': ['FL', '1', 'ContrastBolusT1Relaxivity'],
    '0x0014': ['SQ', '1', 'ContrastBolusAdministrationRouteSequence'],
    '0x0015': ['CS', '1', 'BodyPartExamined'],
    '0x0020': ['CS', '1-n', 'ScanningSequence'],
    '0x0021': ['CS', '1-n', 'SequenceVariant'],
    '0x0022': ['CS', '1-n', 'ScanOptions'],
    '0x0023': ['CS', '1', 'MRAcquisitionType'],
    '0x0024': ['SH', '1', 'SequenceName'],
    '0x0025': ['CS', '1', 'AngioFlag'],
    '0x0026': ['SQ', '1', 'InterventionDrugInformationSequence'],
    '0x0027': ['TM', '1', 'InterventionDrugStopTime'],
    '0x0028': ['DS', '1', 'InterventionDrugDose'],
    '0x0029': ['SQ', '1', 'InterventionDrugCodeSequence'],
    '0x002A': ['SQ', '1', 'AdditionalDrugSequence'],
    '0x0030': ['LO', '1-n', 'Radionuclide'],
    '0x0031': ['LO', '1', 'Radiopharmaceutical'],
    '0x0032': ['DS', '1', 'EnergyWindowCenterline'],
    '0x0033': ['DS', '1-n', 'EnergyWindowTotalWidth'],
    '0x0034': ['LO', '1', 'InterventionDrugName'],
    '0x0035': ['TM', '1', 'InterventionDrugStartTime'],
    '0x0036': ['SQ', '1', 'InterventionSequence'],
    '0x0037': ['CS', '1', 'TherapyType'],
    '0x0038': ['CS', '1', 'InterventionStatus'],
    '0x0039': ['CS', '1', 'TherapyDescription'],
    '0x003A': ['ST', '1', 'InterventionDescription'],
    '0x0040': ['IS', '1', 'CineRate'],
    '0x0042': ['CS', '1', 'InitialCineRunState'],
    '0x0050': ['DS', '1', 'SliceThickness'],
    '0x0060': ['DS', '1', 'KVP'],
    '0x0061': ['DS', '1', ''],
    '0x0070': ['IS', '1', 'CountsAccumulated'],
    '0x0071': ['CS', '1', 'AcquisitionTerminationCondition'],
    '0x0072': ['DS', '1', 'EffectiveDuration'],
    '0x0073': ['CS', '1', 'AcquisitionStartCondition'],
    '0x0074': ['IS', '1', 'AcquisitionStartConditionData'],
    '0x0075': ['IS', '1', 'AcquisitionTerminationConditionData'],
    '0x0080': ['DS', '1', 'RepetitionTime'],
    '0x0081': ['DS', '1', 'EchoTime'],
    '0x0082': ['DS', '1', 'InversionTime'],
    '0x0083': ['DS', '1', 'NumberOfAverages'],
    '0x0084': ['DS', '1', 'ImagingFrequency'],
    '0x0085': ['SH', '1', 'ImagedNucleus'],
    '0x0086': ['IS', '1-n', 'EchoNumbers'],
    '0x0087': ['DS', '1', 'MagneticFieldStrength'],
    '0x0088': ['DS', '1', 'SpacingBetweenSlices'],
    '0x0089': ['IS', '1', 'NumberOfPhaseEncodingSteps'],
    '0x0090': ['DS', '1', 'DataCollectionDiameter'],
    '0x0091': ['IS', '1', 'EchoTrainLength'],
    '0x0093': ['DS', '1', 'PercentSampling'],
    '0x0094': ['DS', '1', 'PercentPhaseFieldOfView'],
    '0x0095': ['DS', '1', 'PixelBandwidth'],
    '0x1000': ['LO', '1', 'DeviceSerialNumber'],
    '0x1002': ['UI', '1', 'DeviceUID'],
    '0x1003': ['LO', '1', 'DeviceID'],
    '0x1004': ['LO', '1', 'PlateID'],
    '0x1005': ['LO', '1', 'GeneratorID'],
    '0x1006': ['LO', '1', 'GridID'],
    '0x1007': ['LO', '1', 'CassetteID'],
    '0x1008': ['LO', '1', 'GantryID'],
    '0x1009': ['UT', '1', 'UniqueDeviceIdentifier'],
    '0x100A': ['SQ', '1', 'UDISequence'],
    '0x100B': ['UI', '1-n', 'ManufacturerDeviceClassUID'],
    '0x1010': ['LO', '1', 'SecondaryCaptureDeviceID'],
    '0x1011': ['LO', '1', 'HardcopyCreationDeviceID'],
    '0x1012': ['DA', '1', 'DateOfSecondaryCapture'],
    '0x1014': ['TM', '1', 'TimeOfSecondaryCapture'],
    '0x1016': ['LO', '1', 'SecondaryCaptureDeviceManufacturer'],
    '0x1017': ['LO', '1', 'HardcopyDeviceManufacturer'],
    '0x1018': ['LO', '1', 'SecondaryCaptureDeviceManufacturerModelName'],
    '0x1019': ['LO', '1-n', 'SecondaryCaptureDeviceSoftwareVersions'],
    '0x101A': ['LO', '1-n', 'HardcopyDeviceSoftwareVersion'],
    '0x101B': ['LO', '1', 'HardcopyDeviceManufacturerModelName'],
    '0x1020': ['LO', '1-n', 'SoftwareVersions'],
    '0x1022': ['SH', '1', 'VideoImageFormatAcquired'],
    '0x1023': ['LO', '1', 'DigitalImageFormatAcquired'],
    '0x1030': ['LO', '1', 'ProtocolName'],
    '0x1040': ['LO', '1', 'ContrastBolusRoute'],
    '0x1041': ['DS', '1', 'ContrastBolusVolume'],
    '0x1042': ['TM', '1', 'ContrastBolusStartTime'],
    '0x1043': ['TM', '1', 'ContrastBolusStopTime'],
    '0x1044': ['DS', '1', 'ContrastBolusTotalDose'],
    '0x1045': ['IS', '1', 'SyringeCounts'],
    '0x1046': ['DS', '1-n', 'ContrastFlowRate'],
    '0x1047': ['DS', '1-n', 'ContrastFlowDuration'],
    '0x1048': ['CS', '1', 'ContrastBolusIngredient'],
    '0x1049': ['DS', '1', 'ContrastBolusIngredientConcentration'],
    '0x1050': ['DS', '1', 'SpatialResolution'],
    '0x1060': ['DS', '1', 'TriggerTime'],
    '0x1061': ['LO', '1', 'TriggerSourceOrType'],
    '0x1062': ['IS', '1', 'NominalInterval'],
    '0x1063': ['DS', '1', 'FrameTime'],
    '0x1064': ['LO', '1', 'CardiacFramingType'],
    '0x1065': ['DS', '1-n', 'FrameTimeVector'],
    '0x1066': ['DS', '1', 'FrameDelay'],
    '0x1067': ['DS', '1', 'ImageTriggerDelay'],
    '0x1068': ['DS', '1', 'MultiplexGroupTimeOffset'],
    '0x1069': ['DS', '1', 'TriggerTimeOffset'],
    '0x106A': ['CS', '1', 'SynchronizationTrigger'],
    '0x106C': ['US', '2', 'SynchronizationChannel'],
    '0x106E': ['UL', '1', 'TriggerSamplePosition'],
    '0x1070': ['LO', '1', 'RadiopharmaceuticalRoute'],
    '0x1071': ['DS', '1', 'RadiopharmaceuticalVolume'],
    '0x1072': ['TM', '1', 'RadiopharmaceuticalStartTime'],
    '0x1073': ['TM', '1', 'RadiopharmaceuticalStopTime'],
    '0x1074': ['DS', '1', 'RadionuclideTotalDose'],
    '0x1075': ['DS', '1', 'RadionuclideHalfLife'],
    '0x1076': ['DS', '1', 'RadionuclidePositronFraction'],
    '0x1077': ['DS', '1', 'RadiopharmaceuticalSpecificActivity'],
    '0x1078': ['DT', '1', 'RadiopharmaceuticalStartDateTime'],
    '0x1079': ['DT', '1', 'RadiopharmaceuticalStopDateTime'],
    '0x1080': ['CS', '1', 'BeatRejectionFlag'],
    '0x1081': ['IS', '1', 'LowRRValue'],
    '0x1082': ['IS', '1', 'HighRRValue'],
    '0x1083': ['IS', '1', 'IntervalsAcquired'],
    '0x1084': ['IS', '1', 'IntervalsRejected'],
    '0x1085': ['LO', '1', 'PVCRejection'],
    '0x1086': ['IS', '1', 'SkipBeats'],
    '0x1088': ['IS', '1', 'HeartRate'],
    '0x1090': ['IS', '1', 'CardiacNumberOfImages'],
    '0x1094': ['IS', '1', 'TriggerWindow'],
    '0x1100': ['DS', '1', 'ReconstructionDiameter'],
    '0x1110': ['DS', '1', 'DistanceSourceToDetector'],
    '0x1111': ['DS', '1', 'DistanceSourceToPatient'],
    '0x1114': ['DS', '1', 'EstimatedRadiographicMagnificationFactor'],
    '0x1120': ['DS', '1', 'GantryDetectorTilt'],
    '0x1121': ['DS', '1', 'GantryDetectorSlew'],
    '0x1130': ['DS', '1', 'TableHeight'],
    '0x1131': ['DS', '1', 'TableTraverse'],
    '0x1134': ['CS', '1', 'TableMotion'],
    '0x1135': ['DS', '1-n', 'TableVerticalIncrement'],
    '0x1136': ['DS', '1-n', 'TableLateralIncrement'],
    '0x1137': ['DS', '1-n', 'TableLongitudinalIncrement'],
    '0x1138': ['DS', '1', 'TableAngle'],
    '0x113A': ['CS', '1', 'TableType'],
    '0x1140': ['CS', '1', 'RotationDirection'],
    '0x1141': ['DS', '1', 'AngularPosition'],
    '0x1142': ['DS', '1-n', 'RadialPosition'],
    '0x1143': ['DS', '1', 'ScanArc'],
    '0x1144': ['DS', '1', 'AngularStep'],
    '0x1145': ['DS', '1', 'CenterOfRotationOffset'],
    '0x1146': ['DS', '1-n', 'RotationOffset'],
    '0x1147': ['CS', '1', 'FieldOfViewShape'],
    '0x1149': ['IS', '1-2', 'FieldOfViewDimensions'],
    '0x1150': ['IS', '1', 'ExposureTime'],
    '0x1151': ['IS', '1', 'XRayTubeCurrent'],
    '0x1152': ['IS', '1', 'Exposure'],
    '0x1153': ['IS', '1', 'ExposureInuAs'],
    '0x1154': ['DS', '1', 'AveragePulseWidth'],
    '0x1155': ['CS', '1', 'RadiationSetting'],
    '0x1156': ['CS', '1', 'RectificationType'],
    '0x115A': ['CS', '1', 'RadiationMode'],
    '0x115E': ['DS', '1', 'ImageAndFluoroscopyAreaDoseProduct'],
    '0x1160': ['SH', '1', 'FilterType'],
    '0x1161': ['LO', '1-n', 'TypeOfFilters'],
    '0x1162': ['DS', '1', 'IntensifierSize'],
    '0x1164': ['DS', '2', 'ImagerPixelSpacing'],
    '0x1166': ['CS', '1-n', 'Grid'],
    '0x1170': ['IS', '1', 'GeneratorPower'],
    '0x1180': ['SH', '1', 'CollimatorGridName'],
    '0x1181': ['CS', '1', 'CollimatorType'],
    '0x1182': ['IS', '1-2', 'FocalDistance'],
    '0x1183': ['DS', '1-2', 'XFocusCenter'],
    '0x1184': ['DS', '1-2', 'YFocusCenter'],
    '0x1190': ['DS', '1-n', 'FocalSpots'],
    '0x1191': ['CS', '1', 'AnodeTargetMaterial'],
    '0x11A0': ['DS', '1', 'BodyPartThickness'],
    '0x11A2': ['DS', '1', 'CompressionForce'],
    '0x11A3': ['DS', '1', 'CompressionPressure'],
    '0x11A4': ['LO', '1', 'PaddleDescription'],
    '0x11A5': ['DS', '1', 'CompressionContactArea'],
    '0x11B0': ['LO', '1', 'AcquisitionMode'],
    '0x11B1': ['LO', '1', 'DoseModeName'],
    '0x11B2': ['CS', '1', 'AcquiredSubtractionMaskFlag'],
    '0x11B3': ['CS', '1', 'FluoroscopyPersistenceFlag'],
    '0x11B4': ['CS', '1', 'FluoroscopyLastImageHoldPersistenceFlag'],
    '0x11B5': ['IS', '1', 'UpperLimitNumberOfPersistentFluoroscopyFrames'],
    '0x11B6': ['CS', '1', 'ContrastBolusAutoInjectionTriggerFlag'],
    '0x11B7': ['FD', '1', 'ContrastBolusInjectionDelay'],
    '0x11B8': ['SQ', '1', 'XAAcquisitionPhaseDetailsSequence'],
    '0x11B9': ['FD', '1', 'XAAcquisitionFrameRate'],
    '0x11BA': ['SQ', '1', 'XAPlaneDetailsSequence'],
    '0x11BB': ['LO', '1', 'AcquisitionFieldOfViewLabel'],
    '0x11BC': ['SQ', '1', 'XRayFilterDetailsSequence'],
    '0x11BD': ['FD', '1', 'XAAcquisitionDuration'],
    '0x11BE': ['CS', '1', 'ReconstructionPipelineType'],
    '0x11BF': ['SQ', '1', 'ImageFilterDetailsSequence'],
    '0x11C0': ['CS', '1', 'AppliedMaskSubtractionFlag'],
    '0x11C1': ['SQ', '1', 'RequestedSeriesDescriptionCodeSequence'],
    '0x1200': ['DA', '1-n', 'DateOfLastCalibration'],
    '0x1201': ['TM', '1-n', 'TimeOfLastCalibration'],
    '0x1202': ['DT', '1', 'DateTimeOfLastCalibration'],
    '0x1203': ['DT', '1', 'CalibrationDateTime'],
    '0x1210': ['SH', '1-n', 'ConvolutionKernel'],
    '0x1240': ['IS', '1-n', 'UpperLowerPixelValues'],
    '0x1242': ['IS', '1', 'ActualFrameDuration'],
    '0x1243': ['IS', '1', 'CountRate'],
    '0x1244': ['US', '1', 'PreferredPlaybackSequencing'],
    '0x1250': ['SH', '1', 'ReceiveCoilName'],
    '0x1251': ['SH', '1', 'TransmitCoilName'],
    '0x1260': ['SH', '1', 'PlateType'],
    '0x1261': ['LO', '1', 'PhosphorType'],
    '0x1271': ['FD', '1', 'WaterEquivalentDiameter'],
    '0x1272': ['SQ', '1', 'WaterEquivalentDiameterCalculationMethodCodeSequence'],
    '0x1300': ['DS', '1', 'ScanVelocity'],
    '0x1301': ['CS', '1-n', 'WholeBodyTechnique'],
    '0x1302': ['IS', '1', 'ScanLength'],
    '0x1310': ['US', '4', 'AcquisitionMatrix'],
    '0x1312': ['CS', '1', 'InPlanePhaseEncodingDirection'],
    '0x1314': ['DS', '1', 'FlipAngle'],
    '0x1315': ['CS', '1', 'VariableFlipAngleFlag'],
    '0x1316': ['DS', '1', 'SAR'],
    '0x1318': ['DS', '1', 'dBdt'],
    '0x1320': ['FL', '1', 'B1rms'],
    '0x1400': ['LO', '1', 'AcquisitionDeviceProcessingDescription'],
    '0x1401': ['LO', '1', 'AcquisitionDeviceProcessingCode'],
    '0x1402': ['CS', '1', 'CassetteOrientation'],
    '0x1403': ['CS', '1', 'CassetteSize'],
    '0x1404': ['US', '1', 'ExposuresOnPlate'],
    '0x1405': ['IS', '1', 'RelativeXRayExposure'],
    '0x1411': ['DS', '1', 'ExposureIndex'],
    '0x1412': ['DS', '1', 'TargetExposureIndex'],
    '0x1413': ['DS', '1', 'DeviationIndex'],
    '0x1450': ['DS', '1', 'ColumnAngulation'],
    '0x1460': ['DS', '1', 'TomoLayerHeight'],
    '0x1470': ['DS', '1', 'TomoAngle'],
    '0x1480': ['DS', '1', 'TomoTime'],
    '0x1490': ['CS', '1', 'TomoType'],
    '0x1491': ['CS', '1', 'TomoClass'],
    '0x1495': ['IS', '1', 'NumberOfTomosynthesisSourceImages'],
    '0x1500': ['CS', '1', 'PositionerMotion'],
    '0x1508': ['CS', '1', 'PositionerType'],
    '0x1510': ['DS', '1', 'PositionerPrimaryAngle'],
    '0x1511': ['DS', '1', 'PositionerSecondaryAngle'],
    '0x1520': ['DS', '1-n', 'PositionerPrimaryAngleIncrement'],
    '0x1521': ['DS', '1-n', 'PositionerSecondaryAngleIncrement'],
    '0x1530': ['DS', '1', 'DetectorPrimaryAngle'],
    '0x1531': ['DS', '1', 'DetectorSecondaryAngle'],
    '0x1600': ['CS', '1-3', 'ShutterShape'],
    '0x1602': ['IS', '1', 'ShutterLeftVerticalEdge'],
    '0x1604': ['IS', '1', 'ShutterRightVerticalEdge'],
    '0x1606': ['IS', '1', 'ShutterUpperHorizontalEdge'],
    '0x1608': ['IS', '1', 'ShutterLowerHorizontalEdge'],
    '0x1610': ['IS', '2', 'CenterOfCircularShutter'],
    '0x1612': ['IS', '1', 'RadiusOfCircularShutter'],
    '0x1620': ['IS', '2-2n', 'VerticesOfThePolygonalShutter'],
    '0x1622': ['US', '1', 'ShutterPresentationValue'],
    '0x1623': ['US', '1', 'ShutterOverlayGroup'],
    '0x1624': ['US', '3', 'ShutterPresentationColorCIELabValue'],
    '0x1630': ['CS', '1', 'OutlineShapeType'],
    '0x1631': ['FD', '1', 'OutlineLeftVerticalEdge'],
    '0x1632': ['FD', '1', 'OutlineRightVerticalEdge'],
    '0x1633': ['FD', '1', 'OutlineUpperHorizontalEdge'],
    '0x1634': ['FD', '1', 'OutlineLowerHorizontalEdge'],
    '0x1635': ['FD', '2', 'CenterOfCircularOutline'],
    '0x1636': ['FD', '1', 'DiameterOfCircularOutline'],
    '0x1637': ['UL', '1', 'NumberOfPolygonalVertices'],
    '0x1638': ['OF', '1', 'VerticesOfThePolygonalOutline'],
    '0x1700': ['CS', '1-3', 'CollimatorShape'],
    '0x1702': ['IS', '1', 'CollimatorLeftVerticalEdge'],
    '0x1704': ['IS', '1', 'CollimatorRightVerticalEdge'],
    '0x1706': ['IS', '1', 'CollimatorUpperHorizontalEdge'],
    '0x1708': ['IS', '1', 'CollimatorLowerHorizontalEdge'],
    '0x1710': ['IS', '2', 'CenterOfCircularCollimator'],
    '0x1712': ['IS', '1', 'RadiusOfCircularCollimator'],
    '0x1720': ['IS', '2-2n', 'VerticesOfThePolygonalCollimator'],
    '0x1800': ['CS', '1', 'AcquisitionTimeSynchronized'],
    '0x1801': ['SH', '1', 'TimeSource'],
    '0x1802': ['CS', '1', 'TimeDistributionProtocol'],
    '0x1803': ['LO', '1', 'NTPSourceAddress'],
    '0x2001': ['IS', '1-n', 'PageNumberVector'],
    '0x2002': ['SH', '1-n', 'FrameLabelVector'],
    '0x2003': ['DS', '1-n', 'FramePrimaryAngleVector'],
    '0x2004': ['DS', '1-n', 'FrameSecondaryAngleVector'],
    '0x2005': ['DS', '1-n', 'SliceLocationVector'],
    '0x2006': ['SH', '1-n', 'DisplayWindowLabelVector'],
    '0x2010': ['DS', '2', 'NominalScannedPixelSpacing'],
    '0x2020': ['CS', '1', 'DigitizingDeviceTransportDirection'],
    '0x2030': ['DS', '1', 'RotationOfScannedFilm'],
    '0x2041': ['SQ', '1', 'BiopsyTargetSequence'],
    '0x2042': ['UI', '1', 'TargetUID'],
    '0x2043': ['FL', '2', 'LocalizingCursorPosition'],
    '0x2044': ['FL', '3', 'CalculatedTargetPosition'],
    '0x2045': ['SH', '1', 'TargetLabel'],
    '0x2046': ['FL', '1', 'DisplayedZValue'],
    '0x3100': ['CS', '1', 'IVUSAcquisition'],
    '0x3101': ['DS', '1', 'IVUSPullbackRate'],
    '0x3102': ['DS', '1', 'IVUSGatedRate'],
    '0x3103': ['IS', '1', 'IVUSPullbackStartFrameNumber'],
    '0x3104': ['IS', '1', 'IVUSPullbackStopFrameNumber'],
    '0x3105': ['IS', '1-n', 'LesionNumber'],
    '0x4000': ['LT', '1', 'AcquisitionComments'],
    '0x5000': ['SH', '1-n', 'OutputPower'],
    '0x5010': ['LO', '1-n', 'TransducerData'],
    '0x5011': ['SQ', '1', 'TransducerIdentificationSequence'],
    '0x5012': ['DS', '1', 'FocusDepth'],
    '0x5020': ['LO', '1', 'ProcessingFunction'],
    '0x5021': ['LO', '1', 'PostprocessingFunction'],
    '0x5022': ['DS', '1', 'MechanicalIndex'],
    '0x5024': ['DS', '1', 'BoneThermalIndex'],
    '0x5026': ['DS', '1', 'CranialThermalIndex'],
    '0x5027': ['DS', '1', 'SoftTissueThermalIndex'],
    '0x5028': ['DS', '1', 'SoftTissueFocusThermalIndex'],
    '0x5029': ['DS', '1', 'SoftTissueSurfaceThermalIndex'],
    '0x5030': ['DS', '1', 'DynamicRange'],
    '0x5040': ['DS', '1', 'TotalGain'],
    '0x5050': ['IS', '1', 'DepthOfScanField'],
    '0x5100': ['CS', '1', 'PatientPosition'],
    '0x5101': ['CS', '1', 'ViewPosition'],
    '0x5104': ['SQ', '1', 'ProjectionEponymousNameCodeSequence'],
    '0x5210': ['DS', '6', 'ImageTransformationMatrix'],
    '0x5212': ['DS', '3', 'ImageTranslationVector'],
    '0x6000': ['DS', '1', 'Sensitivity'],
    '0x6011': ['SQ', '1', 'SequenceOfUltrasoundRegions'],
    '0x6012': ['US', '1', 'RegionSpatialFormat'],
    '0x6014': ['US', '1', 'RegionDataType'],
    '0x6016': ['UL', '1', 'RegionFlags'],
    '0x6018': ['UL', '1', 'RegionLocationMinX0'],
    '0x601A': ['UL', '1', 'RegionLocationMinY0'],
    '0x601C': ['UL', '1', 'RegionLocationMaxX1'],
    '0x601E': ['UL', '1', 'RegionLocationMaxY1'],
    '0x6020': ['SL', '1', 'ReferencePixelX0'],
    '0x6022': ['SL', '1', 'ReferencePixelY0'],
    '0x6024': ['US', '1', 'PhysicalUnitsXDirection'],
    '0x6026': ['US', '1', 'PhysicalUnitsYDirection'],
    '0x6028': ['FD', '1', 'ReferencePixelPhysicalValueX'],
    '0x602A': ['FD', '1', 'ReferencePixelPhysicalValueY'],
    '0x602C': ['FD', '1', 'PhysicalDeltaX'],
    '0x602E': ['FD', '1', 'PhysicalDeltaY'],
    '0x6030': ['UL', '1', 'TransducerFrequency'],
    '0x6031': ['CS', '1', 'TransducerType'],
    '0x6032': ['UL', '1', 'PulseRepetitionFrequency'],
    '0x6034': ['FD', '1', 'DopplerCorrectionAngle'],
    '0x6036': ['FD', '1', 'SteeringAngle'],
    '0x6038': ['UL', '1', 'DopplerSampleVolumeXPositionRetired'],
    '0x6039': ['SL', '1', 'DopplerSampleVolumeXPosition'],
    '0x603A': ['UL', '1', 'DopplerSampleVolumeYPositionRetired'],
    '0x603B': ['SL', '1', 'DopplerSampleVolumeYPosition'],
    '0x603C': ['UL', '1', 'TMLinePositionX0Retired'],
    '0x603D': ['SL', '1', 'TMLinePositionX0'],
    '0x603E': ['UL', '1', 'TMLinePositionY0Retired'],
    '0x603F': ['SL', '1', 'TMLinePositionY0'],
    '0x6040': ['UL', '1', 'TMLinePositionX1Retired'],
    '0x6041': ['SL', '1', 'TMLinePositionX1'],
    '0x6042': ['UL', '1', 'TMLinePositionY1Retired'],
    '0x6043': ['SL', '1', 'TMLinePositionY1'],
    '0x6044': ['US', '1', 'PixelComponentOrganization'],
    '0x6046': ['UL', '1', 'PixelComponentMask'],
    '0x6048': ['UL', '1', 'PixelComponentRangeStart'],
    '0x604A': ['UL', '1', 'PixelComponentRangeStop'],
    '0x604C': ['US', '1', 'PixelComponentPhysicalUnits'],
    '0x604E': ['US', '1', 'PixelComponentDataType'],
    '0x6050': ['UL', '1', 'NumberOfTableBreakPoints'],
    '0x6052': ['UL', '1-n', 'TableOfXBreakPoints'],
    '0x6054': ['FD', '1-n', 'TableOfYBreakPoints'],
    '0x6056': ['UL', '1', 'NumberOfTableEntries'],
    '0x6058': ['UL', '1-n', 'TableOfPixelValues'],
    '0x605A': ['FL', '1-n', 'TableOfParameterValues'],
    '0x6060': ['FL', '1-n', 'RWaveTimeVector'],
    '0x6070': ['US', '1', 'ActiveImageAreaOverlayGroup'],
    '0x7000': ['CS', '1', 'DetectorConditionsNominalFlag'],
    '0x7001': ['DS', '1', 'DetectorTemperature'],
    '0x7004': ['CS', '1', 'DetectorType'],
    '0x7005': ['CS', '1', 'DetectorConfiguration'],
    '0x7006': ['LT', '1', 'DetectorDescription'],
    '0x7008': ['LT', '1', 'DetectorMode'],
    '0x700A': ['SH', '1', 'DetectorID'],
    '0x700C': ['DA', '1', 'DateOfLastDetectorCalibration'],
    '0x700E': ['TM', '1', 'TimeOfLastDetectorCalibration'],
    '0x7010': ['IS', '1', 'ExposuresOnDetectorSinceLastCalibration'],
    '0x7011': ['IS', '1', 'ExposuresOnDetectorSinceManufactured'],
    '0x7012': ['DS', '1', 'DetectorTimeSinceLastExposure'],
    '0x7014': ['DS', '1', 'DetectorActiveTime'],
    '0x7016': ['DS', '1', 'DetectorActivationOffsetFromExposure'],
    '0x701A': ['DS', '2', 'DetectorBinning'],
    '0x7020': ['DS', '2', 'DetectorElementPhysicalSize'],
    '0x7022': ['DS', '2', 'DetectorElementSpacing'],
    '0x7024': ['CS', '1', 'DetectorActiveShape'],
    '0x7026': ['DS', '1-2', 'DetectorActiveDimensions'],
    '0x7028': ['DS', '2', 'DetectorActiveOrigin'],
    '0x702A': ['LO', '1', 'DetectorManufacturerName'],
    '0x702B': ['LO', '1', 'DetectorManufacturerModelName'],
    '0x7030': ['DS', '2', 'FieldOfViewOrigin'],
    '0x7032': ['DS', '1', 'FieldOfViewRotation'],
    '0x7034': ['CS', '1', 'FieldOfViewHorizontalFlip'],
    '0x7036': ['FL', '2', 'PixelDataAreaOriginRelativeToFOV'],
    '0x7038': ['FL', '1', 'PixelDataAreaRotationAngleRelativeToFOV'],
    '0x7040': ['LT', '1', 'GridAbsorbingMaterial'],
    '0x7041': ['LT', '1', 'GridSpacingMaterial'],
    '0x7042': ['DS', '1', 'GridThickness'],
    '0x7044': ['DS', '1', 'GridPitch'],
    '0x7046': ['IS', '2', 'GridAspectRatio'],
    '0x7048': ['DS', '1', 'GridPeriod'],
    '0x704C': ['DS', '1', 'GridFocalDistance'],
    '0x7050': ['CS', '1-n', 'FilterMaterial'],
    '0x7052': ['DS', '1-n', 'FilterThicknessMinimum'],
    '0x7054': ['DS', '1-n', 'FilterThicknessMaximum'],
    '0x7056': ['FL', '1-n', 'FilterBeamPathLengthMinimum'],
    '0x7058': ['FL', '1-n', 'FilterBeamPathLengthMaximum'],
    '0x7060': ['CS', '1', 'ExposureControlMode'],
    '0x7062': ['LT', '1', 'ExposureControlModeDescription'],
    '0x7064': ['CS', '1', 'ExposureStatus'],
    '0x7065': ['DS', '1', 'PhototimerSetting'],
    '0x8150': ['DS', '1', 'ExposureTimeInuS'],
    '0x8151': ['DS', '1', 'XRayTubeCurrentInuA'],
    '0x9004': ['CS', '1', 'ContentQualification'],
    '0x9005': ['SH', '1', 'PulseSequenceName'],
    '0x9006': ['SQ', '1', 'MRImagingModifierSequence'],
    '0x9008': ['CS', '1', 'EchoPulseSequence'],
    '0x9009': ['CS', '1', 'InversionRecovery'],
    '0x9010': ['CS', '1', 'FlowCompensation'],
    '0x9011': ['CS', '1', 'MultipleSpinEcho'],
    '0x9012': ['CS', '1', 'MultiPlanarExcitation'],
    '0x9014': ['CS', '1', 'PhaseContrast'],
    '0x9015': ['CS', '1', 'TimeOfFlightContrast'],
    '0x9016': ['CS', '1', 'Spoiling'],
    '0x9017': ['CS', '1', 'SteadyStatePulseSequence'],
    '0x9018': ['CS', '1', 'EchoPlanarPulseSequence'],
    '0x9019': ['FD', '1', 'TagAngleFirstAxis'],
    '0x9020': ['CS', '1', 'MagnetizationTransfer'],
    '0x9021': ['CS', '1', 'T2Preparation'],
    '0x9022': ['CS', '1', 'BloodSignalNulling'],
    '0x9024': ['CS', '1', 'SaturationRecovery'],
    '0x9025': ['CS', '1', 'SpectrallySelectedSuppression'],
    '0x9026': ['CS', '1', 'SpectrallySelectedExcitation'],
    '0x9027': ['CS', '1', 'SpatialPresaturation'],
    '0x9028': ['CS', '1', 'Tagging'],
    '0x9029': ['CS', '1', 'OversamplingPhase'],
    '0x9030': ['FD', '1', 'TagSpacingFirstDimension'],
    '0x9032': ['CS', '1', 'GeometryOfKSpaceTraversal'],
    '0x9033': ['CS', '1', 'SegmentedKSpaceTraversal'],
    '0x9034': ['CS', '1', 'RectilinearPhaseEncodeReordering'],
    '0x9035': ['FD', '1', 'TagThickness'],
    '0x9036': ['CS', '1', 'PartialFourierDirection'],
    '0x9037': ['CS', '1', 'CardiacSynchronizationTechnique'],
    '0x9041': ['LO', '1', 'ReceiveCoilManufacturerName'],
    '0x9042': ['SQ', '1', 'MRReceiveCoilSequence'],
    '0x9043': ['CS', '1', 'ReceiveCoilType'],
    '0x9044': ['CS', '1', 'QuadratureReceiveCoil'],
    '0x9045': ['SQ', '1', 'MultiCoilDefinitionSequence'],
    '0x9046': ['LO', '1', 'MultiCoilConfiguration'],
    '0x9047': ['SH', '1', 'MultiCoilElementName'],
    '0x9048': ['CS', '1', 'MultiCoilElementUsed'],
    '0x9049': ['SQ', '1', 'MRTransmitCoilSequence'],
    '0x9050': ['LO', '1', 'TransmitCoilManufacturerName'],
    '0x9051': ['CS', '1', 'TransmitCoilType'],
    '0x9052': ['FD', '1-2', 'SpectralWidth'],
    '0x9053': ['FD', '1-2', 'ChemicalShiftReference'],
    '0x9054': ['CS', '1', 'VolumeLocalizationTechnique'],
    '0x9058': ['US', '1', 'MRAcquisitionFrequencyEncodingSteps'],
    '0x9059': ['CS', '1', 'Decoupling'],
    '0x9060': ['CS', '1-2', 'DecoupledNucleus'],
    '0x9061': ['FD', '1-2', 'DecouplingFrequency'],
    '0x9062': ['CS', '1', 'DecouplingMethod'],
    '0x9063': ['FD', '1-2', 'DecouplingChemicalShiftReference'],
    '0x9064': ['CS', '1', 'KSpaceFiltering'],
    '0x9065': ['CS', '1-2', 'TimeDomainFiltering'],
    '0x9066': ['US', '1-2', 'NumberOfZeroFills'],
    '0x9067': ['CS', '1', 'BaselineCorrection'],
    '0x9069': ['FD', '1', 'ParallelReductionFactorInPlane'],
    '0x9070': ['FD', '1', 'CardiacRRIntervalSpecified'],
    '0x9073': ['FD', '1', 'AcquisitionDuration'],
    '0x9074': ['DT', '1', 'FrameAcquisitionDateTime'],
    '0x9075': ['CS', '1', 'DiffusionDirectionality'],
    '0x9076': ['SQ', '1', 'DiffusionGradientDirectionSequence'],
    '0x9077': ['CS', '1', 'ParallelAcquisition'],
    '0x9078': ['CS', '1', 'ParallelAcquisitionTechnique'],
    '0x9079': ['FD', '1-n', 'InversionTimes'],
    '0x9080': ['ST', '1', 'MetaboliteMapDescription'],
    '0x9081': ['CS', '1', 'PartialFourier'],
    '0x9082': ['FD', '1', 'EffectiveEchoTime'],
    '0x9083': ['SQ', '1', 'MetaboliteMapCodeSequence'],
    '0x9084': ['SQ', '1', 'ChemicalShiftSequence'],
    '0x9085': ['CS', '1', 'CardiacSignalSource'],
    '0x9087': ['FD', '1', 'DiffusionBValue'],
    '0x9089': ['FD', '3', 'DiffusionGradientOrientation'],
    '0x9090': ['FD', '3', 'VelocityEncodingDirection'],
    '0x9091': ['FD', '1', 'VelocityEncodingMinimumValue'],
    '0x9092': ['SQ', '1', 'VelocityEncodingAcquisitionSequence'],
    '0x9093': ['US', '1', 'NumberOfKSpaceTrajectories'],
    '0x9094': ['CS', '1', 'CoverageOfKSpace'],
    '0x9095': ['UL', '1', 'SpectroscopyAcquisitionPhaseRows'],
    '0x9096': ['FD', '1', 'ParallelReductionFactorInPlaneRetired'],
    '0x9098': ['FD', '1-2', 'TransmitterFrequency'],
    '0x9100': ['CS', '1-2', 'ResonantNucleus'],
    '0x9101': ['CS', '1', 'FrequencyCorrection'],
    '0x9103': ['SQ', '1', 'MRSpectroscopyFOVGeometrySequence'],
    '0x9104': ['FD', '1', 'SlabThickness'],
    '0x9105': ['FD', '3', 'SlabOrientation'],
    '0x9106': ['FD', '3', 'MidSlabPosition'],
    '0x9107': ['SQ', '1', 'MRSpatialSaturationSequence'],
    '0x9112': ['SQ', '1', 'MRTimingAndRelatedParametersSequence'],
    '0x9114': ['SQ', '1', 'MREchoSequence'],
    '0x9115': ['SQ', '1', 'MRModifierSequence'],
    '0x9117': ['SQ', '1', 'MRDiffusionSequence'],
    '0x9118': ['SQ', '1', 'CardiacSynchronizationSequence'],
    '0x9119': ['SQ', '1', 'MRAveragesSequence'],
    '0x9125': ['SQ', '1', 'MRFOVGeometrySequence'],
    '0x9126': ['SQ', '1', 'VolumeLocalizationSequence'],
    '0x9127': ['UL', '1', 'SpectroscopyAcquisitionDataColumns'],
    '0x9147': ['CS', '1', 'DiffusionAnisotropyType'],
    '0x9151': ['DT', '1', 'FrameReferenceDateTime'],
    '0x9152': ['SQ', '1', 'MRMetaboliteMapSequence'],
    '0x9155': ['FD', '1', 'ParallelReductionFactorOutOfPlane'],
    '0x9159': ['UL', '1', 'SpectroscopyAcquisitionOutOfPlanePhaseSteps'],
    '0x9166': ['CS', '1', 'BulkMotionStatus'],
    '0x9168': ['FD', '1', 'ParallelReductionFactorSecondInPlane'],
    '0x9169': ['CS', '1', 'CardiacBeatRejectionTechnique'],
    '0x9170': ['CS', '1', 'RespiratoryMotionCompensationTechnique'],
    '0x9171': ['CS', '1', 'RespiratorySignalSource'],
    '0x9172': ['CS', '1', 'BulkMotionCompensationTechnique'],
    '0x9173': ['CS', '1', 'BulkMotionSignalSource'],
    '0x9174': ['CS', '1', 'ApplicableSafetyStandardAgency'],
    '0x9175': ['LO', '1', 'ApplicableSafetyStandardDescription'],
    '0x9176': ['SQ', '1', 'OperatingModeSequence'],
    '0x9177': ['CS', '1', 'OperatingModeType'],
    '0x9178': ['CS', '1', 'OperatingMode'],
    '0x9179': ['CS', '1', 'SpecificAbsorptionRateDefinition'],
    '0x9180': ['CS', '1', 'GradientOutputType'],
    '0x9181': ['FD', '1', 'SpecificAbsorptionRateValue'],
    '0x9182': ['FD', '1', 'GradientOutput'],
    '0x9183': ['CS', '1', 'FlowCompensationDirection'],
    '0x9184': ['FD', '1', 'TaggingDelay'],
    '0x9185': ['ST', '1', 'RespiratoryMotionCompensationTechniqueDescription'],
    '0x9186': ['SH', '1', 'RespiratorySignalSourceID'],
    '0x9195': ['FD', '1', 'ChemicalShiftMinimumIntegrationLimitInHz'],
    '0x9196': ['FD', '1', 'ChemicalShiftMaximumIntegrationLimitInHz'],
    '0x9197': ['SQ', '1', 'MRVelocityEncodingSequence'],
    '0x9198': ['CS', '1', 'FirstOrderPhaseCorrection'],
    '0x9199': ['CS', '1', 'WaterReferencedPhaseCorrection'],
    '0x9200': ['CS', '1', 'MRSpectroscopyAcquisitionType'],
    '0x9214': ['CS', '1', 'RespiratoryCyclePosition'],
    '0x9217': ['FD', '1', 'VelocityEncodingMaximumValue'],
    '0x9218': ['FD', '1', 'TagSpacingSecondDimension'],
    '0x9219': ['SS', '1', 'TagAngleSecondAxis'],
    '0x9220': ['FD', '1', 'FrameAcquisitionDuration'],
    '0x9226': ['SQ', '1', 'MRImageFrameTypeSequence'],
    '0x9227': ['SQ', '1', 'MRSpectroscopyFrameTypeSequence'],
    '0x9231': ['US', '1', 'MRAcquisitionPhaseEncodingStepsInPlane'],
    '0x9232': ['US', '1', 'MRAcquisitionPhaseEncodingStepsOutOfPlane'],
    '0x9234': ['UL', '1', 'SpectroscopyAcquisitionPhaseColumns'],
    '0x9236': ['CS', '1', 'CardiacCyclePosition'],
    '0x9239': ['SQ', '1', 'SpecificAbsorptionRateSequence'],
    '0x9240': ['US', '1', 'RFEchoTrainLength'],
    '0x9241': ['US', '1', 'GradientEchoTrainLength'],
    '0x9250': ['CS', '1', 'ArterialSpinLabelingContrast'],
    '0x9251': ['SQ', '1', 'MRArterialSpinLabelingSequence'],
    '0x9252': ['LO', '1', 'ASLTechniqueDescription'],
    '0x9253': ['US', '1', 'ASLSlabNumber'],
    '0x9254': ['FD', '1', 'ASLSlabThickness'],
    '0x9255': ['FD', '3', 'ASLSlabOrientation'],
    '0x9256': ['FD', '3', 'ASLMidSlabPosition'],
    '0x9257': ['CS', '1', 'ASLContext'],
    '0x9258': ['UL', '1', 'ASLPulseTrainDuration'],
    '0x9259': ['CS', '1', 'ASLCrusherFlag'],
    '0x925A': ['FD', '1', 'ASLCrusherFlowLimit'],
    '0x925B': ['LO', '1', 'ASLCrusherDescription'],
    '0x925C': ['CS', '1', 'ASLBolusCutoffFlag'],
    '0x925D': ['SQ', '1', 'ASLBolusCutoffTimingSequence'],
    '0x925E': ['LO', '1', 'ASLBolusCutoffTechnique'],
    '0x925F': ['UL', '1', 'ASLBolusCutoffDelayTime'],
    '0x9260': ['SQ', '1', 'ASLSlabSequence'],
    '0x9295': ['FD', '1', 'ChemicalShiftMinimumIntegrationLimitInppm'],
    '0x9296': ['FD', '1', 'ChemicalShiftMaximumIntegrationLimitInppm'],
    '0x9297': ['CS', '1', 'WaterReferenceAcquisition'],
    '0x9298': ['IS', '1', 'EchoPeakPosition'],
    '0x9301': ['SQ', '1', 'CTAcquisitionTypeSequence'],
    '0x9302': ['CS', '1', 'AcquisitionType'],
    '0x9303': ['FD', '1', 'TubeAngle'],
    '0x9304': ['SQ', '1', 'CTAcquisitionDetailsSequence'],
    '0x9305': ['FD', '1', 'RevolutionTime'],
    '0x9306': ['FD', '1', 'SingleCollimationWidth'],
    '0x9307': ['FD', '1', 'TotalCollimationWidth'],
    '0x9308': ['SQ', '1', 'CTTableDynamicsSequence'],
    '0x9309': ['FD', '1', 'TableSpeed'],
    '0x9310': ['FD', '1', 'TableFeedPerRotation'],
    '0x9311': ['FD', '1', 'SpiralPitchFactor'],
    '0x9312': ['SQ', '1', 'CTGeometrySequence'],
    '0x9313': ['FD', '3', 'DataCollectionCenterPatient'],
    '0x9314': ['SQ', '1', 'CTReconstructionSequence'],
    '0x9315': ['CS', '1', 'ReconstructionAlgorithm'],
    '0x9316': ['CS', '1', 'ConvolutionKernelGroup'],
    '0x9317': ['FD', '2', 'ReconstructionFieldOfView'],
    '0x9318': ['FD', '3', 'ReconstructionTargetCenterPatient'],
    '0x9319': ['FD', '1', 'ReconstructionAngle'],
    '0x9320': ['SH', '1', 'ImageFilter'],
    '0x9321': ['SQ', '1', 'CTExposureSequence'],
    '0x9322': ['FD', '2', 'ReconstructionPixelSpacing'],
    '0x9323': ['CS', '1-n', 'ExposureModulationType'],
    '0x9324': ['FD', '1', 'EstimatedDoseSaving'],
    '0x9325': ['SQ', '1', 'CTXRayDetailsSequence'],
    '0x9326': ['SQ', '1', 'CTPositionSequence'],
    '0x9327': ['FD', '1', 'TablePosition'],
    '0x9328': ['FD', '1', 'ExposureTimeInms'],
    '0x9329': ['SQ', '1', 'CTImageFrameTypeSequence'],
    '0x9330': ['FD', '1', 'XRayTubeCurrentInmA'],
    '0x9332': ['FD', '1', 'ExposureInmAs'],
    '0x9333': ['CS', '1', 'ConstantVolumeFlag'],
    '0x9334': ['CS', '1', 'FluoroscopyFlag'],
    '0x9335': ['FD', '1', 'DistanceSourceToDataCollectionCenter'],
    '0x9337': ['US', '1', 'ContrastBolusAgentNumber'],
    '0x9338': ['SQ', '1', 'ContrastBolusIngredientCodeSequence'],
    '0x9340': ['SQ', '1', 'ContrastAdministrationProfileSequence'],
    '0x9341': ['SQ', '1', 'ContrastBolusUsageSequence'],
    '0x9342': ['CS', '1', 'ContrastBolusAgentAdministered'],
    '0x9343': ['CS', '1', 'ContrastBolusAgentDetected'],
    '0x9344': ['CS', '1', 'ContrastBolusAgentPhase'],
    '0x9345': ['FD', '1', 'CTDIvol'],
    '0x9346': ['SQ', '1', 'CTDIPhantomTypeCodeSequence'],
    '0x9351': ['FL', '1', 'CalciumScoringMassFactorPatient'],
    '0x9352': ['FL', '3', 'CalciumScoringMassFactorDevice'],
    '0x9353': ['FL', '1', 'EnergyWeightingFactor'],
    '0x9360': ['SQ', '1', 'CTAdditionalXRaySourceSequence'],
    '0x9361': ['CS', '1', 'MultienergyCTAcquisition'],
    '0x9362': ['SQ', '1', 'MultienergyCTAcquisitionSequence'],
    '0x9363': ['SQ', '1', 'MultienergyCTProcessingSequence'],
    '0x9364': ['SQ', '1', 'MultienergyCTCharacteristicsSequence'],
    '0x9365': ['SQ', '1', 'MultienergyCTXRaySourceSequence'],
    '0x9366': ['US', '1', 'XRaySourceIndex'],
    '0x9367': ['UC', '1', 'XRaySourceID'],
    '0x9368': ['CS', '1', 'MultienergySourceTechnique'],
    '0x9369': ['DT', '1', 'SourceStartDateTime'],
    '0x936A': ['DT', '1', 'SourceEndDateTime'],
    '0x936B': ['US', '1', 'SwitchingPhaseNumber'],
    '0x936C': ['DS', '1', 'SwitchingPhaseNominalDuration'],
    '0x936D': ['DS', '1', 'SwitchingPhaseTransitionDuration'],
    '0x936E': ['DS', '1', 'EffectiveBinEnergy'],
    '0x936F': ['SQ', '1', 'MultienergyCTXRayDetectorSequence'],
    '0x9370': ['US', '1', 'XRayDetectorIndex'],
    '0x9371': ['UC', '1', 'XRayDetectorID'],
    '0x9372': ['CS', '1', 'MultienergyDetectorType'],
    '0x9373': ['ST', '1', 'XRayDetectorLabel'],
    '0x9374': ['DS', '1', 'NominalMaxEnergy'],
    '0x9375': ['DS', '1', 'NominalMinEnergy'],
    '0x9376': ['US', '1-n', 'ReferencedXRayDetectorIndex'],
    '0x9377': ['US', '1-n', 'ReferencedXRaySourceIndex'],
    '0x9378': ['US', '1-n', 'ReferencedPathIndex'],
    '0x9379': ['SQ', '1', 'MultienergyCTPathSequence'],
    '0x937A': ['US', '1', 'MultienergyCTPathIndex'],
    '0x937B': ['UT', '1', 'MultienergyAcquisitionDescription'],
    '0x937C': ['FD', '1', 'MonoenergeticEnergyEquivalent'],
    '0x937D': ['SQ', '1', 'MaterialCodeSequence'],
    '0x937E': ['CS', '1', 'DecompositionMethod'],
    '0x937F': ['UT', '1', 'DecompositionDescription'],
    '0x9380': ['SQ', '1', 'DecompositionAlgorithmIdentificationSequence'],
    '0x9381': ['SQ', '1', 'DecompositionMaterialSequence'],
    '0x9382': ['SQ', '1', 'MaterialAttenuationSequence'],
    '0x9383': ['DS', '1', 'PhotonEnergy'],
    '0x9384': ['DS', '1', 'XRayMassAttenuationCoefficient'],
    '0x9401': ['SQ', '1', 'ProjectionPixelCalibrationSequence'],
    '0x9402': ['FL', '1', 'DistanceSourceToIsocenter'],
    '0x9403': ['FL', '1', 'DistanceObjectToTableTop'],
    '0x9404': ['FL', '2', 'ObjectPixelSpacingInCenterOfBeam'],
    '0x9405': ['SQ', '1', 'PositionerPositionSequence'],
    '0x9406': ['SQ', '1', 'TablePositionSequence'],
    '0x9407': ['SQ', '1', 'CollimatorShapeSequence'],
    '0x9410': ['CS', '1', 'PlanesInAcquisition'],
    '0x9412': ['SQ', '1', 'XAXRFFrameCharacteristicsSequence'],
    '0x9417': ['SQ', '1', 'FrameAcquisitionSequence'],
    '0x9420': ['CS', '1', 'XRayReceptorType'],
    '0x9423': ['LO', '1', 'AcquisitionProtocolName'],
    '0x9424': ['LT', '1', 'AcquisitionProtocolDescription'],
    '0x9425': ['CS', '1', 'ContrastBolusIngredientOpaque'],
    '0x9426': ['FL', '1', 'DistanceReceptorPlaneToDetectorHousing'],
    '0x9427': ['CS', '1', 'IntensifierActiveShape'],
    '0x9428': ['FL', '1-2', 'IntensifierActiveDimensions'],
    '0x9429': ['FL', '2', 'PhysicalDetectorSize'],
    '0x9430': ['FL', '2', 'PositionOfIsocenterProjection'],
    '0x9432': ['SQ', '1', 'FieldOfViewSequence'],
    '0x9433': ['LO', '1', 'FieldOfViewDescription'],
    '0x9434': ['SQ', '1', 'ExposureControlSensingRegionsSequence'],
    '0x9435': ['CS', '1', 'ExposureControlSensingRegionShape'],
    '0x9436': ['SS', '1', 'ExposureControlSensingRegionLeftVerticalEdge'],
    '0x9437': ['SS', '1', 'ExposureControlSensingRegionRightVerticalEdge'],
    '0x9438': ['SS', '1', 'ExposureControlSensingRegionUpperHorizontalEdge'],
    '0x9439': ['SS', '1', 'ExposureControlSensingRegionLowerHorizontalEdge'],
    '0x9440': ['SS', '2', 'CenterOfCircularExposureControlSensingRegion'],
    '0x9441': ['US', '1', 'RadiusOfCircularExposureControlSensingRegion'],
    '0x9442': ['SS', '2-n', 'VerticesOfThePolygonalExposureControlSensingRegion'],
    '0x9445': ['', '', ''],
    '0x9447': ['FL', '1', 'ColumnAngulationPatient'],
    '0x9449': ['FL', '1', 'BeamAngle'],
    '0x9451': ['SQ', '1', 'FrameDetectorParametersSequence'],
    '0x9452': ['FL', '1', 'CalculatedAnatomyThickness'],
    '0x9455': ['SQ', '1', 'CalibrationSequence'],
    '0x9456': ['SQ', '1', 'ObjectThicknessSequence'],
    '0x9457': ['CS', '1', 'PlaneIdentification'],
    '0x9461': ['FL', '1-2', 'FieldOfViewDimensionsInFloat'],
    '0x9462': ['SQ', '1', 'IsocenterReferenceSystemSequence'],
    '0x9463': ['FL', '1', 'PositionerIsocenterPrimaryAngle'],
    '0x9464': ['FL', '1', 'PositionerIsocenterSecondaryAngle'],
    '0x9465': ['FL', '1', 'PositionerIsocenterDetectorRotationAngle'],
    '0x9466': ['FL', '1', 'TableXPositionToIsocenter'],
    '0x9467': ['FL', '1', 'TableYPositionToIsocenter'],
    '0x9468': ['FL', '1', 'TableZPositionToIsocenter'],
    '0x9469': ['FL', '1', 'TableHorizontalRotationAngle'],
    '0x9470': ['FL', '1', 'TableHeadTiltAngle'],
    '0x9471': ['FL', '1', 'TableCradleTiltAngle'],
    '0x9472': ['SQ', '1', 'FrameDisplayShutterSequence'],
    '0x9473': ['FL', '1', 'AcquiredImageAreaDoseProduct'],
    '0x9474': ['CS', '1', 'CArmPositionerTabletopRelationship'],
    '0x9476': ['SQ', '1', 'XRayGeometrySequence'],
    '0x9477': ['SQ', '1', 'IrradiationEventIdentificationSequence'],
    '0x9504': ['SQ', '1', 'XRay3DFrameTypeSequence'],
    '0x9506': ['SQ', '1', 'ContributingSourcesSequence'],
    '0x9507': ['SQ', '1', 'XRay3DAcquisitionSequence'],
    '0x9508': ['FL', '1', 'PrimaryPositionerScanArc'],
    '0x9509': ['FL', '1', 'SecondaryPositionerScanArc'],
    '0x9510': ['FL', '1', 'PrimaryPositionerScanStartAngle'],
    '0x9511': ['FL', '1', 'SecondaryPositionerScanStartAngle'],
    '0x9514': ['FL', '1', 'PrimaryPositionerIncrement'],
    '0x9515': ['FL', '1', 'SecondaryPositionerIncrement'],
    '0x9516': ['DT', '1', 'StartAcquisitionDateTime'],
    '0x9517': ['DT', '1', 'EndAcquisitionDateTime'],
    '0x9518': ['SS', '1', 'PrimaryPositionerIncrementSign'],
    '0x9519': ['SS', '1', 'SecondaryPositionerIncrementSign'],
    '0x9524': ['LO', '1', 'ApplicationName'],
    '0x9525': ['LO', '1', 'ApplicationVersion'],
    '0x9526': ['LO', '1', 'ApplicationManufacturer'],
    '0x9527': ['CS', '1', 'AlgorithmType'],
    '0x9528': ['LO', '1', 'AlgorithmDescription'],
    '0x9530': ['SQ', '1', 'XRay3DReconstructionSequence'],
    '0x9531': ['LO', '1', 'ReconstructionDescription'],
    '0x9538': ['SQ', '1', 'PerProjectionAcquisitionSequence'],
    '0x9541': ['SQ', '1', 'DetectorPositionSequence'],
    '0x9542': ['SQ', '1', 'XRayAcquisitionDoseSequence'],
    '0x9543': ['FD', '1', 'XRaySourceIsocenterPrimaryAngle'],
    '0x9544': ['FD', '1', 'XRaySourceIsocenterSecondaryAngle'],
    '0x9545': ['FD', '1', 'BreastSupportIsocenterPrimaryAngle'],
    '0x9546': ['FD', '1', 'BreastSupportIsocenterSecondaryAngle'],
    '0x9547': ['FD', '1', 'BreastSupportXPositionToIsocenter'],
    '0x9548': ['FD', '1', 'BreastSupportYPositionToIsocenter'],
    '0x9549': ['FD', '1', 'BreastSupportZPositionToIsocenter'],
    '0x9550': ['FD', '1', 'DetectorIsocenterPrimaryAngle'],
    '0x9551': ['FD', '1', 'DetectorIsocenterSecondaryAngle'],
    '0x9552': ['FD', '1', 'DetectorXPositionToIsocenter'],
    '0x9553': ['FD', '1', 'DetectorYPositionToIsocenter'],
    '0x9554': ['FD', '1', 'DetectorZPositionToIsocenter'],
    '0x9555': ['SQ', '1', 'XRayGridSequence'],
    '0x9556': ['SQ', '1', 'XRayFilterSequence'],
    '0x9557': ['FD', '3', 'DetectorActiveAreaTLHCPosition'],
    '0x9558': ['FD', '6', 'DetectorActiveAreaOrientation'],
    '0x9559': ['CS', '1', 'PositionerPrimaryAngleDirection'],
    '0x9601': ['SQ', '1', 'DiffusionBMatrixSequence'],
    '0x9602': ['FD', '1', 'DiffusionBValueXX'],
    '0x9603': ['FD', '1', 'DiffusionBValueXY'],
    '0x9604': ['FD', '1', 'DiffusionBValueXZ'],
    '0x9605': ['FD', '1', 'DiffusionBValueYY'],
    '0x9606': ['FD', '1', 'DiffusionBValueYZ'],
    '0x9607': ['FD', '1', 'DiffusionBValueZZ'],
    '0x9621': ['SQ', '1', 'FunctionalMRSequence'],
    '0x9622': ['CS', '1', 'FunctionalSettlingPhaseFramesPresent'],
    '0x9623': ['DT', '1', 'FunctionalSyncPulse'],
    '0x9624': ['CS', '1', 'SettlingPhaseFrame'],
    '0x9701': ['DT', '1', 'DecayCorrectionDateTime'],
    '0x9715': ['FD', '1', 'StartDensityThreshold'],
    '0x9716': ['FD', '1', 'StartRelativeDensityDifferenceThreshold'],
    '0x9717': ['FD', '1', 'StartCardiacTriggerCountThreshold'],
    '0x9718': ['FD', '1', 'StartRespiratoryTriggerCountThreshold'],
    '0x9719': ['FD', '1', 'TerminationCountsThreshold'],
    '0x9720': ['FD', '1', 'TerminationDensityThreshold'],
    '0x9721': ['FD', '1', 'TerminationRelativeDensityThreshold'],
    '0x9722': ['FD', '1', 'TerminationTimeThreshold'],
    '0x9723': ['FD', '1', 'TerminationCardiacTriggerCountThreshold'],
    '0x9724': ['FD', '1', 'TerminationRespiratoryTriggerCountThreshold'],
    '0x9725': ['CS', '1', 'DetectorGeometry'],
    '0x9726': ['FD', '1', 'TransverseDetectorSeparation'],
    '0x9727': ['FD', '1', 'AxialDetectorDimension'],
    '0x9729': ['US', '1', 'RadiopharmaceuticalAgentNumber'],
    '0x9732': ['SQ', '1', 'PETFrameAcquisitionSequence'],
    '0x9733': ['SQ', '1', 'PETDetectorMotionDetailsSequence'],
    '0x9734': ['SQ', '1', 'PETTableDynamicsSequence'],
    '0x9735': ['SQ', '1', 'PETPositionSequence'],
    '0x9736': ['SQ', '1', 'PETFrameCorrectionFactorsSequence'],
    '0x9737': ['SQ', '1', 'RadiopharmaceuticalUsageSequence'],
    '0x9738': ['CS', '1', 'AttenuationCorrectionSource'],
    '0x9739': ['US', '1', 'NumberOfIterations'],
    '0x9740': ['US', '1', 'NumberOfSubsets'],
    '0x9749': ['SQ', '1', 'PETReconstructionSequence'],
    '0x9751': ['SQ', '1', 'PETFrameTypeSequence'],
    '0x9755': ['CS', '1', 'TimeOfFlightInformationUsed'],
    '0x9756': ['CS', '1', 'ReconstructionType'],
    '0x9758': ['CS', '1', 'DecayCorrected'],
    '0x9759': ['CS', '1', 'AttenuationCorrected'],
    '0x9760': ['CS', '1', 'ScatterCorrected'],
    '0x9761': ['CS', '1', 'DeadTimeCorrected'],
    '0x9762': ['CS', '1', 'GantryMotionCorrected'],
    '0x9763': ['CS', '1', 'PatientMotionCorrected'],
    '0x9764': ['CS', '1', 'CountLossNormalizationCorrected'],
    '0x9765': ['CS', '1', 'RandomsCorrected'],
    '0x9766': ['CS', '1', 'NonUniformRadialSamplingCorrected'],
    '0x9767': ['CS', '1', 'SensitivityCalibrated'],
    '0x9768': ['CS', '1', 'DetectorNormalizationCorrection'],
    '0x9769': ['CS', '1', 'IterativeReconstructionMethod'],
    '0x9770': ['CS', '1', 'AttenuationCorrectionTemporalRelationship'],
    '0x9771': ['SQ', '1', 'PatientPhysiologicalStateSequence'],
    '0x9772': ['SQ', '1', 'PatientPhysiologicalStateCodeSequence'],
    '0x9801': ['FD', '1-n', 'DepthsOfFocus'],
    '0x9803': ['SQ', '1', 'ExcludedIntervalsSequence'],
    '0x9804': ['DT', '1', 'ExclusionStartDateTime'],
    '0x9805': ['FD', '1', 'ExclusionDuration'],
    '0x9806': ['SQ', '1', 'USImageDescriptionSequence'],
    '0x9807': ['SQ', '1', 'ImageDataTypeSequence'],
    '0x9808': ['CS', '1', 'DataType'],
    '0x9809': ['SQ', '1', 'TransducerScanPatternCodeSequence'],
    '0x980B': ['CS', '1', 'AliasedDataType'],
    '0x980C': ['CS', '1', 'PositionMeasuringDeviceUsed'],
    '0x980D': ['SQ', '1', 'TransducerGeometryCodeSequence'],
    '0x980E': ['SQ', '1', 'TransducerBeamSteeringCodeSequence'],
    '0x980F': ['SQ', '1', 'TransducerApplicationCodeSequence'],
    '0x9810': ['xs', '1', 'ZeroVelocityPixelValue'],
    '0x9900': ['LO', '1', 'ReferenceLocationLabel'],
    '0x9901': ['UT', '1', 'ReferenceLocationDescription'],
    '0x9902': ['SQ', '1', 'ReferenceBasisCodeSequence'],
    '0x9903': ['SQ', '1', 'ReferenceGeometryCodeSequence'],
    '0x9904': ['DS', '1', 'OffsetDistance'],
    '0x9905': ['CS', '1', 'OffsetDirection'],
    '0x9906': ['SQ', '1', 'PotentialScheduledProtocolCodeSequence'],
    '0x9907': ['SQ', '1', 'PotentialRequestedProcedureCodeSequence'],
    '0x9908': ['UC', '1-n', 'PotentialReasonsForProcedure'],
    '0x9909': ['SQ', '1', 'PotentialReasonsForProcedureCodeSequence'],
    '0x990A': ['UC', '1-n', 'PotentialDiagnosticTasks'],
    '0x990B': ['SQ', '1', 'ContraindicationsCodeSequence'],
    '0x990C': ['SQ', '1', 'ReferencedDefinedProtocolSequence'],
    '0x990D': ['SQ', '1', 'ReferencedPerformedProtocolSequence'],
    '0x990E': ['SQ', '1', 'PredecessorProtocolSequence'],
    '0x990F': ['UT', '1', 'ProtocolPlanningInformation'],
    '0x9910': ['UT', '1', 'ProtocolDesignRationale'],
    '0x9911': ['SQ', '1', 'PatientSpecificationSequence'],
    '0x9912': ['SQ', '1', 'ModelSpecificationSequence'],
    '0x9913': ['SQ', '1', 'ParametersSpecificationSequence'],
    '0x9914': ['SQ', '1', 'InstructionSequence'],
    '0x9915': ['US', '1', 'InstructionIndex'],
    '0x9916': ['LO', '1', 'InstructionText'],
    '0x9917': ['UT', '1', 'InstructionDescription'],
    '0x9918': ['CS', '1', 'InstructionPerformedFlag'],
    '0x9919': ['DT', '1', 'InstructionPerformedDateTime'],
    '0x991A': ['UT', '1', 'InstructionPerformanceComment'],
    '0x991B': ['SQ', '1', 'PatientPositioningInstructionSequence'],
    '0x991C': ['SQ', '1', 'PositioningMethodCodeSequence'],
    '0x991D': ['SQ', '1', 'PositioningLandmarkSequence'],
    '0x991E': ['UI', '1', 'TargetFrameOfReferenceUID'],
    '0x991F': ['SQ', '1', 'AcquisitionProtocolElementSpecificationSequence'],
    '0x9920': ['SQ', '1', 'AcquisitionProtocolElementSequence'],
    '0x9921': ['US', '1', 'ProtocolElementNumber'],
    '0x9922': ['LO', '1', 'ProtocolElementName'],
    '0x9923': ['UT', '1', 'ProtocolElementCharacteristicsSummary'],
    '0x9924': ['UT', '1', 'ProtocolElementPurpose'],
    '0x9930': ['CS', '1', 'AcquisitionMotion'],
    '0x9931': ['SQ', '1', 'AcquisitionStartLocationSequence'],
    '0x9932': ['SQ', '1', 'AcquisitionEndLocationSequence'],
    '0x9933': ['SQ', '1', 'ReconstructionProtocolElementSpecificationSequence'],
    '0x9934': ['SQ', '1', 'ReconstructionProtocolElementSequence'],
    '0x9935': ['SQ', '1', 'StorageProtocolElementSpecificationSequence'],
    '0x9936': ['SQ', '1', 'StorageProtocolElementSequence'],
    '0x9937': ['LO', '1', 'RequestedSeriesDescription'],
    '0x9938': ['US', '1-n', 'SourceAcquisitionProtocolElementNumber'],
    '0x9939': ['US', '1-n', 'SourceAcquisitionBeamNumber'],
    '0x993A': ['US', '1-n', 'SourceReconstructionProtocolElementNumber'],
    '0x993B': ['SQ', '1', 'ReconstructionStartLocationSequence'],
    '0x993C': ['SQ', '1', 'ReconstructionEndLocationSequence'],
    '0x993D': ['SQ', '1', 'ReconstructionAlgorithmSequence'],
    '0x993E': ['SQ', '1', 'ReconstructionTargetCenterLocationSequence'],
    '0x9941': ['UT', '1', 'ImageFilterDescription'],
    '0x9942': ['FD', '1', 'CTDIvolNotificationTrigger'],
    '0x9943': ['FD', '1', 'DLPNotificationTrigger'],
    '0x9944': ['CS', '1', 'AutoKVPSelectionType'],
    '0x9945': ['FD', '1', 'AutoKVPUpperBound'],
    '0x9946': ['FD', '1', 'AutoKVPLowerBound'],
    '0x9947': ['CS', '1', 'ProtocolDefinedPatientPosition'],
    '0xA001': ['SQ', '1', 'ContributingEquipmentSequence'],
    '0xA002': ['DT', '1', 'ContributionDateTime'],
    '0xA003': ['ST', '1', 'ContributionDescription']
  },
  '0x0020': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x000D': ['UI', '1', 'StudyInstanceUID'],
    '0x000E': ['UI', '1', 'SeriesInstanceUID'],
    '0x0010': ['SH', '1', 'StudyID'],
    '0x0011': ['IS', '1', 'SeriesNumber'],
    '0x0012': ['IS', '1', 'AcquisitionNumber'],
    '0x0013': ['IS', '1', 'InstanceNumber'],
    '0x0014': ['IS', '1', 'IsotopeNumber'],
    '0x0015': ['IS', '1', 'PhaseNumber'],
    '0x0016': ['IS', '1', 'IntervalNumber'],
    '0x0017': ['IS', '1', 'TimeSlotNumber'],
    '0x0018': ['IS', '1', 'AngleNumber'],
    '0x0019': ['IS', '1', 'ItemNumber'],
    '0x0020': ['CS', '2', 'PatientOrientation'],
    '0x0022': ['IS', '1', 'OverlayNumber'],
    '0x0024': ['IS', '1', 'CurveNumber'],
    '0x0026': ['IS', '1', 'LUTNumber'],
    '0x0030': ['DS', '3', 'ImagePosition'],
    '0x0032': ['DS', '3', 'ImagePositionPatient'],
    '0x0035': ['DS', '6', 'ImageOrientation'],
    '0x0037': ['DS', '6', 'ImageOrientationPatient'],
    '0x0050': ['DS', '1', 'Location'],
    '0x0052': ['UI', '1', 'FrameOfReferenceUID'],
    '0x0060': ['CS', '1', 'Laterality'],
    '0x0062': ['CS', '1', 'ImageLaterality'],
    '0x0070': ['LO', '1', 'ImageGeometryType'],
    '0x0080': ['CS', '1-n', 'MaskingImage'],
    '0x00AA': ['IS', '1', 'ReportNumber'],
    '0x0100': ['IS', '1', 'TemporalPositionIdentifier'],
    '0x0105': ['IS', '1', 'NumberOfTemporalPositions'],
    '0x0110': ['DS', '1', 'TemporalResolution'],
    '0x0200': ['UI', '1', 'SynchronizationFrameOfReferenceUID'],
    '0x0242': ['UI', '1', 'SOPInstanceUIDOfConcatenationSource'],
    '0x1000': ['IS', '1', 'SeriesInStudy'],
    '0x1001': ['IS', '1', 'AcquisitionsInSeries'],
    '0x1002': ['IS', '1', 'ImagesInAcquisition'],
    '0x1003': ['IS', '1', 'ImagesInSeries'],
    '0x1004': ['IS', '1', 'AcquisitionsInStudy'],
    '0x1005': ['IS', '1', 'ImagesInStudy'],
    '0x1020': ['LO', '1-n', 'Reference'],
    '0x103F': ['LO', '1', 'TargetPositionReferenceIndicator'],
    '0x1040': ['LO', '1', 'PositionReferenceIndicator'],
    '0x1041': ['DS', '1', 'SliceLocation'],
    '0x1070': ['IS', '1-n', 'OtherStudyNumbers'],
    '0x1200': ['IS', '1', 'NumberOfPatientRelatedStudies'],
    '0x1202': ['IS', '1', 'NumberOfPatientRelatedSeries'],
    '0x1204': ['IS', '1', 'NumberOfPatientRelatedInstances'],
    '0x1206': ['IS', '1', 'NumberOfStudyRelatedSeries'],
    '0x1208': ['IS', '1', 'NumberOfStudyRelatedInstances'],
    '0x1209': ['IS', '1', 'NumberOfSeriesRelatedInstances'],
    '0x3100': ['CS', '1-n', 'SourceImageIDs'],
    '0x3401': ['CS', '1', 'ModifyingDeviceID'],
    '0x3402': ['CS', '1', 'ModifiedImageID'],
    '0x3403': ['DA', '1', 'ModifiedImageDate'],
    '0x3404': ['LO', '1', 'ModifyingDeviceManufacturer'],
    '0x3405': ['TM', '1', 'ModifiedImageTime'],
    '0x3406': ['LO', '1', 'ModifiedImageDescription'],
    '0x4000': ['LT', '1', 'ImageComments'],
    '0x5000': ['AT', '1-n', 'OriginalImageIdentification'],
    '0x5002': ['LO', '1-n', 'OriginalImageIdentificationNomenclature'],
    '0x9056': ['SH', '1', 'StackID'],
    '0x9057': ['UL', '1', 'InStackPositionNumber'],
    '0x9071': ['SQ', '1', 'FrameAnatomySequence'],
    '0x9072': ['CS', '1', 'FrameLaterality'],
    '0x9111': ['SQ', '1', 'FrameContentSequence'],
    '0x9113': ['SQ', '1', 'PlanePositionSequence'],
    '0x9116': ['SQ', '1', 'PlaneOrientationSequence'],
    '0x9128': ['UL', '1', 'TemporalPositionIndex'],
    '0x9153': ['FD', '1', 'NominalCardiacTriggerDelayTime'],
    '0x9154': ['FL', '1', 'NominalCardiacTriggerTimePriorToRPeak'],
    '0x9155': ['FL', '1', 'ActualCardiacTriggerTimePriorToRPeak'],
    '0x9156': ['US', '1', 'FrameAcquisitionNumber'],
    '0x9157': ['UL', '1-n', 'DimensionIndexValues'],
    '0x9158': ['LT', '1', 'FrameComments'],
    '0x9161': ['UI', '1', 'ConcatenationUID'],
    '0x9162': ['US', '1', 'InConcatenationNumber'],
    '0x9163': ['US', '1', 'InConcatenationTotalNumber'],
    '0x9164': ['UI', '1', 'DimensionOrganizationUID'],
    '0x9165': ['AT', '1', 'DimensionIndexPointer'],
    '0x9167': ['AT', '1', 'FunctionalGroupPointer'],
    '0x9170': ['SQ', '1', 'UnassignedSharedConvertedAttributesSequence'],
    '0x9171': ['SQ', '1', 'UnassignedPerFrameConvertedAttributesSequence'],
    '0x9172': ['SQ', '1', 'ConversionSourceAttributesSequence'],
    '0x9213': ['LO', '1', 'DimensionIndexPrivateCreator'],
    '0x9221': ['SQ', '1', 'DimensionOrganizationSequence'],
    '0x9222': ['SQ', '1', 'DimensionIndexSequence'],
    '0x9228': ['UL', '1', 'ConcatenationFrameOffsetNumber'],
    '0x9238': ['LO', '1', 'FunctionalGroupPrivateCreator'],
    '0x9241': ['FL', '1', 'NominalPercentageOfCardiacPhase'],
    '0x9245': ['FL', '1', 'NominalPercentageOfRespiratoryPhase'],
    '0x9246': ['FL', '1', 'StartingRespiratoryAmplitude'],
    '0x9247': ['CS', '1', 'StartingRespiratoryPhase'],
    '0x9248': ['FL', '1', 'EndingRespiratoryAmplitude'],
    '0x9249': ['CS', '1', 'EndingRespiratoryPhase'],
    '0x9250': ['CS', '1', 'RespiratoryTriggerType'],
    '0x9251': ['FD', '1', 'RRIntervalTimeNominal'],
    '0x9252': ['FD', '1', 'ActualCardiacTriggerDelayTime'],
    '0x9253': ['SQ', '1', 'RespiratorySynchronizationSequence'],
    '0x9254': ['FD', '1', 'RespiratoryIntervalTime'],
    '0x9255': ['FD', '1', 'NominalRespiratoryTriggerDelayTime'],
    '0x9256': ['FD', '1', 'RespiratoryTriggerDelayThreshold'],
    '0x9257': ['FD', '1', 'ActualRespiratoryTriggerDelayTime'],
    '0x9301': ['FD', '3', 'ImagePositionVolume'],
    '0x9302': ['FD', '6', 'ImageOrientationVolume'],
    '0x9307': ['CS', '1', 'UltrasoundAcquisitionGeometry'],
    '0x9308': ['FD', '3', 'ApexPosition'],
    '0x9309': ['FD', '16', 'VolumeToTransducerMappingMatrix'],
    '0x930A': ['FD', '16', 'VolumeToTableMappingMatrix'],
    '0x930B': ['CS', '1', 'VolumeToTransducerRelationship'],
    '0x930C': ['CS', '1', 'PatientFrameOfReferenceSource'],
    '0x930D': ['FD', '1', 'TemporalPositionTimeOffset'],
    '0x930E': ['SQ', '1', 'PlanePositionVolumeSequence'],
    '0x930F': ['SQ', '1', 'PlaneOrientationVolumeSequence'],
    '0x9310': ['SQ', '1', 'TemporalPositionSequence'],
    '0x9311': ['CS', '1', 'DimensionOrganizationType'],
    '0x9312': ['UI', '1', 'VolumeFrameOfReferenceUID'],
    '0x9313': ['UI', '1', 'TableFrameOfReferenceUID'],
    '0x9421': ['LO', '1', 'DimensionDescriptionLabel'],
    '0x9450': ['SQ', '1', 'PatientOrientationInFrameSequence'],
    '0x9453': ['LO', '1', 'FrameLabel'],
    '0x9518': ['US', '1-n', 'AcquisitionIndex'],
    '0x9529': ['SQ', '1', 'ContributingSOPInstancesReferenceSequence'],
    '0x9536': ['US', '1', 'ReconstructionIndex']
  },
  '0x0022': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0001': ['US', '1', 'LightPathFilterPassThroughWavelength'],
    '0x0002': ['US', '2', 'LightPathFilterPassBand'],
    '0x0003': ['US', '1', 'ImagePathFilterPassThroughWavelength'],
    '0x0004': ['US', '2', 'ImagePathFilterPassBand'],
    '0x0005': ['CS', '1', 'PatientEyeMovementCommanded'],
    '0x0006': ['SQ', '1', 'PatientEyeMovementCommandCodeSequence'],
    '0x0007': ['FL', '1', 'SphericalLensPower'],
    '0x0008': ['FL', '1', 'CylinderLensPower'],
    '0x0009': ['FL', '1', 'CylinderAxis'],
    '0x000A': ['FL', '1', 'EmmetropicMagnification'],
    '0x000B': ['FL', '1', 'IntraOcularPressure'],
    '0x000C': ['FL', '1', 'HorizontalFieldOfView'],
    '0x000D': ['CS', '1', 'PupilDilated'],
    '0x000E': ['FL', '1', 'DegreeOfDilation'],
    '0x0010': ['FL', '1', 'StereoBaselineAngle'],
    '0x0011': ['FL', '1', 'StereoBaselineDisplacement'],
    '0x0012': ['FL', '1', 'StereoHorizontalPixelOffset'],
    '0x0013': ['FL', '1', 'StereoVerticalPixelOffset'],
    '0x0014': ['FL', '1', 'StereoRotation'],
    '0x0015': ['SQ', '1', 'AcquisitionDeviceTypeCodeSequence'],
    '0x0016': ['SQ', '1', 'IlluminationTypeCodeSequence'],
    '0x0017': ['SQ', '1', 'LightPathFilterTypeStackCodeSequence'],
    '0x0018': ['SQ', '1', 'ImagePathFilterTypeStackCodeSequence'],
    '0x0019': ['SQ', '1', 'LensesCodeSequence'],
    '0x001A': ['SQ', '1', 'ChannelDescriptionCodeSequence'],
    '0x001B': ['SQ', '1', 'RefractiveStateSequence'],
    '0x001C': ['SQ', '1', 'MydriaticAgentCodeSequence'],
    '0x001D': ['SQ', '1', 'RelativeImagePositionCodeSequence'],
    '0x001E': ['FL', '1', 'CameraAngleOfView'],
    '0x0020': ['SQ', '1', 'StereoPairsSequence'],
    '0x0021': ['SQ', '1', 'LeftImageSequence'],
    '0x0022': ['SQ', '1', 'RightImageSequence'],
    '0x0028': ['CS', '1', 'StereoPairsPresent'],
    '0x0030': ['FL', '1', 'AxialLengthOfTheEye'],
    '0x0031': ['SQ', '1', 'OphthalmicFrameLocationSequence'],
    '0x0032': ['FL', '2-2n', 'ReferenceCoordinates'],
    '0x0035': ['FL', '1', 'DepthSpatialResolution'],
    '0x0036': ['FL', '1', 'MaximumDepthDistortion'],
    '0x0037': ['FL', '1', 'AlongScanSpatialResolution'],
    '0x0038': ['FL', '1', 'MaximumAlongScanDistortion'],
    '0x0039': ['CS', '1', 'OphthalmicImageOrientation'],
    '0x0041': ['FL', '1', 'DepthOfTransverseImage'],
    '0x0042': ['SQ', '1', 'MydriaticAgentConcentrationUnitsSequence'],
    '0x0048': ['FL', '1', 'AcrossScanSpatialResolution'],
    '0x0049': ['FL', '1', 'MaximumAcrossScanDistortion'],
    '0x004E': ['DS', '1', 'MydriaticAgentConcentration'],
    '0x0055': ['FL', '1', 'IlluminationWaveLength'],
    '0x0056': ['FL', '1', 'IlluminationPower'],
    '0x0057': ['FL', '1', 'IlluminationBandwidth'],
    '0x0058': ['SQ', '1', 'MydriaticAgentSequence'],
    '0x1007': ['SQ', '1', 'OphthalmicAxialMeasurementsRightEyeSequence'],
    '0x1008': ['SQ', '1', 'OphthalmicAxialMeasurementsLeftEyeSequence'],
    '0x1009': ['CS', '1', 'OphthalmicAxialMeasurementsDeviceType'],
    '0x1010': ['CS', '1', 'OphthalmicAxialLengthMeasurementsType'],
    '0x1012': ['SQ', '1', 'OphthalmicAxialLengthSequence'],
    '0x1019': ['FL', '1', 'OphthalmicAxialLength'],
    '0x1024': ['SQ', '1', 'LensStatusCodeSequence'],
    '0x1025': ['SQ', '1', 'VitreousStatusCodeSequence'],
    '0x1028': ['SQ', '1', 'IOLFormulaCodeSequence'],
    '0x1029': ['LO', '1', 'IOLFormulaDetail'],
    '0x1033': ['FL', '1', 'KeratometerIndex'],
    '0x1035': ['SQ', '1', 'SourceOfOphthalmicAxialLengthCodeSequence'],
    '0x1036': ['SQ', '1', 'SourceOfCornealSizeDataCodeSequence'],
    '0x1037': ['FL', '1', 'TargetRefraction'],
    '0x1039': ['CS', '1', 'RefractiveProcedureOccurred'],
    '0x1040': ['SQ', '1', 'RefractiveSurgeryTypeCodeSequence'],
    '0x1044': ['SQ', '1', 'OphthalmicUltrasoundMethodCodeSequence'],
    '0x1045': ['SQ', '1', 'SurgicallyInducedAstigmatismSequence'],
    '0x1046': ['CS', '1', 'TypeOfOpticalCorrection'],
    '0x1047': ['SQ', '1', 'ToricIOLPowerSequence'],
    '0x1048': ['SQ', '1', 'PredictedToricErrorSequence'],
    '0x1049': ['CS', '1', 'PreSelectedForImplantation'],
    '0x104A': ['SQ', '1', 'ToricIOLPowerForExactEmmetropiaSequence'],
    '0x104B': ['SQ', '1', 'ToricIOLPowerForExactTargetRefractionSequence'],
    '0x1050': ['SQ', '1', 'OphthalmicAxialLengthMeasurementsSequence'],
    '0x1053': ['FL', '1', 'IOLPower'],
    '0x1054': ['FL', '1', 'PredictedRefractiveError'],
    '0x1059': ['FL', '1', 'OphthalmicAxialLengthVelocity'],
    '0x1065': ['LO', '1', 'LensStatusDescription'],
    '0x1066': ['LO', '1', 'VitreousStatusDescription'],
    '0x1090': ['SQ', '1', 'IOLPowerSequence'],
    '0x1092': ['SQ', '1', 'LensConstantSequence'],
    '0x1093': ['LO', '1', 'IOLManufacturer'],
    '0x1094': ['LO', '1', 'LensConstantDescription'],
    '0x1095': ['LO', '1', 'ImplantName'],
    '0x1096': ['SQ', '1', 'KeratometryMeasurementTypeCodeSequence'],
    '0x1097': ['LO', '1', 'ImplantPartNumber'],
    '0x1100': ['SQ', '1', 'ReferencedOphthalmicAxialMeasurementsSequence'],
    '0x1101': ['SQ', '1', 'OphthalmicAxialLengthMeasurementsSegmentNameCodeSequence'],
    '0x1103': ['SQ', '1', 'RefractiveErrorBeforeRefractiveSurgeryCodeSequence'],
    '0x1121': ['FL', '1', 'IOLPowerForExactEmmetropia'],
    '0x1122': ['FL', '1', 'IOLPowerForExactTargetRefraction'],
    '0x1125': ['SQ', '1', 'AnteriorChamberDepthDefinitionCodeSequence'],
    '0x1127': ['SQ', '1', 'LensThicknessSequence'],
    '0x1128': ['SQ', '1', 'AnteriorChamberDepthSequence'],
    '0x112A': ['SQ', '1', 'CalculationCommentSequence'],
    '0x112B': ['CS', '1', 'CalculationCommentType'],
    '0x112C': ['LT', '1', 'CalculationComment'],
    '0x1130': ['FL', '1', 'LensThickness'],
    '0x1131': ['FL', '1', 'AnteriorChamberDepth'],
    '0x1132': ['SQ', '1', 'SourceOfLensThicknessDataCodeSequence'],
    '0x1133': ['SQ', '1', 'SourceOfAnteriorChamberDepthDataCodeSequence'],
    '0x1134': ['SQ', '1', 'SourceOfRefractiveMeasurementsSequence'],
    '0x1135': ['SQ', '1', 'SourceOfRefractiveMeasurementsCodeSequence'],
    '0x1140': ['CS', '1', 'OphthalmicAxialLengthMeasurementModified'],
    '0x1150': ['SQ', '1', 'OphthalmicAxialLengthDataSourceCodeSequence'],
    '0x1153': ['SQ', '1', 'OphthalmicAxialLengthAcquisitionMethodCodeSequence'],
    '0x1155': ['FL', '1', 'SignalToNoiseRatio'],
    '0x1159': ['LO', '1', 'OphthalmicAxialLengthDataSourceDescription'],
    '0x1210': ['SQ', '1', 'OphthalmicAxialLengthMeasurementsTotalLengthSequence'],
    '0x1211': ['SQ', '1', 'OphthalmicAxialLengthMeasurementsSegmentalLengthSequence'],
    '0x1212': ['SQ', '1', 'OphthalmicAxialLengthMeasurementsLengthSummationSequence'],
    '0x1220': ['SQ', '1', 'UltrasoundOphthalmicAxialLengthMeasurementsSequence'],
    '0x1225': ['SQ', '1', 'OpticalOphthalmicAxialLengthMeasurementsSequence'],
    '0x1230': ['SQ', '1', 'UltrasoundSelectedOphthalmicAxialLengthSequence'],
    '0x1250': ['SQ', '1', 'OphthalmicAxialLengthSelectionMethodCodeSequence'],
    '0x1255': ['SQ', '1', 'OpticalSelectedOphthalmicAxialLengthSequence'],
    '0x1257': ['SQ', '1', 'SelectedSegmentalOphthalmicAxialLengthSequence'],
    '0x1260': ['SQ', '1', 'SelectedTotalOphthalmicAxialLengthSequence'],
    '0x1262': ['SQ', '1', 'OphthalmicAxialLengthQualityMetricSequence'],
    '0x1265': ['SQ', '1', 'OphthalmicAxialLengthQualityMetricTypeCodeSequence'],
    '0x1273': ['LO', '1', 'OphthalmicAxialLengthQualityMetricTypeDescription'],
    '0x1300': ['SQ', '1', 'IntraocularLensCalculationsRightEyeSequence'],
    '0x1310': ['SQ', '1', 'IntraocularLensCalculationsLeftEyeSequence'],
    '0x1330': ['SQ', '1', 'ReferencedOphthalmicAxialLengthMeasurementQCImageSequence'],
    '0x1415': ['CS', '1', 'OphthalmicMappingDeviceType'],
    '0x1420': ['SQ', '1', 'AcquisitionMethodCodeSequence'],
    '0x1423': ['SQ', '1', 'AcquisitionMethodAlgorithmSequence'],
    '0x1436': ['SQ', '1', 'OphthalmicThicknessMapTypeCodeSequence'],
    '0x1443': ['SQ', '1', 'OphthalmicThicknessMappingNormalsSequence'],
    '0x1445': ['SQ', '1', 'RetinalThicknessDefinitionCodeSequence'],
    '0x1450': ['SQ', '1', 'PixelValueMappingToCodedConceptSequence'],
    '0x1452': ['xs', '1', 'MappedPixelValue'],
    '0x1454': ['LO', '1', 'PixelValueMappingExplanation'],
    '0x1458': ['SQ', '1', 'OphthalmicThicknessMapQualityThresholdSequence'],
    '0x1460': ['FL', '1', 'OphthalmicThicknessMapThresholdQualityRating'],
    '0x1463': ['FL', '2', 'AnatomicStructureReferencePoint'],
    '0x1465': ['SQ', '1', 'RegistrationToLocalizerSequence'],
    '0x1466': ['CS', '1', 'RegisteredLocalizerUnits'],
    '0x1467': ['FL', '2', 'RegisteredLocalizerTopLeftHandCorner'],
    '0x1468': ['FL', '2', 'RegisteredLocalizerBottomRightHandCorner'],
    '0x1470': ['SQ', '1', 'OphthalmicThicknessMapQualityRatingSequence'],
    '0x1472': ['SQ', '1', 'RelevantOPTAttributesSequence'],
    '0x1512': ['SQ', '1', 'TransformationMethodCodeSequence'],
    '0x1513': ['SQ', '1', 'TransformationAlgorithmSequence'],
    '0x1515': ['CS', '1', 'OphthalmicAxialLengthMethod'],
    '0x1517': ['FL', '1', 'OphthalmicFOV'],
    '0x1518': ['SQ', '1', 'TwoDimensionalToThreeDimensionalMapSequence'],
    '0x1525': ['SQ', '1', 'WideFieldOphthalmicPhotographyQualityRatingSequence'],
    '0x1526': ['SQ', '1', 'WideFieldOphthalmicPhotographyQualityThresholdSequence'],
    '0x1527': ['FL', '1', 'WideFieldOphthalmicPhotographyThresholdQualityRating'],
    '0x1528': ['FL', '1', 'XCoordinatesCenterPixelViewAngle'],
    '0x1529': ['FL', '1', 'YCoordinatesCenterPixelViewAngle'],
    '0x1530': ['UL', '1', 'NumberOfMapPoints'],
    '0x1531': ['OF', '1', 'TwoDimensionalToThreeDimensionalMapData'],
    '0x1612': ['SQ', '1', 'DerivationAlgorithmSequence'],
    '0x1615': ['SQ', '1', 'OphthalmicImageTypeCodeSequence'],
    '0x1616': ['LO', '1', 'OphthalmicImageTypeDescription'],
    '0x1618': ['SQ', '1', 'ScanPatternTypeCodeSequence'],
    '0x1620': ['SQ', '1', 'ReferencedSurfaceMeshIdentificationSequence'],
    '0x1622': ['CS', '1', 'OphthalmicVolumetricPropertiesFlag'],
    '0x1624': ['FL', '1', 'OphthalmicAnatomicReferencePointXCoordinate'],
    '0x1626': ['FL', '1', 'OphthalmicAnatomicReferencePointYCoordinate'],
    '0x1628': ['SQ', '1', 'OphthalmicEnFaceImageQualityRatingSequence'],
    '0x1630': ['DS', '1', 'QualityThreshold'],
    '0x1640': ['SQ', '1', 'OCTBscanAnalysisAcquisitionParametersSequence'],
    '0x1642': ['UL', '1', 'NumberOfBscansPerFrame'],
    '0x1643': ['FL', '1', 'BscanSlabThickness'],
    '0x1644': ['FL', '1', 'DistanceBetweenBscanSlabs'],
    '0x1645': ['FL', '1', 'BscanCycleTime'],
    '0x1646': ['FL', '1-n', 'BscanCycleTimeVector'],
    '0x1649': ['FL', '1', 'AscanRate'],
    '0x1650': ['FL', '1', 'BscanRate'],
    '0x1658': ['UL', '1', 'SurfaceMeshZPixelOffset']
  },
  '0x0024': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0010': ['FL', '1', 'VisualFieldHorizontalExtent'],
    '0x0011': ['FL', '1', 'VisualFieldVerticalExtent'],
    '0x0012': ['CS', '1', 'VisualFieldShape'],
    '0x0016': ['SQ', '1', 'ScreeningTestModeCodeSequence'],
    '0x0018': ['FL', '1', 'MaximumStimulusLuminance'],
    '0x0020': ['FL', '1', 'BackgroundLuminance'],
    '0x0021': ['SQ', '1', 'StimulusColorCodeSequence'],
    '0x0024': ['SQ', '1', 'BackgroundIlluminationColorCodeSequence'],
    '0x0025': ['FL', '1', 'StimulusArea'],
    '0x0028': ['FL', '1', 'StimulusPresentationTime'],
    '0x0032': ['SQ', '1', 'FixationSequence'],
    '0x0033': ['SQ', '1', 'FixationMonitoringCodeSequence'],
    '0x0034': ['SQ', '1', 'VisualFieldCatchTrialSequence'],
    '0x0035': ['US', '1', 'FixationCheckedQuantity'],
    '0x0036': ['US', '1', 'PatientNotProperlyFixatedQuantity'],
    '0x0037': ['CS', '1', 'PresentedVisualStimuliDataFlag'],
    '0x0038': ['US', '1', 'NumberOfVisualStimuli'],
    '0x0039': ['CS', '1', 'ExcessiveFixationLossesDataFlag'],
    '0x0040': ['CS', '1', 'ExcessiveFixationLosses'],
    '0x0042': ['US', '1', 'StimuliRetestingQuantity'],
    '0x0044': ['LT', '1', 'CommentsOnPatientPerformanceOfVisualField'],
    '0x0045': ['CS', '1', 'FalseNegativesEstimateFlag'],
    '0x0046': ['FL', '1', 'FalseNegativesEstimate'],
    '0x0048': ['US', '1', 'NegativeCatchTrialsQuantity'],
    '0x0050': ['US', '1', 'FalseNegativesQuantity'],
    '0x0051': ['CS', '1', 'ExcessiveFalseNegativesDataFlag'],
    '0x0052': ['CS', '1', 'ExcessiveFalseNegatives'],
    '0x0053': ['CS', '1', 'FalsePositivesEstimateFlag'],
    '0x0054': ['FL', '1', 'FalsePositivesEstimate'],
    '0x0055': ['CS', '1', 'CatchTrialsDataFlag'],
    '0x0056': ['US', '1', 'PositiveCatchTrialsQuantity'],
    '0x0057': ['CS', '1', 'TestPointNormalsDataFlag'],
    '0x0058': ['SQ', '1', 'TestPointNormalsSequence'],
    '0x0059': ['CS', '1', 'GlobalDeviationProbabilityNormalsFlag'],
    '0x0060': ['US', '1', 'FalsePositivesQuantity'],
    '0x0061': ['CS', '1', 'ExcessiveFalsePositivesDataFlag'],
    '0x0062': ['CS', '1', 'ExcessiveFalsePositives'],
    '0x0063': ['CS', '1', 'VisualFieldTestNormalsFlag'],
    '0x0064': ['SQ', '1', 'ResultsNormalsSequence'],
    '0x0065': ['SQ', '1', 'AgeCorrectedSensitivityDeviationAlgorithmSequence'],
    '0x0066': ['FL', '1', 'GlobalDeviationFromNormal'],
    '0x0067': ['SQ', '1', 'GeneralizedDefectSensitivityDeviationAlgorithmSequence'],
    '0x0068': ['FL', '1', 'LocalizedDeviationFromNormal'],
    '0x0069': ['LO', '1', 'PatientReliabilityIndicator'],
    '0x0070': ['FL', '1', 'VisualFieldMeanSensitivity'],
    '0x0071': ['FL', '1', 'GlobalDeviationProbability'],
    '0x0072': ['CS', '1', 'LocalDeviationProbabilityNormalsFlag'],
    '0x0073': ['FL', '1', 'LocalizedDeviationProbability'],
    '0x0074': ['CS', '1', 'ShortTermFluctuationCalculated'],
    '0x0075': ['FL', '1', 'ShortTermFluctuation'],
    '0x0076': ['CS', '1', 'ShortTermFluctuationProbabilityCalculated'],
    '0x0077': ['FL', '1', 'ShortTermFluctuationProbability'],
    '0x0078': ['CS', '1', 'CorrectedLocalizedDeviationFromNormalCalculated'],
    '0x0079': ['FL', '1', 'CorrectedLocalizedDeviationFromNormal'],
    '0x0080': ['CS', '1', 'CorrectedLocalizedDeviationFromNormalProbabilityCalculated'],
    '0x0081': ['FL', '1', 'CorrectedLocalizedDeviationFromNormalProbability'],
    '0x0083': ['SQ', '1', 'GlobalDeviationProbabilitySequence'],
    '0x0085': ['SQ', '1', 'LocalizedDeviationProbabilitySequence'],
    '0x0086': ['CS', '1', 'FovealSensitivityMeasured'],
    '0x0087': ['FL', '1', 'FovealSensitivity'],
    '0x0088': ['FL', '1', 'VisualFieldTestDuration'],
    '0x0089': ['SQ', '1', 'VisualFieldTestPointSequence'],
    '0x0090': ['FL', '1', 'VisualFieldTestPointXCoordinate'],
    '0x0091': ['FL', '1', 'VisualFieldTestPointYCoordinate'],
    '0x0092': ['FL', '1', 'AgeCorrectedSensitivityDeviationValue'],
    '0x0093': ['CS', '1', 'StimulusResults'],
    '0x0094': ['FL', '1', 'SensitivityValue'],
    '0x0095': ['CS', '1', 'RetestStimulusSeen'],
    '0x0096': ['FL', '1', 'RetestSensitivityValue'],
    '0x0097': ['SQ', '1', 'VisualFieldTestPointNormalsSequence'],
    '0x0098': ['FL', '1', 'QuantifiedDefect'],
    '0x0100': ['FL', '1', 'AgeCorrectedSensitivityDeviationProbabilityValue'],
    '0x0102': ['CS', '1', 'GeneralizedDefectCorrectedSensitivityDeviationFlag'],
    '0x0103': ['FL', '1', 'GeneralizedDefectCorrectedSensitivityDeviationValue'],
    '0x0104': ['FL', '1', 'GeneralizedDefectCorrectedSensitivityDeviationProbabilityValue'],
    '0x0105': ['FL', '1', 'MinimumSensitivityValue'],
    '0x0106': ['CS', '1', 'BlindSpotLocalized'],
    '0x0107': ['FL', '1', 'BlindSpotXCoordinate'],
    '0x0108': ['FL', '1', 'BlindSpotYCoordinate'],
    '0x0110': ['SQ', '1', 'VisualAcuityMeasurementSequence'],
    '0x0112': ['SQ', '1', 'RefractiveParametersUsedOnPatientSequence'],
    '0x0113': ['CS', '1', 'MeasurementLaterality'],
    '0x0114': ['SQ', '1', 'OphthalmicPatientClinicalInformationLeftEyeSequence'],
    '0x0115': ['SQ', '1', 'OphthalmicPatientClinicalInformationRightEyeSequence'],
    '0x0117': ['CS', '1', 'FovealPointNormativeDataFlag'],
    '0x0118': ['FL', '1', 'FovealPointProbabilityValue'],
    '0x0120': ['CS', '1', 'ScreeningBaselineMeasured'],
    '0x0122': ['SQ', '1', 'ScreeningBaselineMeasuredSequence'],
    '0x0124': ['CS', '1', 'ScreeningBaselineType'],
    '0x0126': ['FL', '1', 'ScreeningBaselineValue'],
    '0x0202': ['LO', '1', 'AlgorithmSource'],
    '0x0306': ['LO', '1', 'DataSetName'],
    '0x0307': ['LO', '1', 'DataSetVersion'],
    '0x0308': ['LO', '1', 'DataSetSource'],
    '0x0309': ['LO', '1', 'DataSetDescription'],
    '0x0317': ['SQ', '1', 'VisualFieldTestReliabilityGlobalIndexSequence'],
    '0x0320': ['SQ', '1', 'VisualFieldGlobalResultsIndexSequence'],
    '0x0325': ['SQ', '1', 'DataObservationSequence'],
    '0x0338': ['CS', '1', 'IndexNormalsFlag'],
    '0x0341': ['FL', '1', 'IndexProbability'],
    '0x0344': ['SQ', '1', 'IndexProbabilitySequence']
  },
  '0x0028': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0002': ['US', '1', 'SamplesPerPixel'],
    '0x0003': ['US', '1', 'SamplesPerPixelUsed'],
    '0x0004': ['CS', '1', 'PhotometricInterpretation'],
    '0x0005': ['US', '1', 'ImageDimensions'],
    '0x0006': ['US', '1', 'PlanarConfiguration'],
    '0x0008': ['IS', '1', 'NumberOfFrames'],
    '0x0009': ['AT', '1-n', 'FrameIncrementPointer'],
    '0x000A': ['AT', '1-n', 'FrameDimensionPointer'],
    '0x0010': ['US', '1', 'Rows'],
    '0x0011': ['US', '1', 'Columns'],
    '0x0012': ['US', '1', 'Planes'],
    '0x0014': ['US', '1', 'UltrasoundColorDataPresent'],
    '0x0020': ['', '', ''],
    '0x0030': ['DS', '2', 'PixelSpacing'],
    '0x0031': ['DS', '2', 'ZoomFactor'],
    '0x0032': ['DS', '2', 'ZoomCenter'],
    '0x0034': ['IS', '2', 'PixelAspectRatio'],
    '0x0040': ['CS', '1', 'ImageFormat'],
    '0x0050': ['LO', '1-n', 'ManipulatedImage'],
    '0x0051': ['CS', '1-n', 'CorrectedImage'],
    '0x005F': ['LO', '1', 'CompressionRecognitionCode'],
    '0x0060': ['CS', '1', 'CompressionCode'],
    '0x0061': ['SH', '1', 'CompressionOriginator'],
    '0x0062': ['LO', '1', 'CompressionLabel'],
    '0x0063': ['SH', '1', 'CompressionDescription'],
    '0x0065': ['CS', '1-n', 'CompressionSequence'],
    '0x0066': ['AT', '1-n', 'CompressionStepPointers'],
    '0x0068': ['US', '1', 'RepeatInterval'],
    '0x0069': ['US', '1', 'BitsGrouped'],
    '0x0070': ['US', '1-n', 'PerimeterTable'],
    '0x0071': ['xs', '1', 'PerimeterValue'],
    '0x0080': ['US', '1', 'PredictorRows'],
    '0x0081': ['US', '1', 'PredictorColumns'],
    '0x0082': ['US', '1-n', 'PredictorConstants'],
    '0x0090': ['CS', '1', 'BlockedPixels'],
    '0x0091': ['US', '1', 'BlockRows'],
    '0x0092': ['US', '1', 'BlockColumns'],
    '0x0093': ['US', '1', 'RowOverlap'],
    '0x0094': ['US', '1', 'ColumnOverlap'],
    '0x0100': ['US', '1', 'BitsAllocated'],
    '0x0101': ['US', '1', 'BitsStored'],
    '0x0102': ['US', '1', 'HighBit'],
    '0x0103': ['US', '1', 'PixelRepresentation'],
    '0x0104': ['xs', '1', 'SmallestValidPixelValue'],
    '0x0105': ['xs', '1', 'LargestValidPixelValue'],
    '0x0106': ['xs', '1', 'SmallestImagePixelValue'],
    '0x0107': ['xs', '1', 'LargestImagePixelValue'],
    '0x0108': ['xs', '1', 'SmallestPixelValueInSeries'],
    '0x0109': ['xs', '1', 'LargestPixelValueInSeries'],
    '0x0110': ['xs', '1', 'SmallestImagePixelValueInPlane'],
    '0x0111': ['xs', '1', 'LargestImagePixelValueInPlane'],
    '0x0120': ['xs', '1', 'PixelPaddingValue'],
    '0x0121': ['xs', '1', 'PixelPaddingRangeLimit'],
    '0x0122': ['FL', '1', 'FloatPixelPaddingValue'],
    '0x0123': ['FD', '1', 'DoubleFloatPixelPaddingValue'],
    '0x0124': ['FL', '1', 'FloatPixelPaddingRangeLimit'],
    '0x0125': ['FD', '1', 'DoubleFloatPixelPaddingRangeLimit'],
    '0x0200': ['US', '1', 'ImageLocation'],
    '0x0300': ['CS', '1', 'QualityControlImage'],
    '0x0301': ['CS', '1', 'BurnedInAnnotation'],
    '0x0302': ['CS', '1', 'RecognizableVisualFeatures'],
    '0x0303': ['CS', '1', 'LongitudinalTemporalInformationModified'],
    '0x0304': ['UI', '1', 'ReferencedColorPaletteInstanceUID'],
    '0x0400': ['LO', '1', 'TransformLabel'],
    '0x0401': ['LO', '1', 'TransformVersionNumber'],
    '0x0402': ['US', '1', 'NumberOfTransformSteps'],
    '0x0403': ['LO', '1-n', 'SequenceOfCompressedData'],
    '0x0404': ['AT', '1-n', 'DetailsOfCoefficients'],
    '0x04x0': ['US', '1', 'RowsForNthOrderCoefficients'],
    '0x04x1': ['US', '1', 'ColumnsForNthOrderCoefficients'],
    '0x04x2': ['LO', '1-n', 'CoefficientCoding'],
    '0x04x3': ['AT', '1-n', 'CoefficientCodingPointers'],
    '0x0700': ['LO', '1', 'DCTLabel'],
    '0x0701': ['CS', '1-n', 'DataBlockDescription'],
    '0x0702': ['AT', '1-n', 'DataBlock'],
    '0x0710': ['US', '1', 'NormalizationFactorFormat'],
    '0x0720': ['US', '1', 'ZonalMapNumberFormat'],
    '0x0721': ['AT', '1-n', 'ZonalMapLocation'],
    '0x0722': ['US', '1', 'ZonalMapFormat'],
    '0x0730': ['US', '1', 'AdaptiveMapFormat'],
    '0x0740': ['US', '1', 'CodeNumberFormat'],
    '0x08x0': ['CS', '1-n', 'CodeLabel'],
    '0x08x2': ['US', '1', 'NumberOfTables'],
    '0x08x3': ['AT', '1-n', 'CodeTableLocation'],
    '0x08x4': ['US', '1', 'BitsForCodeWord'],
    '0x08x8': ['AT', '1-n', 'ImageDataLocation'],
    '0x0A02': ['CS', '1', 'PixelSpacingCalibrationType'],
    '0x0A04': ['LO', '1', 'PixelSpacingCalibrationDescription'],
    '0x1040': ['CS', '1', 'PixelIntensityRelationship'],
    '0x1041': ['SS', '1', 'PixelIntensityRelationshipSign'],
    '0x1050': ['DS', '1-n', 'WindowCenter'],
    '0x1051': ['DS', '1-n', 'WindowWidth'],
    '0x1052': ['DS', '1', 'RescaleIntercept'],
    '0x1053': ['DS', '1', 'RescaleSlope'],
    '0x1054': ['LO', '1', 'RescaleType'],
    '0x1055': ['LO', '1-n', 'WindowCenterWidthExplanation'],
    '0x1056': ['CS', '1', 'VOILUTFunction'],
    '0x1080': ['CS', '1', 'GrayScale'],
    '0x1090': ['CS', '1', 'RecommendedViewingMode'],
    '0x1100': ['xs', '3', 'GrayLookupTableDescriptor'],
    '0x1101': ['xs', '3', 'RedPaletteColorLookupTableDescriptor'],
    '0x1102': ['xs', '3', 'GreenPaletteColorLookupTableDescriptor'],
    '0x1103': ['xs', '3', 'BluePaletteColorLookupTableDescriptor'],
    '0x1104': ['US', '3', 'AlphaPaletteColorLookupTableDescriptor'],
    '0x1111': ['xs', '4', 'LargeRedPaletteColorLookupTableDescriptor'],
    '0x1112': ['xs', '4', 'LargeGreenPaletteColorLookupTableDescriptor'],
    '0x1113': ['xs', '4', 'LargeBluePaletteColorLookupTableDescriptor'],
    '0x1199': ['UI', '1', 'PaletteColorLookupTableUID'],
    '0x1200': ['US or SS or OW', '1-n or 1', 'GrayLookupTableData'],
    '0x1201': ['OW', '1', 'RedPaletteColorLookupTableData'],
    '0x1202': ['OW', '1', 'GreenPaletteColorLookupTableData'],
    '0x1203': ['OW', '1', 'BluePaletteColorLookupTableData'],
    '0x1204': ['OW', '1', 'AlphaPaletteColorLookupTableData'],
    '0x1211': ['OW', '1', 'LargeRedPaletteColorLookupTableData'],
    '0x1212': ['OW', '1', 'LargeGreenPaletteColorLookupTableData'],
    '0x1213': ['OW', '1', 'LargeBluePaletteColorLookupTableData'],
    '0x1214': ['UI', '1', 'LargePaletteColorLookupTableUID'],
    '0x1221': ['OW', '1', 'SegmentedRedPaletteColorLookupTableData'],
    '0x1222': ['OW', '1', 'SegmentedGreenPaletteColorLookupTableData'],
    '0x1223': ['OW', '1', 'SegmentedBluePaletteColorLookupTableData'],
    '0x1224': ['OW', '1', 'SegmentedAlphaPaletteColorLookupTableData'],
    '0x1230': ['SQ', '1', 'StoredValueColorRangeSequence'],
    '0x1231': ['FD', '1', 'MinimumStoredValueMapped'],
    '0x1232': ['FD', '1', 'MaximumStoredValueMapped'],
    '0x1300': ['CS', '1', 'BreastImplantPresent'],
    '0x1350': ['CS', '1', 'PartialView'],
    '0x1351': ['ST', '1', 'PartialViewDescription'],
    '0x1352': ['SQ', '1', 'PartialViewCodeSequence'],
    '0x135A': ['CS', '1', 'SpatialLocationsPreserved'],
    '0x1401': ['SQ', '1', 'DataFrameAssignmentSequence'],
    '0x1402': ['CS', '1', 'DataPathAssignment'],
    '0x1403': ['US', '1', 'BitsMappedToColorLookupTable'],
    '0x1404': ['SQ', '1', 'BlendingLUT1Sequence'],
    '0x1405': ['CS', '1', 'BlendingLUT1TransferFunction'],
    '0x1406': ['FD', '1', 'BlendingWeightConstant'],
    '0x1407': ['US', '3', 'BlendingLookupTableDescriptor'],
    '0x1408': ['OW', '1', 'BlendingLookupTableData'],
    '0x140B': ['SQ', '1', 'EnhancedPaletteColorLookupTableSequence'],
    '0x140C': ['SQ', '1', 'BlendingLUT2Sequence'],
    '0x140D': ['CS', '1', 'BlendingLUT2TransferFunction'],
    '0x140E': ['CS', '1', 'DataPathID'],
    '0x140F': ['CS', '1', 'RGBLUTTransferFunction'],
    '0x1410': ['CS', '1', 'AlphaLUTTransferFunction'],
    '0x2000': ['OB', '1', 'ICCProfile'],
    '0x2002': ['CS', '1', 'ColorSpace'],
    '0x2110': ['CS', '1', 'LossyImageCompression'],
    '0x2112': ['DS', '1-n', 'LossyImageCompressionRatio'],
    '0x2114': ['CS', '1-n', 'LossyImageCompressionMethod'],
    '0x3000': ['SQ', '1', 'ModalityLUTSequence'],
    '0x3002': ['xs', '3', 'LUTDescriptor'],
    '0x3003': ['LO', '1', 'LUTExplanation'],
    '0x3004': ['LO', '1', 'ModalityLUTType'],
    '0x3006': ['US or OW', '1-n or 1', 'LUTData'],
    '0x3010': ['SQ', '1', 'VOILUTSequence'],
    '0x3110': ['SQ', '1', 'SoftcopyVOILUTSequence'],
    '0x4000': ['LT', '1', 'ImagePresentationComments'],
    '0x5000': ['SQ', '1', 'BiPlaneAcquisitionSequence'],
    '0x6010': ['US', '1', 'RepresentativeFrameNumber'],
    '0x6020': ['US', '1-n', 'FrameNumbersOfInterest'],
    '0x6022': ['LO', '1-n', 'FrameOfInterestDescription'],
    '0x6023': ['CS', '1-n', 'FrameOfInterestType'],
    '0x6030': ['US', '1-n', 'MaskPointers'],
    '0x6040': ['US', '1-n', 'RWavePointer'],
    '0x6100': ['SQ', '1', 'MaskSubtractionSequence'],
    '0x6101': ['CS', '1', 'MaskOperation'],
    '0x6102': ['US', '2-2n', 'ApplicableFrameRange'],
    '0x6110': ['US', '1-n', 'MaskFrameNumbers'],
    '0x6112': ['US', '1', 'ContrastFrameAveraging'],
    '0x6114': ['FL', '2', 'MaskSubPixelShift'],
    '0x6120': ['SS', '1', 'TIDOffset'],
    '0x6190': ['ST', '1', 'MaskOperationExplanation'],
    '0x7000': ['SQ', '1', 'EquipmentAdministratorSequence'],
    '0x7001': ['US', '1', 'NumberOfDisplaySubsystems'],
    '0x7002': ['US', '1', 'CurrentConfigurationID'],
    '0x7003': ['US', '1', 'DisplaySubsystemID'],
    '0x7004': ['SH', '1', 'DisplaySubsystemName'],
    '0x7005': ['LO', '1', 'DisplaySubsystemDescription'],
    '0x7006': ['CS', '1', 'SystemStatus'],
    '0x7007': ['LO', '1', 'SystemStatusComment'],
    '0x7008': ['SQ', '1', 'TargetLuminanceCharacteristicsSequence'],
    '0x7009': ['US', '1', 'LuminanceCharacteristicsID'],
    '0x700A': ['SQ', '1', 'DisplaySubsystemConfigurationSequence'],
    '0x700B': ['US', '1', 'ConfigurationID'],
    '0x700C': ['SH', '1', 'ConfigurationName'],
    '0x700D': ['LO', '1', 'ConfigurationDescription'],
    '0x700E': ['US', '1', 'ReferencedTargetLuminanceCharacteristicsID'],
    '0x700F': ['SQ', '1', 'QAResultsSequence'],
    '0x7010': ['SQ', '1', 'DisplaySubsystemQAResultsSequence'],
    '0x7011': ['SQ', '1', 'ConfigurationQAResultsSequence'],
    '0x7012': ['SQ', '1', 'MeasurementEquipmentSequence'],
    '0x7013': ['CS', '1-n', 'MeasurementFunctions'],
    '0x7014': ['CS', '1', 'MeasurementEquipmentType'],
    '0x7015': ['SQ', '1', 'VisualEvaluationResultSequence'],
    '0x7016': ['SQ', '1', 'DisplayCalibrationResultSequence'],
    '0x7017': ['US', '1', 'DDLValue'],
    '0x7018': ['FL', '2', 'CIExyWhitePoint'],
    '0x7019': ['CS', '1', 'DisplayFunctionType'],
    '0x701A': ['FL', '1', 'GammaValue'],
    '0x701B': ['US', '1', 'NumberOfLuminancePoints'],
    '0x701C': ['SQ', '1', 'LuminanceResponseSequence'],
    '0x701D': ['FL', '1', 'TargetMinimumLuminance'],
    '0x701E': ['FL', '1', 'TargetMaximumLuminance'],
    '0x701F': ['FL', '1', 'LuminanceValue'],
    '0x7020': ['LO', '1', 'LuminanceResponseDescription'],
    '0x7021': ['CS', '1', 'WhitePointFlag'],
    '0x7022': ['SQ', '1', 'DisplayDeviceTypeCodeSequence'],
    '0x7023': ['SQ', '1', 'DisplaySubsystemSequence'],
    '0x7024': ['SQ', '1', 'LuminanceResultSequence'],
    '0x7025': ['CS', '1', 'AmbientLightValueSource'],
    '0x7026': ['CS', '1-n', 'MeasuredCharacteristics'],
    '0x7027': ['SQ', '1', 'LuminanceUniformityResultSequence'],
    '0x7028': ['SQ', '1', 'VisualEvaluationTestSequence'],
    '0x7029': ['CS', '1', 'TestResult'],
    '0x702A': ['LO', '1', 'TestResultComment'],
    '0x702B': ['CS', '1', 'TestImageValidation'],
    '0x702C': ['SQ', '1', 'TestPatternCodeSequence'],
    '0x702D': ['SQ', '1', 'MeasurementPatternCodeSequence'],
    '0x702E': ['SQ', '1', 'VisualEvaluationMethodCodeSequence'],
    '0x7FE0': ['UR', '1', 'PixelDataProviderURL'],
    '0x9001': ['UL', '1', 'DataPointRows'],
    '0x9002': ['UL', '1', 'DataPointColumns'],
    '0x9003': ['CS', '1', 'SignalDomainColumns'],
    '0x9099': ['US', '1', 'LargestMonochromePixelValue'],
    '0x9108': ['CS', '1', 'DataRepresentation'],
    '0x9110': ['SQ', '1', 'PixelMeasuresSequence'],
    '0x9132': ['SQ', '1', 'FrameVOILUTSequence'],
    '0x9145': ['SQ', '1', 'PixelValueTransformationSequence'],
    '0x9235': ['CS', '1', 'SignalDomainRows'],
    '0x9411': ['FL', '1', 'DisplayFilterPercentage'],
    '0x9415': ['SQ', '1', 'FramePixelShiftSequence'],
    '0x9416': ['US', '1', 'SubtractionItemID'],
    '0x9422': ['SQ', '1', 'PixelIntensityRelationshipLUTSequence'],
    '0x9443': ['SQ', '1', 'FramePixelDataPropertiesSequence'],
    '0x9444': ['CS', '1', 'GeometricalProperties'],
    '0x9445': ['FL', '1', 'GeometricMaximumDistortion'],
    '0x9446': ['CS', '1-n', 'ImageProcessingApplied'],
    '0x9454': ['CS', '1', 'MaskSelectionMode'],
    '0x9474': ['CS', '1', 'LUTFunction'],
    '0x9478': ['FL', '1', 'MaskVisibilityPercentage'],
    '0x9501': ['SQ', '1', 'PixelShiftSequence'],
    '0x9502': ['SQ', '1', 'RegionPixelShiftSequence'],
    '0x9503': ['SS', '2-2n', 'VerticesOfTheRegion'],
    '0x9505': ['SQ', '1', 'MultiFramePresentationSequence'],
    '0x9506': ['US', '2-2n', 'PixelShiftFrameRange'],
    '0x9507': ['US', '2-2n', 'LUTFrameRange'],
    '0x9520': ['DS', '16', 'ImageToEquipmentMappingMatrix'],
    '0x9537': ['CS', '1', 'EquipmentCoordinateSystemIdentification']
  },
  '0x0032': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x000A': ['CS', '1', 'StudyStatusID'],
    '0x000C': ['CS', '1', 'StudyPriorityID'],
    '0x0012': ['LO', '1', 'StudyIDIssuer'],
    '0x0032': ['DA', '1', 'StudyVerifiedDate'],
    '0x0033': ['TM', '1', 'StudyVerifiedTime'],
    '0x0034': ['DA', '1', 'StudyReadDate'],
    '0x0035': ['TM', '1', 'StudyReadTime'],
    '0x1000': ['DA', '1', 'ScheduledStudyStartDate'],
    '0x1001': ['TM', '1', 'ScheduledStudyStartTime'],
    '0x1010': ['DA', '1', 'ScheduledStudyStopDate'],
    '0x1011': ['TM', '1', 'ScheduledStudyStopTime'],
    '0x1020': ['LO', '1', 'ScheduledStudyLocation'],
    '0x1021': ['AE', '1-n', 'ScheduledStudyLocationAETitle'],
    '0x1030': ['LO', '1', 'ReasonForStudy'],
    '0x1031': ['SQ', '1', 'RequestingPhysicianIdentificationSequence'],
    '0x1032': ['PN', '1', 'RequestingPhysician'],
    '0x1033': ['LO', '1', 'RequestingService'],
    '0x1034': ['SQ', '1', 'RequestingServiceCodeSequence'],
    '0x1040': ['DA', '1', 'StudyArrivalDate'],
    '0x1041': ['TM', '1', 'StudyArrivalTime'],
    '0x1050': ['DA', '1', 'StudyCompletionDate'],
    '0x1051': ['TM', '1', 'StudyCompletionTime'],
    '0x1055': ['CS', '1', 'StudyComponentStatusID'],
    '0x1060': ['LO', '1', 'RequestedProcedureDescription'],
    '0x1064': ['SQ', '1', 'RequestedProcedureCodeSequence'],
    '0x1065': ['SQ', '1', 'RequestedLateralityCodeSequence'],
    '0x1066': ['UT', '1', 'ReasonForVisit'],
    '0x1067': ['SQ', '1', 'ReasonForVisitCodeSequence'],
    '0x1070': ['LO', '1', 'RequestedContrastAgent'],
    '0x4000': ['LT', '1', 'StudyComments']
  },
  '0x0034': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0001': ['SQ', '1', 'FlowIdentifierSequence'],
    '0x0002': ['OB', '1', 'FlowIdentifier'],
    '0x0003': ['UI', '1', 'FlowTransferSyntaxUID'],
    '0x0004': ['UL', '1', 'FlowRTPSamplingRate'],
    '0x0005': ['OB', '1', 'SourceIdentifier'],
    '0x0007': ['OB', '1', 'FrameOriginTimestamp'],
    '0x0008': ['CS', '1', 'IncludesImagingSubject'],
    '0x0009': ['SQ', '1', 'FrameUsefulnessGroupSequence'],
    '0x000A': ['SQ', '1', 'RealTimeBulkDataFlowSequence'],
    '0x000B': ['SQ', '1', 'CameraPositionGroupSequence'],
    '0x000C': ['CS', '1', 'IncludesInformation'],
    '0x000D': ['SQ', '1', 'TimeOfFrameGroupSequence']
  },
  '0x0038': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0004': ['SQ', '1', 'ReferencedPatientAliasSequence'],
    '0x0008': ['CS', '1', 'VisitStatusID'],
    '0x0010': ['LO', '1', 'AdmissionID'],
    '0x0011': ['LO', '1', 'IssuerOfAdmissionID'],
    '0x0014': ['SQ', '1', 'IssuerOfAdmissionIDSequence'],
    '0x0016': ['LO', '1', 'RouteOfAdmissions'],
    '0x001A': ['DA', '1', 'ScheduledAdmissionDate'],
    '0x001B': ['TM', '1', 'ScheduledAdmissionTime'],
    '0x001C': ['DA', '1', 'ScheduledDischargeDate'],
    '0x001D': ['TM', '1', 'ScheduledDischargeTime'],
    '0x001E': ['LO', '1', 'ScheduledPatientInstitutionResidence'],
    '0x0020': ['DA', '1', 'AdmittingDate'],
    '0x0021': ['TM', '1', 'AdmittingTime'],
    '0x0030': ['DA', '1', 'DischargeDate'],
    '0x0032': ['TM', '1', 'DischargeTime'],
    '0x0040': ['LO', '1', 'DischargeDiagnosisDescription'],
    '0x0044': ['SQ', '1', 'DischargeDiagnosisCodeSequence'],
    '0x0050': ['LO', '1', 'SpecialNeeds'],
    '0x0060': ['LO', '1', 'ServiceEpisodeID'],
    '0x0061': ['LO', '1', 'IssuerOfServiceEpisodeID'],
    '0x0062': ['LO', '1', 'ServiceEpisodeDescription'],
    '0x0064': ['SQ', '1', 'IssuerOfServiceEpisodeIDSequence'],
    '0x0100': ['SQ', '1', 'PertinentDocumentsSequence'],
    '0x0101': ['SQ', '1', 'PertinentResourcesSequence'],
    '0x0102': ['LO', '1', 'ResourceDescription'],
    '0x0300': ['LO', '1', 'CurrentPatientLocation'],
    '0x0400': ['LO', '1', 'PatientInstitutionResidence'],
    '0x0500': ['LO', '1', 'PatientState'],
    '0x0502': ['SQ', '1', 'PatientClinicalTrialParticipationSequence'],
    '0x4000': ['LT', '1', 'VisitComments']
  },
  '0x003A': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0004': ['CS', '1', 'WaveformOriginality'],
    '0x0005': ['US', '1', 'NumberOfWaveformChannels'],
    '0x0010': ['UL', '1', 'NumberOfWaveformSamples'],
    '0x001A': ['DS', '1', 'SamplingFrequency'],
    '0x0020': ['SH', '1', 'MultiplexGroupLabel'],
    '0x0200': ['SQ', '1', 'ChannelDefinitionSequence'],
    '0x0202': ['IS', '1', 'WaveformChannelNumber'],
    '0x0203': ['SH', '1', 'ChannelLabel'],
    '0x0205': ['CS', '1-n', 'ChannelStatus'],
    '0x0208': ['SQ', '1', 'ChannelSourceSequence'],
    '0x0209': ['SQ', '1', 'ChannelSourceModifiersSequence'],
    '0x020A': ['SQ', '1', 'SourceWaveformSequence'],
    '0x020C': ['LO', '1', 'ChannelDerivationDescription'],
    '0x0210': ['DS', '1', 'ChannelSensitivity'],
    '0x0211': ['SQ', '1', 'ChannelSensitivityUnitsSequence'],
    '0x0212': ['DS', '1', 'ChannelSensitivityCorrectionFactor'],
    '0x0213': ['DS', '1', 'ChannelBaseline'],
    '0x0214': ['DS', '1', 'ChannelTimeSkew'],
    '0x0215': ['DS', '1', 'ChannelSampleSkew'],
    '0x0218': ['DS', '1', 'ChannelOffset'],
    '0x021A': ['US', '1', 'WaveformBitsStored'],
    '0x0220': ['DS', '1', 'FilterLowFrequency'],
    '0x0221': ['DS', '1', 'FilterHighFrequency'],
    '0x0222': ['DS', '1', 'NotchFilterFrequency'],
    '0x0223': ['DS', '1', 'NotchFilterBandwidth'],
    '0x0230': ['FL', '1', 'WaveformDataDisplayScale'],
    '0x0231': ['US', '3', 'WaveformDisplayBackgroundCIELabValue'],
    '0x0240': ['SQ', '1', 'WaveformPresentationGroupSequence'],
    '0x0241': ['US', '1', 'PresentationGroupNumber'],
    '0x0242': ['SQ', '1', 'ChannelDisplaySequence'],
    '0x0244': ['US', '3', 'ChannelRecommendedDisplayCIELabValue'],
    '0x0245': ['FL', '1', 'ChannelPosition'],
    '0x0246': ['CS', '1', 'DisplayShadingFlag'],
    '0x0247': ['FL', '1', 'FractionalChannelDisplayScale'],
    '0x0248': ['FL', '1', 'AbsoluteChannelDisplayScale'],
    '0x0300': ['SQ', '1', 'MultiplexedAudioChannelsDescriptionCodeSequence'],
    '0x0301': ['IS', '1', 'ChannelIdentificationCode'],
    '0x0302': ['CS', '1', 'ChannelMode'],
    '0x0310': ['UI', '1', 'MultiplexGroupUID'],
    '0x0311': ['DS', '1', 'PowerlineFrequency'],
    '0x0312': ['SQ', '1', 'ChannelImpedanceSequence'],
    '0x0313': ['DS', '1', 'ImpedanceValue'],
    '0x0314': ['DT', '1', 'ImpedanceMeasurementDateTime'],
    '0x0315': ['DS', '1', 'ImpedanceMeasurementFrequency'],
    '0x0316': ['CS', '1', 'ImpedanceMeasurementCurrentType']
  },
  '0x0040': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0001': ['AE', '1-n', 'ScheduledStationAETitle'],
    '0x0002': ['DA', '1', 'ScheduledProcedureStepStartDate'],
    '0x0003': ['TM', '1', 'ScheduledProcedureStepStartTime'],
    '0x0004': ['DA', '1', 'ScheduledProcedureStepEndDate'],
    '0x0005': ['TM', '1', 'ScheduledProcedureStepEndTime'],
    '0x0006': ['PN', '1', 'ScheduledPerformingPhysicianName'],
    '0x0007': ['LO', '1', 'ScheduledProcedureStepDescription'],
    '0x0008': ['SQ', '1', 'ScheduledProtocolCodeSequence'],
    '0x0009': ['SH', '1', 'ScheduledProcedureStepID'],
    '0x000A': ['SQ', '1', 'StageCodeSequence'],
    '0x000B': ['SQ', '1', 'ScheduledPerformingPhysicianIdentificationSequence'],
    '0x0010': ['SH', '1-n', 'ScheduledStationName'],
    '0x0011': ['SH', '1', 'ScheduledProcedureStepLocation'],
    '0x0012': ['LO', '1', 'PreMedication'],
    '0x0020': ['CS', '1', 'ScheduledProcedureStepStatus'],
    '0x0026': ['SQ', '1', 'OrderPlacerIdentifierSequence'],
    '0x0027': ['SQ', '1', 'OrderFillerIdentifierSequence'],
    '0x0031': ['UT', '1', 'LocalNamespaceEntityID'],
    '0x0032': ['UT', '1', 'UniversalEntityID'],
    '0x0033': ['CS', '1', 'UniversalEntityIDType'],
    '0x0035': ['CS', '1', 'IdentifierTypeCode'],
    '0x0036': ['SQ', '1', 'AssigningFacilitySequence'],
    '0x0039': ['SQ', '1', 'AssigningJurisdictionCodeSequence'],
    '0x003A': ['SQ', '1', 'AssigningAgencyOrDepartmentCodeSequence'],
    '0x0100': ['SQ', '1', 'ScheduledProcedureStepSequence'],
    '0x0220': ['SQ', '1', 'ReferencedNonImageCompositeSOPInstanceSequence'],
    '0x0241': ['AE', '1', 'PerformedStationAETitle'],
    '0x0242': ['SH', '1', 'PerformedStationName'],
    '0x0243': ['SH', '1', 'PerformedLocation'],
    '0x0244': ['DA', '1', 'PerformedProcedureStepStartDate'],
    '0x0245': ['TM', '1', 'PerformedProcedureStepStartTime'],
    '0x0250': ['DA', '1', 'PerformedProcedureStepEndDate'],
    '0x0251': ['TM', '1', 'PerformedProcedureStepEndTime'],
    '0x0252': ['CS', '1', 'PerformedProcedureStepStatus'],
    '0x0253': ['SH', '1', 'PerformedProcedureStepID'],
    '0x0254': ['LO', '1', 'PerformedProcedureStepDescription'],
    '0x0255': ['LO', '1', 'PerformedProcedureTypeDescription'],
    '0x0260': ['SQ', '1', 'PerformedProtocolCodeSequence'],
    '0x0261': ['CS', '1', 'PerformedProtocolType'],
    '0x0270': ['SQ', '1', 'ScheduledStepAttributesSequence'],
    '0x0275': ['SQ', '1', 'RequestAttributesSequence'],
    '0x0280': ['ST', '1', 'CommentsOnThePerformedProcedureStep'],
    '0x0281': ['SQ', '1', 'PerformedProcedureStepDiscontinuationReasonCodeSequence'],
    '0x0293': ['SQ', '1', 'QuantitySequence'],
    '0x0294': ['DS', '1', 'Quantity'],
    '0x0295': ['SQ', '1', 'MeasuringUnitsSequence'],
    '0x0296': ['SQ', '1', 'BillingItemSequence'],
    '0x0300': ['US', '1', 'TotalTimeOfFluoroscopy'],
    '0x0301': ['US', '1', 'TotalNumberOfExposures'],
    '0x0302': ['US', '1', 'EntranceDose'],
    '0x0303': ['US', '1-2', 'ExposedArea'],
    '0x0306': ['DS', '1', 'DistanceSourceToEntrance'],
    '0x0307': ['DS', '1', 'DistanceSourceToSupport'],
    '0x030E': ['SQ', '1', 'ExposureDoseSequence'],
    '0x0310': ['ST', '1', 'CommentsOnRadiationDose'],
    '0x0312': ['DS', '1', 'XRayOutput'],
    '0x0314': ['DS', '1', 'HalfValueLayer'],
    '0x0316': ['DS', '1', 'OrganDose'],
    '0x0318': ['CS', '1', 'OrganExposed'],
    '0x0320': ['SQ', '1', 'BillingProcedureStepSequence'],
    '0x0321': ['SQ', '1', 'FilmConsumptionSequence'],
    '0x0324': ['SQ', '1', 'BillingSuppliesAndDevicesSequence'],
    '0x0330': ['SQ', '1', 'ReferencedProcedureStepSequence'],
    '0x0340': ['SQ', '1', 'PerformedSeriesSequence'],
    '0x0400': ['LT', '1', 'CommentsOnTheScheduledProcedureStep'],
    '0x0440': ['SQ', '1', 'ProtocolContextSequence'],
    '0x0441': ['SQ', '1', 'ContentItemModifierSequence'],
    '0x0500': ['SQ', '1', 'ScheduledSpecimenSequence'],
    '0x050A': ['LO', '1', 'SpecimenAccessionNumber'],
    '0x0512': ['LO', '1', 'ContainerIdentifier'],
    '0x0513': ['SQ', '1', 'IssuerOfTheContainerIdentifierSequence'],
    '0x0515': ['SQ', '1', 'AlternateContainerIdentifierSequence'],
    '0x0518': ['SQ', '1', 'ContainerTypeCodeSequence'],
    '0x051A': ['LO', '1', 'ContainerDescription'],
    '0x0520': ['SQ', '1', 'ContainerComponentSequence'],
    '0x0550': ['SQ', '1', 'SpecimenSequence'],
    '0x0551': ['LO', '1', 'SpecimenIdentifier'],
    '0x0552': ['SQ', '1', 'SpecimenDescriptionSequenceTrial'],
    '0x0553': ['ST', '1', 'SpecimenDescriptionTrial'],
    '0x0554': ['UI', '1', 'SpecimenUID'],
    '0x0555': ['SQ', '1', 'AcquisitionContextSequence'],
    '0x0556': ['ST', '1', 'AcquisitionContextDescription'],
    '0x0560': ['SQ', '1', 'SpecimenDescriptionSequence'],
    '0x0562': ['SQ', '1', 'IssuerOfTheSpecimenIdentifierSequence'],
    '0x059A': ['SQ', '1', 'SpecimenTypeCodeSequence'],
    '0x0600': ['LO', '1', 'SpecimenShortDescription'],
    '0x0602': ['UT', '1', 'SpecimenDetailedDescription'],
    '0x0610': ['SQ', '1', 'SpecimenPreparationSequence'],
    '0x0612': ['SQ', '1', 'SpecimenPreparationStepContentItemSequence'],
    '0x0620': ['SQ', '1', 'SpecimenLocalizationContentItemSequence'],
    '0x06FA': ['LO', '1', 'SlideIdentifier'],
    '0x0710': ['SQ', '1', 'WholeSlideMicroscopyImageFrameTypeSequence'],
    '0x071A': ['SQ', '1', 'ImageCenterPointCoordinatesSequence'],
    '0x072A': ['DS', '1', 'XOffsetInSlideCoordinateSystem'],
    '0x073A': ['DS', '1', 'YOffsetInSlideCoordinateSystem'],
    '0x074A': ['DS', '1', 'ZOffsetInSlideCoordinateSystem'],
    '0x08D8': ['SQ', '1', 'PixelSpacingSequence'],
    '0x08DA': ['SQ', '1', 'CoordinateSystemAxisCodeSequence'],
    '0x08EA': ['SQ', '1', 'MeasurementUnitsCodeSequence'],
    '0x09F8': ['SQ', '1', 'VitalStainCodeSequenceTrial'],
    '0x1001': ['SH', '1', 'RequestedProcedureID'],
    '0x1002': ['LO', '1', 'ReasonForTheRequestedProcedure'],
    '0x1003': ['SH', '1', 'RequestedProcedurePriority'],
    '0x1004': ['LO', '1', 'PatientTransportArrangements'],
    '0x1005': ['LO', '1', 'RequestedProcedureLocation'],
    '0x1006': ['SH', '1', 'PlacerOrderNumberProcedure'],
    '0x1007': ['SH', '1', 'FillerOrderNumberProcedure'],
    '0x1008': ['LO', '1', 'ConfidentialityCode'],
    '0x1009': ['SH', '1', 'ReportingPriority'],
    '0x100A': ['SQ', '1', 'ReasonForRequestedProcedureCodeSequence'],
    '0x1010': ['PN', '1-n', 'NamesOfIntendedRecipientsOfResults'],
    '0x1011': ['SQ', '1', 'IntendedRecipientsOfResultsIdentificationSequence'],
    '0x1012': ['SQ', '1', 'ReasonForPerformedProcedureCodeSequence'],
    '0x1060': ['LO', '1', 'RequestedProcedureDescriptionTrial'],
    '0x1101': ['SQ', '1', 'PersonIdentificationCodeSequence'],
    '0x1102': ['ST', '1', 'PersonAddress'],
    '0x1103': ['LO', '1-n', 'PersonTelephoneNumbers'],
    '0x1104': ['LT', '1', 'PersonTelecomInformation'],
    '0x1400': ['LT', '1', 'RequestedProcedureComments'],
    '0x2001': ['LO', '1', 'ReasonForTheImagingServiceRequest'],
    '0x2004': ['DA', '1', 'IssueDateOfImagingServiceRequest'],
    '0x2005': ['TM', '1', 'IssueTimeOfImagingServiceRequest'],
    '0x2006': ['SH', '1', 'PlacerOrderNumberImagingServiceRequestRetired'],
    '0x2007': ['SH', '1', 'FillerOrderNumberImagingServiceRequestRetired'],
    '0x2008': ['PN', '1', 'OrderEnteredBy'],
    '0x2009': ['SH', '1', 'OrderEntererLocation'],
    '0x2010': ['SH', '1', 'OrderCallbackPhoneNumber'],
    '0x2011': ['LT', '1', 'OrderCallbackTelecomInformation'],
    '0x2016': ['LO', '1', 'PlacerOrderNumberImagingServiceRequest'],
    '0x2017': ['LO', '1', 'FillerOrderNumberImagingServiceRequest'],
    '0x2400': ['LT', '1', 'ImagingServiceRequestComments'],
    '0x3001': ['LO', '1', 'ConfidentialityConstraintOnPatientDataDescription'],
    '0x4001': ['CS', '1', 'GeneralPurposeScheduledProcedureStepStatus'],
    '0x4002': ['CS', '1', 'GeneralPurposePerformedProcedureStepStatus'],
    '0x4003': ['CS', '1', 'GeneralPurposeScheduledProcedureStepPriority'],
    '0x4004': ['SQ', '1', 'ScheduledProcessingApplicationsCodeSequence'],
    '0x4005': ['DT', '1', 'ScheduledProcedureStepStartDateTime'],
    '0x4006': ['CS', '1', 'MultipleCopiesFlag'],
    '0x4007': ['SQ', '1', 'PerformedProcessingApplicationsCodeSequence'],
    '0x4008': ['DT', '1', 'ScheduledProcedureStepExpirationDateTime'],
    '0x4009': ['SQ', '1', 'HumanPerformerCodeSequence'],
    '0x4010': ['DT', '1', 'ScheduledProcedureStepModificationDateTime'],
    '0x4011': ['DT', '1', 'ExpectedCompletionDateTime'],
    '0x4015': ['SQ', '1', 'ResultingGeneralPurposePerformedProcedureStepsSequence'],
    '0x4016': ['SQ', '1', 'ReferencedGeneralPurposeScheduledProcedureStepSequence'],
    '0x4018': ['SQ', '1', 'ScheduledWorkitemCodeSequence'],
    '0x4019': ['SQ', '1', 'PerformedWorkitemCodeSequence'],
    '0x4020': ['CS', '1', 'InputAvailabilityFlag'],
    '0x4021': ['SQ', '1', 'InputInformationSequence'],
    '0x4022': ['SQ', '1', 'RelevantInformationSequence'],
    '0x4023': ['UI', '1', 'ReferencedGeneralPurposeScheduledProcedureStepTransactionUID'],
    '0x4025': ['SQ', '1', 'ScheduledStationNameCodeSequence'],
    '0x4026': ['SQ', '1', 'ScheduledStationClassCodeSequence'],
    '0x4027': ['SQ', '1', 'ScheduledStationGeographicLocationCodeSequence'],
    '0x4028': ['SQ', '1', 'PerformedStationNameCodeSequence'],
    '0x4029': ['SQ', '1', 'PerformedStationClassCodeSequence'],
    '0x4030': ['SQ', '1', 'PerformedStationGeographicLocationCodeSequence'],
    '0x4031': ['SQ', '1', 'RequestedSubsequentWorkitemCodeSequence'],
    '0x4032': ['SQ', '1', 'NonDICOMOutputCodeSequence'],
    '0x4033': ['SQ', '1', 'OutputInformationSequence'],
    '0x4034': ['SQ', '1', 'ScheduledHumanPerformersSequence'],
    '0x4035': ['SQ', '1', 'ActualHumanPerformersSequence'],
    '0x4036': ['LO', '1', 'HumanPerformerOrganization'],
    '0x4037': ['PN', '1', 'HumanPerformerName'],
    '0x4040': ['CS', '1', 'RawDataHandling'],
    '0x4041': ['CS', '1', 'InputReadinessState'],
    '0x4050': ['DT', '1', 'PerformedProcedureStepStartDateTime'],
    '0x4051': ['DT', '1', 'PerformedProcedureStepEndDateTime'],
    '0x4052': ['DT', '1', 'ProcedureStepCancellationDateTime'],
    '0x4070': ['SQ', '1', 'OutputDestinationSequence'],
    '0x4071': ['SQ', '1', 'DICOMStorageSequence'],
    '0x4072': ['SQ', '1', 'STOWRSStorageSequence'],
    '0x4073': ['UR', '1', 'StorageURL'],
    '0x4074': ['SQ', '1', 'XDSStorageSequence'],
    '0x8302': ['DS', '1', 'EntranceDoseInmGy'],
    '0x8303': ['CS', '1', 'EntranceDoseDerivation'],
    '0x9092': ['SQ', '1', 'ParametricMapFrameTypeSequence'],
    '0x9094': ['SQ', '1', 'ReferencedImageRealWorldValueMappingSequence'],
    '0x9096': ['SQ', '1', 'RealWorldValueMappingSequence'],
    '0x9098': ['SQ', '1', 'PixelValueMappingCodeSequence'],
    '0x9210': ['SH', '1', 'LUTLabel'],
    '0x9211': ['xs', '1', 'RealWorldValueLastValueMapped'],
    '0x9212': ['FD', '1-n', 'RealWorldValueLUTData'],
    '0x9213': ['FD', '1', 'DoubleFloatRealWorldValueLastValueMapped'],
    '0x9214': ['FD', '1', 'DoubleFloatRealWorldValueFirstValueMapped'],
    '0x9216': ['xs', '1', 'RealWorldValueFirstValueMapped'],
    '0x9220': ['SQ', '1', 'QuantityDefinitionSequence'],
    '0x9224': ['FD', '1', 'RealWorldValueIntercept'],
    '0x9225': ['FD', '1', 'RealWorldValueSlope'],
    '0xA007': ['CS', '1', 'FindingsFlagTrial'],
    '0xA010': ['CS', '1', 'RelationshipType'],
    '0xA020': ['SQ', '1', 'FindingsSequenceTrial'],
    '0xA021': ['UI', '1', 'FindingsGroupUIDTrial'],
    '0xA022': ['UI', '1', 'ReferencedFindingsGroupUIDTrial'],
    '0xA023': ['DA', '1', 'FindingsGroupRecordingDateTrial'],
    '0xA024': ['TM', '1', 'FindingsGroupRecordingTimeTrial'],
    '0xA026': ['SQ', '1', 'FindingsSourceCategoryCodeSequenceTrial'],
    '0xA027': ['LO', '1', 'VerifyingOrganization'],
    '0xA028': ['SQ', '1', 'DocumentingOrganizationIdentifierCodeSequenceTrial'],
    '0xA030': ['DT', '1', 'VerificationDateTime'],
    '0xA032': ['DT', '1', 'ObservationDateTime'],
    '0xA033': ['DT', '1', 'ObservationStartDateTime'],
    '0xA040': ['CS', '1', 'ValueType'],
    '0xA043': ['SQ', '1', 'ConceptNameCodeSequence'],
    '0xA047': ['LO', '1', 'MeasurementPrecisionDescriptionTrial'],
    '0xA050': ['CS', '1', 'ContinuityOfContent'],
    '0xA057': ['CS', '1-n', 'UrgencyOrPriorityAlertsTrial'],
    '0xA060': ['LO', '1', 'SequencingIndicatorTrial'],
    '0xA066': ['SQ', '1', 'DocumentIdentifierCodeSequenceTrial'],
    '0xA067': ['PN', '1', 'DocumentAuthorTrial'],
    '0xA068': ['SQ', '1', 'DocumentAuthorIdentifierCodeSequenceTrial'],
    '0xA070': ['SQ', '1', 'IdentifierCodeSequenceTrial'],
    '0xA073': ['SQ', '1', 'VerifyingObserverSequence'],
    '0xA074': ['OB', '1', 'ObjectBinaryIdentifierTrial'],
    '0xA075': ['PN', '1', 'VerifyingObserverName'],
    '0xA076': ['SQ', '1', 'DocumentingObserverIdentifierCodeSequenceTrial'],
    '0xA078': ['SQ', '1', 'AuthorObserverSequence'],
    '0xA07A': ['SQ', '1', 'ParticipantSequence'],
    '0xA07C': ['SQ', '1', 'CustodialOrganizationSequence'],
    '0xA080': ['CS', '1', 'ParticipationType'],
    '0xA082': ['DT', '1', 'ParticipationDateTime'],
    '0xA084': ['CS', '1', 'ObserverType'],
    '0xA085': ['SQ', '1', 'ProcedureIdentifierCodeSequenceTrial'],
    '0xA088': ['SQ', '1', 'VerifyingObserverIdentificationCodeSequence'],
    '0xA089': ['OB', '1', 'ObjectDirectoryBinaryIdentifierTrial'],
    '0xA090': ['SQ', '1', 'EquivalentCDADocumentSequence'],
    '0xA0B0': ['US', '2-2n', 'ReferencedWaveformChannels'],
    '0xA110': ['DA', '1', 'DateOfDocumentOrVerbalTransactionTrial'],
    '0xA112': ['TM', '1', 'TimeOfDocumentCreationOrVerbalTransactionTrial'],
    '0xA120': ['DT', '1', 'DateTime'],
    '0xA121': ['DA', '1', 'Date'],
    '0xA122': ['TM', '1', 'Time'],
    '0xA123': ['PN', '1', 'PersonName'],
    '0xA124': ['UI', '1', 'UID'],
    '0xA125': ['CS', '2', 'ReportStatusIDTrial'],
    '0xA130': ['CS', '1', 'TemporalRangeType'],
    '0xA132': ['UL', '1-n', 'ReferencedSamplePositions'],
    '0xA136': ['US', '1-n', 'ReferencedFrameNumbers'],
    '0xA138': ['DS', '1-n', 'ReferencedTimeOffsets'],
    '0xA13A': ['DT', '1-n', 'ReferencedDateTime'],
    '0xA160': ['UT', '1', 'TextValue'],
    '0xA161': ['FD', '1-n', 'FloatingPointValue'],
    '0xA162': ['SL', '1-n', 'RationalNumeratorValue'],
    '0xA163': ['UL', '1-n', 'RationalDenominatorValue'],
    '0xA167': ['SQ', '1', 'ObservationCategoryCodeSequenceTrial'],
    '0xA168': ['SQ', '1', 'ConceptCodeSequence'],
    '0xA16A': ['ST', '1', 'BibliographicCitationTrial'],
    '0xA170': ['SQ', '1', 'PurposeOfReferenceCodeSequence'],
    '0xA171': ['UI', '1', 'ObservationUID'],
    '0xA172': ['UI', '1', 'ReferencedObservationUIDTrial'],
    '0xA173': ['CS', '1', 'ReferencedObservationClassTrial'],
    '0xA174': ['CS', '1', 'ReferencedObjectObservationClassTrial'],
    '0xA180': ['US', '1', 'AnnotationGroupNumber'],
    '0xA192': ['DA', '1', 'ObservationDateTrial'],
    '0xA193': ['TM', '1', 'ObservationTimeTrial'],
    '0xA194': ['CS', '1', 'MeasurementAutomationTrial'],
    '0xA195': ['SQ', '1', 'ModifierCodeSequence'],
    '0xA224': ['ST', '1', 'IdentificationDescriptionTrial'],
    '0xA290': ['CS', '1', 'CoordinatesSetGeometricTypeTrial'],
    '0xA296': ['SQ', '1', 'AlgorithmCodeSequenceTrial'],
    '0xA297': ['ST', '1', 'AlgorithmDescriptionTrial'],
    '0xA29A': ['SL', '2-2n', 'PixelCoordinatesSetTrial'],
    '0xA300': ['SQ', '1', 'MeasuredValueSequence'],
    '0xA301': ['SQ', '1', 'NumericValueQualifierCodeSequence'],
    '0xA307': ['PN', '1', 'CurrentObserverTrial'],
    '0xA30A': ['DS', '1-n', 'NumericValue'],
    '0xA313': ['SQ', '1', 'ReferencedAccessionSequenceTrial'],
    '0xA33A': ['ST', '1', 'ReportStatusCommentTrial'],
    '0xA340': ['SQ', '1', 'ProcedureContextSequenceTrial'],
    '0xA352': ['PN', '1', 'VerbalSourceTrial'],
    '0xA353': ['ST', '1', 'AddressTrial'],
    '0xA354': ['LO', '1', 'TelephoneNumberTrial'],
    '0xA358': ['SQ', '1', 'VerbalSourceIdentifierCodeSequenceTrial'],
    '0xA360': ['SQ', '1', 'PredecessorDocumentsSequence'],
    '0xA370': ['SQ', '1', 'ReferencedRequestSequence'],
    '0xA372': ['SQ', '1', 'PerformedProcedureCodeSequence'],
    '0xA375': ['SQ', '1', 'CurrentRequestedProcedureEvidenceSequence'],
    '0xA380': ['SQ', '1', 'ReportDetailSequenceTrial'],
    '0xA385': ['SQ', '1', 'PertinentOtherEvidenceSequence'],
    '0xA390': ['SQ', '1', 'HL7StructuredDocumentReferenceSequence'],
    '0xA402': ['UI', '1', 'ObservationSubjectUIDTrial'],
    '0xA403': ['CS', '1', 'ObservationSubjectClassTrial'],
    '0xA404': ['SQ', '1', 'ObservationSubjectTypeCodeSequenceTrial'],
    '0xA491': ['CS', '1', 'CompletionFlag'],
    '0xA492': ['LO', '1', 'CompletionFlagDescription'],
    '0xA493': ['CS', '1', 'VerificationFlag'],
    '0xA494': ['CS', '1', 'ArchiveRequested'],
    '0xA496': ['CS', '1', 'PreliminaryFlag'],
    '0xA504': ['SQ', '1', 'ContentTemplateSequence'],
    '0xA525': ['SQ', '1', 'IdenticalDocumentsSequence'],
    '0xA600': ['CS', '1', 'ObservationSubjectContextFlagTrial'],
    '0xA601': ['CS', '1', 'ObserverContextFlagTrial'],
    '0xA603': ['CS', '1', 'ProcedureContextFlagTrial'],
    '0xA730': ['SQ', '1', 'ContentSequence'],
    '0xA731': ['SQ', '1', 'RelationshipSequenceTrial'],
    '0xA732': ['SQ', '1', 'RelationshipTypeCodeSequenceTrial'],
    '0xA744': ['SQ', '1', 'LanguageCodeSequenceTrial'],
    '0xA801': ['SQ', '1', 'TabulatedValuesSequence'],
    '0xA802': ['UL', '1', 'NumberOfTableRows'],
    '0xA803': ['UL', '1', 'NumberOfTableColumns'],
    '0xA804': ['UL', '1', 'TableRowNumber'],
    '0xA805': ['UL', '1', 'TableColumnNumber'],
    '0xA806': ['SQ', '1', 'TableRowDefinitionSequence'],
    '0xA807': ['SQ', '1', 'TableColumnDefinitionSequence'],
    '0xA808': ['SQ', '1', 'CellValuesSequence'],
    '0xA992': ['ST', '1', 'UniformResourceLocatorTrial'],
    '0xB020': ['SQ', '1', 'WaveformAnnotationSequence'],
    '0xDB00': ['CS', '1', 'TemplateIdentifier'],
    '0xDB06': ['DT', '1', 'TemplateVersion'],
    '0xDB07': ['DT', '1', 'TemplateLocalVersion'],
    '0xDB0B': ['CS', '1', 'TemplateExtensionFlag'],
    '0xDB0C': ['UI', '1', 'TemplateExtensionOrganizationUID'],
    '0xDB0D': ['UI', '1', 'TemplateExtensionCreatorUID'],
    '0xDB73': ['UL', '1-n', 'ReferencedContentItemIdentifier'],
    '0xE001': ['ST', '1', 'HL7InstanceIdentifier'],
    '0xE004': ['DT', '1', 'HL7DocumentEffectiveTime'],
    '0xE006': ['SQ', '1', 'HL7DocumentTypeCodeSequence'],
    '0xE008': ['SQ', '1', 'DocumentClassCodeSequence'],
    '0xE010': ['UR', '1', 'RetrieveURI'],
    '0xE011': ['UI', '1', 'RetrieveLocationUID'],
    '0xE020': ['CS', '1', 'TypeOfInstances'],
    '0xE021': ['SQ', '1', 'DICOMRetrievalSequence'],
    '0xE022': ['SQ', '1', 'DICOMMediaRetrievalSequence'],
    '0xE023': ['SQ', '1', 'WADORetrievalSequence'],
    '0xE024': ['SQ', '1', 'XDSRetrievalSequence'],
    '0xE025': ['SQ', '1', 'WADORSRetrievalSequence'],
    '0xE030': ['UI', '1', 'RepositoryUniqueID'],
    '0xE031': ['UI', '1', 'HomeCommunityID']
  },
  '0x0042': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0010': ['ST', '1', 'DocumentTitle'],
    '0x0011': ['OB', '1', 'EncapsulatedDocument'],
    '0x0012': ['LO', '1', 'MIMETypeOfEncapsulatedDocument'],
    '0x0013': ['SQ', '1', 'SourceInstanceSequence'],
    '0x0014': ['LO', '1-n', 'ListOfMIMETypes'],
    '0x0015': ['UL', '1', 'EncapsulatedDocumentLength']
  },
  '0x0044': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0001': ['ST', '1', 'ProductPackageIdentifier'],
    '0x0002': ['CS', '1', 'SubstanceAdministrationApproval'],
    '0x0003': ['LT', '1', 'ApprovalStatusFurtherDescription'],
    '0x0004': ['DT', '1', 'ApprovalStatusDateTime'],
    '0x0007': ['SQ', '1', 'ProductTypeCodeSequence'],
    '0x0008': ['LO', '1-n', 'ProductName'],
    '0x0009': ['LT', '1', 'ProductDescription'],
    '0x000A': ['LO', '1', 'ProductLotIdentifier'],
    '0x000B': ['DT', '1', 'ProductExpirationDateTime'],
    '0x0010': ['DT', '1', 'SubstanceAdministrationDateTime'],
    '0x0011': ['LO', '1', 'SubstanceAdministrationNotes'],
    '0x0012': ['LO', '1', 'SubstanceAdministrationDeviceID'],
    '0x0013': ['SQ', '1', 'ProductParameterSequence'],
    '0x0019': ['SQ', '1', 'SubstanceAdministrationParameterSequence'],
    '0x0100': ['SQ', '1', 'ApprovalSequence'],
    '0x0101': ['SQ', '1', 'AssertionCodeSequence'],
    '0x0102': ['UI', '1', 'AssertionUID'],
    '0x0103': ['SQ', '1', 'AsserterIdentificationSequence'],
    '0x0104': ['DT', '1', 'AssertionDateTime'],
    '0x0105': ['DT', '1', 'AssertionExpirationDateTime'],
    '0x0106': ['UT', '1', 'AssertionComments'],
    '0x0107': ['SQ', '1', 'RelatedAssertionSequence'],
    '0x0108': ['UI', '1', 'ReferencedAssertionUID'],
    '0x0109': ['SQ', '1', 'ApprovalSubjectSequence'],
    '0x010A': ['SQ', '1', 'OrganizationalRoleCodeSequence']
  },
  '0x0046': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0012': ['LO', '1', 'LensDescription'],
    '0x0014': ['SQ', '1', 'RightLensSequence'],
    '0x0015': ['SQ', '1', 'LeftLensSequence'],
    '0x0016': ['SQ', '1', 'UnspecifiedLateralityLensSequence'],
    '0x0018': ['SQ', '1', 'CylinderSequence'],
    '0x0028': ['SQ', '1', 'PrismSequence'],
    '0x0030': ['FD', '1', 'HorizontalPrismPower'],
    '0x0032': ['CS', '1', 'HorizontalPrismBase'],
    '0x0034': ['FD', '1', 'VerticalPrismPower'],
    '0x0036': ['CS', '1', 'VerticalPrismBase'],
    '0x0038': ['CS', '1', 'LensSegmentType'],
    '0x0040': ['FD', '1', 'OpticalTransmittance'],
    '0x0042': ['FD', '1', 'ChannelWidth'],
    '0x0044': ['FD', '1', 'PupilSize'],
    '0x0046': ['FD', '1', 'CornealSize'],
    '0x0047': ['SQ', '1', 'CornealSizeSequence'],
    '0x0050': ['SQ', '1', 'AutorefractionRightEyeSequence'],
    '0x0052': ['SQ', '1', 'AutorefractionLeftEyeSequence'],
    '0x0060': ['FD', '1', 'DistancePupillaryDistance'],
    '0x0062': ['FD', '1', 'NearPupillaryDistance'],
    '0x0063': ['FD', '1', 'IntermediatePupillaryDistance'],
    '0x0064': ['FD', '1', 'OtherPupillaryDistance'],
    '0x0070': ['SQ', '1', 'KeratometryRightEyeSequence'],
    '0x0071': ['SQ', '1', 'KeratometryLeftEyeSequence'],
    '0x0074': ['SQ', '1', 'SteepKeratometricAxisSequence'],
    '0x0075': ['FD', '1', 'RadiusOfCurvature'],
    '0x0076': ['FD', '1', 'KeratometricPower'],
    '0x0077': ['FD', '1', 'KeratometricAxis'],
    '0x0080': ['SQ', '1', 'FlatKeratometricAxisSequence'],
    '0x0092': ['CS', '1', 'BackgroundColor'],
    '0x0094': ['CS', '1', 'Optotype'],
    '0x0095': ['CS', '1', 'OptotypePresentation'],
    '0x0097': ['SQ', '1', 'SubjectiveRefractionRightEyeSequence'],
    '0x0098': ['SQ', '1', 'SubjectiveRefractionLeftEyeSequence'],
    '0x0100': ['SQ', '1', 'AddNearSequence'],
    '0x0101': ['SQ', '1', 'AddIntermediateSequence'],
    '0x0102': ['SQ', '1', 'AddOtherSequence'],
    '0x0104': ['FD', '1', 'AddPower'],
    '0x0106': ['FD', '1', 'ViewingDistance'],
    '0x0110': ['SQ', '1', 'CorneaMeasurementsSequence'],
    '0x0111': ['SQ', '1', 'SourceOfCorneaMeasurementDataCodeSequence'],
    '0x0112': ['SQ', '1', 'SteepCornealAxisSequence'],
    '0x0113': ['SQ', '1', 'FlatCornealAxisSequence'],
    '0x0114': ['FD', '1', 'CornealPower'],
    '0x0115': ['FD', '1', 'CornealAxis'],
    '0x0116': ['SQ', '1', 'CorneaMeasurementMethodCodeSequence'],
    '0x0117': ['FL', '1', 'RefractiveIndexOfCornea'],
    '0x0118': ['FL', '1', 'RefractiveIndexOfAqueousHumor'],
    '0x0121': ['SQ', '1', 'VisualAcuityTypeCodeSequence'],
    '0x0122': ['SQ', '1', 'VisualAcuityRightEyeSequence'],
    '0x0123': ['SQ', '1', 'VisualAcuityLeftEyeSequence'],
    '0x0124': ['SQ', '1', 'VisualAcuityBothEyesOpenSequence'],
    '0x0125': ['CS', '1', 'ViewingDistanceType'],
    '0x0135': ['SS', '2', 'VisualAcuityModifiers'],
    '0x0137': ['FD', '1', 'DecimalVisualAcuity'],
    '0x0139': ['LO', '1', 'OptotypeDetailedDefinition'],
    '0x0145': ['SQ', '1', 'ReferencedRefractiveMeasurementsSequence'],
    '0x0146': ['FD', '1', 'SpherePower'],
    '0x0147': ['FD', '1', 'CylinderPower'],
    '0x0201': ['CS', '1', 'CornealTopographySurface'],
    '0x0202': ['FL', '2', 'CornealVertexLocation'],
    '0x0203': ['FL', '1', 'PupilCentroidXCoordinate'],
    '0x0204': ['FL', '1', 'PupilCentroidYCoordinate'],
    '0x0205': ['FL', '1', 'EquivalentPupilRadius'],
    '0x0207': ['SQ', '1', 'CornealTopographyMapTypeCodeSequence'],
    '0x0208': ['IS', '2-2n', 'VerticesOfTheOutlineOfPupil'],
    '0x0210': ['SQ', '1', 'CornealTopographyMappingNormalsSequence'],
    '0x0211': ['SQ', '1', 'MaximumCornealCurvatureSequence'],
    '0x0212': ['FL', '1', 'MaximumCornealCurvature'],
    '0x0213': ['FL', '2', 'MaximumCornealCurvatureLocation'],
    '0x0215': ['SQ', '1', 'MinimumKeratometricSequence'],
    '0x0218': ['SQ', '1', 'SimulatedKeratometricCylinderSequence'],
    '0x0220': ['FL', '1', 'AverageCornealPower'],
    '0x0224': ['FL', '1', 'CornealISValue'],
    '0x0227': ['FL', '1', 'AnalyzedArea'],
    '0x0230': ['FL', '1', 'SurfaceRegularityIndex'],
    '0x0232': ['FL', '1', 'SurfaceAsymmetryIndex'],
    '0x0234': ['FL', '1', 'CornealEccentricityIndex'],
    '0x0236': ['FL', '1', 'KeratoconusPredictionIndex'],
    '0x0238': ['FL', '1', 'DecimalPotentialVisualAcuity'],
    '0x0242': ['CS', '1', 'CornealTopographyMapQualityEvaluation'],
    '0x0244': ['SQ', '1', 'SourceImageCornealProcessedDataSequence'],
    '0x0247': ['FL', '3', 'CornealPointLocation'],
    '0x0248': ['CS', '1', 'CornealPointEstimated'],
    '0x0249': ['FL', '1', 'AxialPower'],
    '0x0250': ['FL', '1', 'TangentialPower'],
    '0x0251': ['FL', '1', 'RefractivePower'],
    '0x0252': ['FL', '1', 'RelativeElevation'],
    '0x0253': ['FL', '1', 'CornealWavefront']
  },
  '0x0048': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0001': ['FL', '1', 'ImagedVolumeWidth'],
    '0x0002': ['FL', '1', 'ImagedVolumeHeight'],
    '0x0003': ['FL', '1', 'ImagedVolumeDepth'],
    '0x0006': ['UL', '1', 'TotalPixelMatrixColumns'],
    '0x0007': ['UL', '1', 'TotalPixelMatrixRows'],
    '0x0008': ['SQ', '1', 'TotalPixelMatrixOriginSequence'],
    '0x0010': ['CS', '1', 'SpecimenLabelInImage'],
    '0x0011': ['CS', '1', 'FocusMethod'],
    '0x0012': ['CS', '1', 'ExtendedDepthOfField'],
    '0x0013': ['US', '1', 'NumberOfFocalPlanes'],
    '0x0014': ['FL', '1', 'DistanceBetweenFocalPlanes'],
    '0x0015': ['US', '3', 'RecommendedAbsentPixelCIELabValue'],
    '0x0100': ['SQ', '1', 'IlluminatorTypeCodeSequence'],
    '0x0102': ['DS', '6', 'ImageOrientationSlide'],
    '0x0105': ['SQ', '1', 'OpticalPathSequence'],
    '0x0106': ['SH', '1', 'OpticalPathIdentifier'],
    '0x0107': ['ST', '1', 'OpticalPathDescription'],
    '0x0108': ['SQ', '1', 'IlluminationColorCodeSequence'],
    '0x0110': ['SQ', '1', 'SpecimenReferenceSequence'],
    '0x0111': ['DS', '1', 'CondenserLensPower'],
    '0x0112': ['DS', '1', 'ObjectiveLensPower'],
    '0x0113': ['DS', '1', 'ObjectiveLensNumericalAperture'],
    '0x0120': ['SQ', '1', 'PaletteColorLookupTableSequence'],
    '0x0200': ['SQ', '1', 'ReferencedImageNavigationSequence'],
    '0x0201': ['US', '2', 'TopLeftHandCornerOfLocalizerArea'],
    '0x0202': ['US', '2', 'BottomRightHandCornerOfLocalizerArea'],
    '0x0207': ['SQ', '1', 'OpticalPathIdentificationSequence'],
    '0x021A': ['SQ', '1', 'PlanePositionSlideSequence'],
    '0x021E': ['SL', '1', 'ColumnPositionInTotalImagePixelMatrix'],
    '0x021F': ['SL', '1', 'RowPositionInTotalImagePixelMatrix'],
    '0x0301': ['CS', '1', 'PixelOriginInterpretation'],
    '0x0302': ['UL', '1', 'NumberOfOpticalPaths'],
    '0x0303': ['UL', '1', 'TotalPixelMatrixFocalPlanes']
  },
  '0x0050': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0004': ['CS', '1', 'CalibrationImage'],
    '0x0010': ['SQ', '1', 'DeviceSequence'],
    '0x0012': ['SQ', '1', 'ContainerComponentTypeCodeSequence'],
    '0x0013': ['FD', '1', 'ContainerComponentThickness'],
    '0x0014': ['DS', '1', 'DeviceLength'],
    '0x0015': ['FD', '1', 'ContainerComponentWidth'],
    '0x0016': ['DS', '1', 'DeviceDiameter'],
    '0x0017': ['CS', '1', 'DeviceDiameterUnits'],
    '0x0018': ['DS', '1', 'DeviceVolume'],
    '0x0019': ['DS', '1', 'InterMarkerDistance'],
    '0x001A': ['CS', '1', 'ContainerComponentMaterial'],
    '0x001B': ['LO', '1', 'ContainerComponentID'],
    '0x001C': ['FD', '1', 'ContainerComponentLength'],
    '0x001D': ['FD', '1', 'ContainerComponentDiameter'],
    '0x001E': ['LO', '1', 'ContainerComponentDescription'],
    '0x0020': ['LO', '1', 'DeviceDescription'],
    '0x0021': ['ST', '1', 'LongDeviceDescription']
  },
  '0x0052': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0001': ['FL', '1', 'ContrastBolusIngredientPercentByVolume'],
    '0x0002': ['FD', '1', 'OCTFocalDistance'],
    '0x0003': ['FD', '1', 'BeamSpotSize'],
    '0x0004': ['FD', '1', 'EffectiveRefractiveIndex'],
    '0x0006': ['CS', '1', 'OCTAcquisitionDomain'],
    '0x0007': ['FD', '1', 'OCTOpticalCenterWavelength'],
    '0x0008': ['FD', '1', 'AxialResolution'],
    '0x0009': ['FD', '1', 'RangingDepth'],
    '0x0011': ['FD', '1', 'ALineRate'],
    '0x0012': ['US', '1', 'ALinesPerFrame'],
    '0x0013': ['FD', '1', 'CatheterRotationalRate'],
    '0x0014': ['FD', '1', 'ALinePixelSpacing'],
    '0x0016': ['SQ', '1', 'ModeOfPercutaneousAccessSequence'],
    '0x0025': ['SQ', '1', 'IntravascularOCTFrameTypeSequence'],
    '0x0026': ['CS', '1', 'OCTZOffsetApplied'],
    '0x0027': ['SQ', '1', 'IntravascularFrameContentSequence'],
    '0x0028': ['FD', '1', 'IntravascularLongitudinalDistance'],
    '0x0029': ['SQ', '1', 'IntravascularOCTFrameContentSequence'],
    '0x0030': ['SS', '1', 'OCTZOffsetCorrection'],
    '0x0031': ['CS', '1', 'CatheterDirectionOfRotation'],
    '0x0033': ['FD', '1', 'SeamLineLocation'],
    '0x0034': ['FD', '1', 'FirstALineLocation'],
    '0x0036': ['US', '1', 'SeamLineIndex'],
    '0x0038': ['US', '1', 'NumberOfPaddedALines'],
    '0x0039': ['CS', '1', 'InterpolationType'],
    '0x003A': ['CS', '1', 'RefractiveIndexApplied']
  },
  '0x0054': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0010': ['US', '1-n', 'EnergyWindowVector'],
    '0x0011': ['US', '1', 'NumberOfEnergyWindows'],
    '0x0012': ['SQ', '1', 'EnergyWindowInformationSequence'],
    '0x0013': ['SQ', '1', 'EnergyWindowRangeSequence'],
    '0x0014': ['DS', '1', 'EnergyWindowLowerLimit'],
    '0x0015': ['DS', '1', 'EnergyWindowUpperLimit'],
    '0x0016': ['SQ', '1', 'RadiopharmaceuticalInformationSequence'],
    '0x0017': ['IS', '1', 'ResidualSyringeCounts'],
    '0x0018': ['SH', '1', 'EnergyWindowName'],
    '0x0020': ['US', '1-n', 'DetectorVector'],
    '0x0021': ['US', '1', 'NumberOfDetectors'],
    '0x0022': ['SQ', '1', 'DetectorInformationSequence'],
    '0x0030': ['US', '1-n', 'PhaseVector'],
    '0x0031': ['US', '1', 'NumberOfPhases'],
    '0x0032': ['SQ', '1', 'PhaseInformationSequence'],
    '0x0033': ['US', '1', 'NumberOfFramesInPhase'],
    '0x0036': ['IS', '1', 'PhaseDelay'],
    '0x0038': ['IS', '1', 'PauseBetweenFrames'],
    '0x0039': ['CS', '1', 'PhaseDescription'],
    '0x0050': ['US', '1-n', 'RotationVector'],
    '0x0051': ['US', '1', 'NumberOfRotations'],
    '0x0052': ['SQ', '1', 'RotationInformationSequence'],
    '0x0053': ['US', '1', 'NumberOfFramesInRotation'],
    '0x0060': ['US', '1-n', 'RRIntervalVector'],
    '0x0061': ['US', '1', 'NumberOfRRIntervals'],
    '0x0062': ['SQ', '1', 'GatedInformationSequence'],
    '0x0063': ['SQ', '1', 'DataInformationSequence'],
    '0x0070': ['US', '1-n', 'TimeSlotVector'],
    '0x0071': ['US', '1', 'NumberOfTimeSlots'],
    '0x0072': ['SQ', '1', 'TimeSlotInformationSequence'],
    '0x0073': ['DS', '1', 'TimeSlotTime'],
    '0x0080': ['US', '1-n', 'SliceVector'],
    '0x0081': ['US', '1', 'NumberOfSlices'],
    '0x0090': ['US', '1-n', 'AngularViewVector'],
    '0x0100': ['US', '1-n', 'TimeSliceVector'],
    '0x0101': ['US', '1', 'NumberOfTimeSlices'],
    '0x0200': ['DS', '1', 'StartAngle'],
    '0x0202': ['CS', '1', 'TypeOfDetectorMotion'],
    '0x0210': ['IS', '1-n', 'TriggerVector'],
    '0x0211': ['US', '1', 'NumberOfTriggersInPhase'],
    '0x0220': ['SQ', '1', 'ViewCodeSequence'],
    '0x0222': ['SQ', '1', 'ViewModifierCodeSequence'],
    '0x0300': ['SQ', '1', 'RadionuclideCodeSequence'],
    '0x0302': ['SQ', '1', 'AdministrationRouteCodeSequence'],
    '0x0304': ['SQ', '1', 'RadiopharmaceuticalCodeSequence'],
    '0x0306': ['SQ', '1', 'CalibrationDataSequence'],
    '0x0308': ['US', '1', 'EnergyWindowNumber'],
    '0x0400': ['SH', '1', 'ImageID'],
    '0x0410': ['SQ', '1', 'PatientOrientationCodeSequence'],
    '0x0412': ['SQ', '1', 'PatientOrientationModifierCodeSequence'],
    '0x0414': ['SQ', '1', 'PatientGantryRelationshipCodeSequence'],
    '0x0500': ['CS', '1', 'SliceProgressionDirection'],
    '0x0501': ['CS', '1', 'ScanProgressionDirection'],
    '0x1000': ['CS', '2', 'SeriesType'],
    '0x1001': ['CS', '1', 'Units'],
    '0x1002': ['CS', '1', 'CountsSource'],
    '0x1004': ['CS', '1', 'ReprojectionMethod'],
    '0x1006': ['CS', '1', 'SUVType'],
    '0x1100': ['CS', '1', 'RandomsCorrectionMethod'],
    '0x1101': ['LO', '1', 'AttenuationCorrectionMethod'],
    '0x1102': ['CS', '1', 'DecayCorrection'],
    '0x1103': ['LO', '1', 'ReconstructionMethod'],
    '0x1104': ['LO', '1', 'DetectorLinesOfResponseUsed'],
    '0x1105': ['LO', '1', 'ScatterCorrectionMethod'],
    '0x1200': ['DS', '1', 'AxialAcceptance'],
    '0x1201': ['IS', '2', 'AxialMash'],
    '0x1202': ['IS', '1', 'TransverseMash'],
    '0x1203': ['DS', '2', 'DetectorElementSize'],
    '0x1210': ['DS', '1', 'CoincidenceWindowWidth'],
    '0x1220': ['CS', '1-n', 'SecondaryCountsType'],
    '0x1300': ['DS', '1', 'FrameReferenceTime'],
    '0x1310': ['IS', '1', 'PrimaryPromptsCountsAccumulated'],
    '0x1311': ['IS', '1-n', 'SecondaryCountsAccumulated'],
    '0x1320': ['DS', '1', 'SliceSensitivityFactor'],
    '0x1321': ['DS', '1', 'DecayFactor'],
    '0x1322': ['DS', '1', 'DoseCalibrationFactor'],
    '0x1323': ['DS', '1', 'ScatterFractionFactor'],
    '0x1324': ['DS', '1', 'DeadTimeFactor'],
    '0x1330': ['US', '1', 'ImageIndex'],
    '0x1400': ['CS', '1-n', 'CountsIncluded'],
    '0x1401': ['CS', '1', 'DeadTimeCorrectionFlag']
  },
  '0x0060': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x3000': ['SQ', '1', 'HistogramSequence'],
    '0x3002': ['US', '1', 'HistogramNumberOfBins'],
    '0x3004': ['xs', '1', 'HistogramFirstBinValue'],
    '0x3006': ['xs', '1', 'HistogramLastBinValue'],
    '0x3008': ['US', '1', 'HistogramBinWidth'],
    '0x3010': ['LO', '1', 'HistogramExplanation'],
    '0x3020': ['UL', '1-n', 'HistogramData']
  },
  '0x0062': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0001': ['CS', '1', 'SegmentationType'],
    '0x0002': ['SQ', '1', 'SegmentSequence'],
    '0x0003': ['SQ', '1', 'SegmentedPropertyCategoryCodeSequence'],
    '0x0004': ['US', '1', 'SegmentNumber'],
    '0x0005': ['LO', '1', 'SegmentLabel'],
    '0x0006': ['ST', '1', 'SegmentDescription'],
    '0x0007': ['SQ', '1', 'SegmentationAlgorithmIdentificationSequence'],
    '0x0008': ['CS', '1', 'SegmentAlgorithmType'],
    '0x0009': ['LO', '1-n', 'SegmentAlgorithmName'],
    '0x000A': ['SQ', '1', 'SegmentIdentificationSequence'],
    '0x000B': ['US', '1-n', 'ReferencedSegmentNumber'],
    '0x000C': ['US', '1', 'RecommendedDisplayGrayscaleValue'],
    '0x000D': ['US', '3', 'RecommendedDisplayCIELabValue'],
    '0x000E': ['US', '1', 'MaximumFractionalValue'],
    '0x000F': ['SQ', '1', 'SegmentedPropertyTypeCodeSequence'],
    '0x0010': ['CS', '1', 'SegmentationFractionalType'],
    '0x0011': ['SQ', '1', 'SegmentedPropertyTypeModifierCodeSequence'],
    '0x0012': ['SQ', '1', 'UsedSegmentsSequence'],
    '0x0013': ['CS', '1', 'SegmentsOverlap'],
    '0x0020': ['UT', '1', 'TrackingID'],
    '0x0021': ['UI', '1', 'TrackingUID']
  },
  '0x0064': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0002': ['SQ', '1', 'DeformableRegistrationSequence'],
    '0x0003': ['UI', '1', 'SourceFrameOfReferenceUID'],
    '0x0005': ['SQ', '1', 'DeformableRegistrationGridSequence'],
    '0x0007': ['UL', '3', 'GridDimensions'],
    '0x0008': ['FD', '3', 'GridResolution'],
    '0x0009': ['OF', '1', 'VectorGridData'],
    '0x000F': ['SQ', '1', 'PreDeformationMatrixRegistrationSequence'],
    '0x0010': ['SQ', '1', 'PostDeformationMatrixRegistrationSequence']
  },
  '0x0066': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0001': ['UL', '1', 'NumberOfSurfaces'],
    '0x0002': ['SQ', '1', 'SurfaceSequence'],
    '0x0003': ['UL', '1', 'SurfaceNumber'],
    '0x0004': ['LT', '1', 'SurfaceComments'],
    '0x0009': ['CS', '1', 'SurfaceProcessing'],
    '0x000A': ['FL', '1', 'SurfaceProcessingRatio'],
    '0x000B': ['LO', '1', 'SurfaceProcessingDescription'],
    '0x000C': ['FL', '1', 'RecommendedPresentationOpacity'],
    '0x000D': ['CS', '1', 'RecommendedPresentationType'],
    '0x000E': ['CS', '1', 'FiniteVolume'],
    '0x0010': ['CS', '1', 'Manifold'],
    '0x0011': ['SQ', '1', 'SurfacePointsSequence'],
    '0x0012': ['SQ', '1', 'SurfacePointsNormalsSequence'],
    '0x0013': ['SQ', '1', 'SurfaceMeshPrimitivesSequence'],
    '0x0015': ['UL', '1', 'NumberOfSurfacePoints'],
    '0x0016': ['OF', '1', 'PointCoordinatesData'],
    '0x0017': ['FL', '3', 'PointPositionAccuracy'],
    '0x0018': ['FL', '1', 'MeanPointDistance'],
    '0x0019': ['FL', '1', 'MaximumPointDistance'],
    '0x001A': ['FL', '6', 'PointsBoundingBoxCoordinates'],
    '0x001B': ['FL', '3', 'AxisOfRotation'],
    '0x001C': ['FL', '3', 'CenterOfRotation'],
    '0x001E': ['UL', '1', 'NumberOfVectors'],
    '0x001F': ['US', '1', 'VectorDimensionality'],
    '0x0020': ['FL', '1-n', 'VectorAccuracy'],
    '0x0021': ['OF', '1', 'VectorCoordinateData'],
    '0x0022': ['OD', '1', 'DoublePointCoordinatesData'],
    '0x0023': ['OW', '1', 'TrianglePointIndexList'],
    '0x0024': ['OW', '1', 'EdgePointIndexList'],
    '0x0025': ['OW', '1', 'VertexPointIndexList'],
    '0x0026': ['SQ', '1', 'TriangleStripSequence'],
    '0x0027': ['SQ', '1', 'TriangleFanSequence'],
    '0x0028': ['SQ', '1', 'LineSequence'],
    '0x0029': ['OW', '1', 'PrimitivePointIndexList'],
    '0x002A': ['UL', '1', 'SurfaceCount'],
    '0x002B': ['SQ', '1', 'ReferencedSurfaceSequence'],
    '0x002C': ['UL', '1', 'ReferencedSurfaceNumber'],
    '0x002D': ['SQ', '1', 'SegmentSurfaceGenerationAlgorithmIdentificationSequence'],
    '0x002E': ['SQ', '1', 'SegmentSurfaceSourceInstanceSequence'],
    '0x002F': ['SQ', '1', 'AlgorithmFamilyCodeSequence'],
    '0x0030': ['SQ', '1', 'AlgorithmNameCodeSequence'],
    '0x0031': ['LO', '1', 'AlgorithmVersion'],
    '0x0032': ['LT', '1', 'AlgorithmParameters'],
    '0x0034': ['SQ', '1', 'FacetSequence'],
    '0x0035': ['SQ', '1', 'SurfaceProcessingAlgorithmIdentificationSequence'],
    '0x0036': ['LO', '1', 'AlgorithmName'],
    '0x0037': ['FL', '1', 'RecommendedPointRadius'],
    '0x0038': ['FL', '1', 'RecommendedLineThickness'],
    '0x0040': ['OL', '1', 'LongPrimitivePointIndexList'],
    '0x0041': ['OL', '1', 'LongTrianglePointIndexList'],
    '0x0042': ['OL', '1', 'LongEdgePointIndexList'],
    '0x0043': ['OL', '1', 'LongVertexPointIndexList'],
    '0x0101': ['SQ', '1', 'TrackSetSequence'],
    '0x0102': ['SQ', '1', 'TrackSequence'],
    '0x0103': ['OW', '1', 'RecommendedDisplayCIELabValueList'],
    '0x0104': ['SQ', '1', 'TrackingAlgorithmIdentificationSequence'],
    '0x0105': ['UL', '1', 'TrackSetNumber'],
    '0x0106': ['LO', '1', 'TrackSetLabel'],
    '0x0107': ['UT', '1', 'TrackSetDescription'],
    '0x0108': ['SQ', '1', 'TrackSetAnatomicalTypeCodeSequence'],
    '0x0121': ['SQ', '1', 'MeasurementsSequence'],
    '0x0124': ['SQ', '1', 'TrackSetStatisticsSequence'],
    '0x0125': ['OF', '1', 'FloatingPointValues'],
    '0x0129': ['OL', '1', 'TrackPointIndexList'],
    '0x0130': ['SQ', '1', 'TrackStatisticsSequence'],
    '0x0132': ['SQ', '1', 'MeasurementValuesSequence'],
    '0x0133': ['SQ', '1', 'DiffusionAcquisitionCodeSequence'],
    '0x0134': ['SQ', '1', 'DiffusionModelCodeSequence']
  },
  '0x0068': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x6210': ['LO', '1', 'ImplantSize'],
    '0x6221': ['LO', '1', 'ImplantTemplateVersion'],
    '0x6222': ['SQ', '1', 'ReplacedImplantTemplateSequence'],
    '0x6223': ['CS', '1', 'ImplantType'],
    '0x6224': ['SQ', '1', 'DerivationImplantTemplateSequence'],
    '0x6225': ['SQ', '1', 'OriginalImplantTemplateSequence'],
    '0x6226': ['DT', '1', 'EffectiveDateTime'],
    '0x6230': ['SQ', '1', 'ImplantTargetAnatomySequence'],
    '0x6260': ['SQ', '1', 'InformationFromManufacturerSequence'],
    '0x6265': ['SQ', '1', 'NotificationFromManufacturerSequence'],
    '0x6270': ['DT', '1', 'InformationIssueDateTime'],
    '0x6280': ['ST', '1', 'InformationSummary'],
    '0x62A0': ['SQ', '1', 'ImplantRegulatoryDisapprovalCodeSequence'],
    '0x62A5': ['FD', '1', 'OverallTemplateSpatialTolerance'],
    '0x62C0': ['SQ', '1', 'HPGLDocumentSequence'],
    '0x62D0': ['US', '1', 'HPGLDocumentID'],
    '0x62D5': ['LO', '1', 'HPGLDocumentLabel'],
    '0x62E0': ['SQ', '1', 'ViewOrientationCodeSequence'],
    '0x62F0': ['SQ', '1', 'ViewOrientationModifierCodeSequence'],
    '0x62F2': ['FD', '1', 'HPGLDocumentScaling'],
    '0x6300': ['OB', '1', 'HPGLDocument'],
    '0x6310': ['US', '1', 'HPGLContourPenNumber'],
    '0x6320': ['SQ', '1', 'HPGLPenSequence'],
    '0x6330': ['US', '1', 'HPGLPenNumber'],
    '0x6340': ['LO', '1', 'HPGLPenLabel'],
    '0x6345': ['ST', '1', 'HPGLPenDescription'],
    '0x6346': ['FD', '2', 'RecommendedRotationPoint'],
    '0x6347': ['FD', '4', 'BoundingRectangle'],
    '0x6350': ['US', '1-n', 'ImplantTemplate3DModelSurfaceNumber'],
    '0x6360': ['SQ', '1', 'SurfaceModelDescriptionSequence'],
    '0x6380': ['LO', '1', 'SurfaceModelLabel'],
    '0x6390': ['FD', '1', 'SurfaceModelScalingFactor'],
    '0x63A0': ['SQ', '1', 'MaterialsCodeSequence'],
    '0x63A4': ['SQ', '1', 'CoatingMaterialsCodeSequence'],
    '0x63A8': ['SQ', '1', 'ImplantTypeCodeSequence'],
    '0x63AC': ['SQ', '1', 'FixationMethodCodeSequence'],
    '0x63B0': ['SQ', '1', 'MatingFeatureSetsSequence'],
    '0x63C0': ['US', '1', 'MatingFeatureSetID'],
    '0x63D0': ['LO', '1', 'MatingFeatureSetLabel'],
    '0x63E0': ['SQ', '1', 'MatingFeatureSequence'],
    '0x63F0': ['US', '1', 'MatingFeatureID'],
    '0x6400': ['SQ', '1', 'MatingFeatureDegreeOfFreedomSequence'],
    '0x6410': ['US', '1', 'DegreeOfFreedomID'],
    '0x6420': ['CS', '1', 'DegreeOfFreedomType'],
    '0x6430': ['SQ', '1', 'TwoDMatingFeatureCoordinatesSequence'],
    '0x6440': ['US', '1', 'ReferencedHPGLDocumentID'],
    '0x6450': ['FD', '2', 'TwoDMatingPoint'],
    '0x6460': ['FD', '4', 'TwoDMatingAxes'],
    '0x6470': ['SQ', '1', 'TwoDDegreeOfFreedomSequence'],
    '0x6490': ['FD', '3', 'ThreeDDegreeOfFreedomAxis'],
    '0x64A0': ['FD', '2', 'RangeOfFreedom'],
    '0x64C0': ['FD', '3', 'ThreeDMatingPoint'],
    '0x64D0': ['FD', '9', 'ThreeDMatingAxes'],
    '0x64F0': ['FD', '3', 'TwoDDegreeOfFreedomAxis'],
    '0x6500': ['SQ', '1', 'PlanningLandmarkPointSequence'],
    '0x6510': ['SQ', '1', 'PlanningLandmarkLineSequence'],
    '0x6520': ['SQ', '1', 'PlanningLandmarkPlaneSequence'],
    '0x6530': ['US', '1', 'PlanningLandmarkID'],
    '0x6540': ['LO', '1', 'PlanningLandmarkDescription'],
    '0x6545': ['SQ', '1', 'PlanningLandmarkIdentificationCodeSequence'],
    '0x6550': ['SQ', '1', 'TwoDPointCoordinatesSequence'],
    '0x6560': ['FD', '2', 'TwoDPointCoordinates'],
    '0x6590': ['FD', '3', 'ThreeDPointCoordinates'],
    '0x65A0': ['SQ', '1', 'TwoDLineCoordinatesSequence'],
    '0x65B0': ['FD', '4', 'TwoDLineCoordinates'],
    '0x65D0': ['FD', '6', 'ThreeDLineCoordinates'],
    '0x65E0': ['SQ', '1', 'TwoDPlaneCoordinatesSequence'],
    '0x65F0': ['FD', '4', 'TwoDPlaneIntersection'],
    '0x6610': ['FD', '3', 'ThreeDPlaneOrigin'],
    '0x6620': ['FD', '3', 'ThreeDPlaneNormal'],
    '0x7001': ['CS', '1', 'ModelModification'],
    '0x7002': ['CS', '1', 'ModelMirroring'],
    '0x7003': ['SQ', '1', 'ModelUsageCodeSequence'],
    '0x7004': ['UI', '1', 'ModelGroupUID'],
    '0x7005': ['UR', '1', 'RelativeURIReferenceWithinEncapsulatedDocument']
  },
  '0x006A': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0001': ['CS', '1', 'AnnotationCoordinateType'],
    '0x0002': ['SQ', '1', 'AnnotationGroupSequence'],
    '0x0003': ['UI', '1', 'AnnotationGroupUID'],
    '0x0005': ['LO', '1', 'AnnotationGroupLabel'],
    '0x0006': ['UT', '1', 'AnnotationGroupDescription'],
    '0x0007': ['CS', '1', 'AnnotationGroupGenerationType'],
    '0x0008': ['SQ', '1', 'AnnotationGroupAlgorithmIdentificationSequence'],
    '0x0009': ['SQ', '1', 'AnnotationPropertyCategoryCodeSequence'],
    '0x000A': ['SQ', '1', 'AnnotationPropertyTypeCodeSequence'],
    '0x000B': ['SQ', '1', 'AnnotationPropertyTypeModifierCodeSequence'],
    '0x000C': ['UL', '1', 'NumberOfAnnotations'],
    '0x000D': ['CS', '1', 'AnnotationAppliesToAllOpticalPaths'],
    '0x000E': ['SH', '1-n', 'ReferencedOpticalPathIdentifier'],
    '0x000F': ['CS', '1', 'AnnotationAppliesToAllZPlanes'],
    '0x0010': ['FD', '1-n', 'CommonZCoordinateValue'],
    '0x0011': ['OL', '1', 'AnnotationIndexList']
  },
  '0x0070': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0001': ['SQ', '1', 'GraphicAnnotationSequence'],
    '0x0002': ['CS', '1', 'GraphicLayer'],
    '0x0003': ['CS', '1', 'BoundingBoxAnnotationUnits'],
    '0x0004': ['CS', '1', 'AnchorPointAnnotationUnits'],
    '0x0005': ['CS', '1', 'GraphicAnnotationUnits'],
    '0x0006': ['ST', '1', 'UnformattedTextValue'],
    '0x0008': ['SQ', '1', 'TextObjectSequence'],
    '0x0009': ['SQ', '1', 'GraphicObjectSequence'],
    '0x0010': ['FL', '2', 'BoundingBoxTopLeftHandCorner'],
    '0x0011': ['FL', '2', 'BoundingBoxBottomRightHandCorner'],
    '0x0012': ['CS', '1', 'BoundingBoxTextHorizontalJustification'],
    '0x0014': ['FL', '2', 'AnchorPoint'],
    '0x0015': ['CS', '1', 'AnchorPointVisibility'],
    '0x0020': ['US', '1', 'GraphicDimensions'],
    '0x0021': ['US', '1', 'NumberOfGraphicPoints'],
    '0x0022': ['FL', '2-n', 'GraphicData'],
    '0x0023': ['CS', '1', 'GraphicType'],
    '0x0024': ['CS', '1', 'GraphicFilled'],
    '0x0040': ['IS', '1', 'ImageRotationRetired'],
    '0x0041': ['CS', '1', 'ImageHorizontalFlip'],
    '0x0042': ['US', '1', 'ImageRotation'],
    '0x0050': ['US', '2', 'DisplayedAreaTopLeftHandCornerTrial'],
    '0x0051': ['US', '2', 'DisplayedAreaBottomRightHandCornerTrial'],
    '0x0052': ['SL', '2', 'DisplayedAreaTopLeftHandCorner'],
    '0x0053': ['SL', '2', 'DisplayedAreaBottomRightHandCorner'],
    '0x005A': ['SQ', '1', 'DisplayedAreaSelectionSequence'],
    '0x0060': ['SQ', '1', 'GraphicLayerSequence'],
    '0x0062': ['IS', '1', 'GraphicLayerOrder'],
    '0x0066': ['US', '1', 'GraphicLayerRecommendedDisplayGrayscaleValue'],
    '0x0067': ['US', '3', 'GraphicLayerRecommendedDisplayRGBValue'],
    '0x0068': ['LO', '1', 'GraphicLayerDescription'],
    '0x0080': ['CS', '1', 'ContentLabel'],
    '0x0081': ['LO', '1', 'ContentDescription'],
    '0x0082': ['DA', '1', 'PresentationCreationDate'],
    '0x0083': ['TM', '1', 'PresentationCreationTime'],
    '0x0084': ['PN', '1', 'ContentCreatorName'],
    '0x0086': ['SQ', '1', 'ContentCreatorIdentificationCodeSequence'],
    '0x0087': ['SQ', '1', 'AlternateContentDescriptionSequence'],
    '0x0100': ['CS', '1', 'PresentationSizeMode'],
    '0x0101': ['DS', '2', 'PresentationPixelSpacing'],
    '0x0102': ['IS', '2', 'PresentationPixelAspectRatio'],
    '0x0103': ['FL', '1', 'PresentationPixelMagnificationRatio'],
    '0x0207': ['LO', '1', 'GraphicGroupLabel'],
    '0x0208': ['ST', '1', 'GraphicGroupDescription'],
    '0x0209': ['SQ', '1', 'CompoundGraphicSequence'],
    '0x0226': ['UL', '1', 'CompoundGraphicInstanceID'],
    '0x0227': ['LO', '1', 'FontName'],
    '0x0228': ['CS', '1', 'FontNameType'],
    '0x0229': ['LO', '1', 'CSSFontName'],
    '0x0230': ['FD', '1', 'RotationAngle'],
    '0x0231': ['SQ', '1', 'TextStyleSequence'],
    '0x0232': ['SQ', '1', 'LineStyleSequence'],
    '0x0233': ['SQ', '1', 'FillStyleSequence'],
    '0x0234': ['SQ', '1', 'GraphicGroupSequence'],
    '0x0241': ['US', '3', 'TextColorCIELabValue'],
    '0x0242': ['CS', '1', 'HorizontalAlignment'],
    '0x0243': ['CS', '1', 'VerticalAlignment'],
    '0x0244': ['CS', '1', 'ShadowStyle'],
    '0x0245': ['FL', '1', 'ShadowOffsetX'],
    '0x0246': ['FL', '1', 'ShadowOffsetY'],
    '0x0247': ['US', '3', 'ShadowColorCIELabValue'],
    '0x0248': ['CS', '1', 'Underlined'],
    '0x0249': ['CS', '1', 'Bold'],
    '0x0250': ['CS', '1', 'Italic'],
    '0x0251': ['US', '3', 'PatternOnColorCIELabValue'],
    '0x0252': ['US', '3', 'PatternOffColorCIELabValue'],
    '0x0253': ['FL', '1', 'LineThickness'],
    '0x0254': ['CS', '1', 'LineDashingStyle'],
    '0x0255': ['UL', '1', 'LinePattern'],
    '0x0256': ['OB', '1', 'FillPattern'],
    '0x0257': ['CS', '1', 'FillMode'],
    '0x0258': ['FL', '1', 'ShadowOpacity'],
    '0x0261': ['FL', '1', 'GapLength'],
    '0x0262': ['FL', '1', 'DiameterOfVisibility'],
    '0x0273': ['FL', '2', 'RotationPoint'],
    '0x0274': ['CS', '1', 'TickAlignment'],
    '0x0278': ['CS', '1', 'ShowTickLabel'],
    '0x0279': ['CS', '1', 'TickLabelAlignment'],
    '0x0282': ['CS', '1', 'CompoundGraphicUnits'],
    '0x0284': ['FL', '1', 'PatternOnOpacity'],
    '0x0285': ['FL', '1', 'PatternOffOpacity'],
    '0x0287': ['SQ', '1', 'MajorTicksSequence'],
    '0x0288': ['FL', '1', 'TickPosition'],
    '0x0289': ['SH', '1', 'TickLabel'],
    '0x0294': ['CS', '1', 'CompoundGraphicType'],
    '0x0295': ['UL', '1', 'GraphicGroupID'],
    '0x0306': ['CS', '1', 'ShapeType'],
    '0x0308': ['SQ', '1', 'RegistrationSequence'],
    '0x0309': ['SQ', '1', 'MatrixRegistrationSequence'],
    '0x030A': ['SQ', '1', 'MatrixSequence'],
    '0x030B': ['FD', '16', 'FrameOfReferenceToDisplayedCoordinateSystemTransformationMatrix'],
    '0x030C': ['CS', '1', 'FrameOfReferenceTransformationMatrixType'],
    '0x030D': ['SQ', '1', 'RegistrationTypeCodeSequence'],
    '0x030F': ['ST', '1', 'FiducialDescription'],
    '0x0310': ['SH', '1', 'FiducialIdentifier'],
    '0x0311': ['SQ', '1', 'FiducialIdentifierCodeSequence'],
    '0x0312': ['FD', '1', 'ContourUncertaintyRadius'],
    '0x0314': ['SQ', '1', 'UsedFiducialsSequence'],
    '0x0318': ['SQ', '1', 'GraphicCoordinatesDataSequence'],
    '0x031A': ['UI', '1', 'FiducialUID'],
    '0x031B': ['UI', '1', 'ReferencedFiducialUID'],
    '0x031C': ['SQ', '1', 'FiducialSetSequence'],
    '0x031E': ['SQ', '1', 'FiducialSequence'],
    '0x031F': ['SQ', '1', 'FiducialsPropertyCategoryCodeSequence'],
    '0x0401': ['US', '3', 'GraphicLayerRecommendedDisplayCIELabValue'],
    '0x0402': ['SQ', '1', 'BlendingSequence'],
    '0x0403': ['FL', '1', 'RelativeOpacity'],
    '0x0404': ['SQ', '1', 'ReferencedSpatialRegistrationSequence'],
    '0x0405': ['CS', '1', 'BlendingPosition'],
    '0x1101': ['UI', '1', 'PresentationDisplayCollectionUID'],
    '0x1102': ['UI', '1', 'PresentationSequenceCollectionUID'],
    '0x1103': ['US', '1', 'PresentationSequencePositionIndex'],
    '0x1104': ['SQ', '1', 'RenderedImageReferenceSequence'],
    '0x1201': ['SQ', '1', 'VolumetricPresentationStateInputSequence'],
    '0x1202': ['CS', '1', 'PresentationInputType'],
    '0x1203': ['US', '1', 'InputSequencePositionIndex'],
    '0x1204': ['CS', '1', 'Crop'],
    '0x1205': ['US', '1-n', 'CroppingSpecificationIndex'],
    '0x1206': ['CS', '1', 'CompositingMethod'],
    '0x1207': ['US', '1', 'VolumetricPresentationInputNumber'],
    '0x1208': ['CS', '1', 'ImageVolumeGeometry'],
    '0x1209': ['UI', '1', 'VolumetricPresentationInputSetUID'],
    '0x120A': ['SQ', '1', 'VolumetricPresentationInputSetSequence'],
    '0x120B': ['CS', '1', 'GlobalCrop'],
    '0x120C': ['US', '1-n', 'GlobalCroppingSpecificationIndex'],
    '0x120D': ['CS', '1', 'RenderingMethod'],
    '0x1301': ['SQ', '1', 'VolumeCroppingSequence'],
    '0x1302': ['CS', '1', 'VolumeCroppingMethod'],
    '0x1303': ['FD', '6', 'BoundingBoxCrop'],
    '0x1304': ['SQ', '1', 'ObliqueCroppingPlaneSequence'],
    '0x1305': ['FD', '4', 'Plane'],
    '0x1306': ['FD', '3', 'PlaneNormal'],
    '0x1309': ['US', '1', 'CroppingSpecificationNumber'],
    '0x1501': ['CS', '1', 'MultiPlanarReconstructionStyle'],
    '0x1502': ['CS', '1', 'MPRThicknessType'],
    '0x1503': ['FD', '1', 'MPRSlabThickness'],
    '0x1505': ['FD', '3', 'MPRTopLeftHandCorner'],
    '0x1507': ['FD', '3', 'MPRViewWidthDirection'],
    '0x1508': ['FD', '1', 'MPRViewWidth'],
    '0x150C': ['UL', '1', 'NumberOfVolumetricCurvePoints'],
    '0x150D': ['OD', '1', 'VolumetricCurvePoints'],
    '0x1511': ['FD', '3', 'MPRViewHeightDirection'],
    '0x1512': ['FD', '1', 'MPRViewHeight'],
    '0x1602': ['CS', '1', 'RenderProjection'],
    '0x1603': ['FD', '3', 'ViewpointPosition'],
    '0x1604': ['FD', '3', 'ViewpointLookAtPoint'],
    '0x1605': ['FD', '3', 'ViewpointUpDirection'],
    '0x1606': ['FD', '6', 'RenderFieldOfView'],
    '0x1607': ['FD', '1', 'SamplingStepSize'],
    '0x1701': ['CS', '1', 'ShadingStyle'],
    '0x1702': ['FD', '1', 'AmbientReflectionIntensity'],
    '0x1703': ['FD', '3', 'LightDirection'],
    '0x1704': ['FD', '1', 'DiffuseReflectionIntensity'],
    '0x1705': ['FD', '1', 'SpecularReflectionIntensity'],
    '0x1706': ['FD', '1', 'Shininess'],
    '0x1801': ['SQ', '1', 'PresentationStateClassificationComponentSequence'],
    '0x1802': ['CS', '1', 'ComponentType'],
    '0x1803': ['SQ', '1', 'ComponentInputSequence'],
    '0x1804': ['US', '1', 'VolumetricPresentationInputIndex'],
    '0x1805': ['SQ', '1', 'PresentationStateCompositorComponentSequence'],
    '0x1806': ['SQ', '1', 'WeightingTransferFunctionSequence'],
    '0x1807': ['US', '3', 'WeightingLookupTableDescriptor'],
    '0x1808': ['OB', '1', 'WeightingLookupTableData'],
    '0x1901': ['SQ', '1', 'VolumetricAnnotationSequence'],
    '0x1903': ['SQ', '1', 'ReferencedStructuredContextSequence'],
    '0x1904': ['UI', '1', 'ReferencedContentItem'],
    '0x1905': ['SQ', '1', 'VolumetricPresentationInputAnnotationSequence'],
    '0x1907': ['CS', '1', 'AnnotationClipping'],
    '0x1A01': ['CS', '1', 'PresentationAnimationStyle'],
    '0x1A03': ['FD', '1', 'RecommendedAnimationRate'],
    '0x1A04': ['SQ', '1', 'AnimationCurveSequence'],
    '0x1A05': ['FD', '1', 'AnimationStepSize'],
    '0x1A06': ['FD', '1', 'SwivelRange'],
    '0x1A07': ['OD', '1', 'VolumetricCurveUpDirections'],
    '0x1A08': ['SQ', '1', 'VolumeStreamSequence'],
    '0x1A09': ['LO', '1', 'RGBATransferFunctionDescription'],
    '0x1B01': ['SQ', '1', 'AdvancedBlendingSequence'],
    '0x1B02': ['US', '1', 'BlendingInputNumber'],
    '0x1B03': ['SQ', '1', 'BlendingDisplayInputSequence'],
    '0x1B04': ['SQ', '1', 'BlendingDisplaySequence'],
    '0x1B06': ['CS', '1', 'BlendingMode'],
    '0x1B07': ['CS', '1', 'TimeSeriesBlending'],
    '0x1B08': ['CS', '1', 'GeometryForDisplay'],
    '0x1B11': ['SQ', '1', 'ThresholdSequence'],
    '0x1B12': ['SQ', '1', 'ThresholdValueSequence'],
    '0x1B13': ['CS', '1', 'ThresholdType'],
    '0x1B14': ['FD', '1', 'ThresholdValue']
  },
  '0x0072': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0002': ['SH', '1', 'HangingProtocolName'],
    '0x0004': ['LO', '1', 'HangingProtocolDescription'],
    '0x0006': ['CS', '1', 'HangingProtocolLevel'],
    '0x0008': ['LO', '1', 'HangingProtocolCreator'],
    '0x000A': ['DT', '1', 'HangingProtocolCreationDateTime'],
    '0x000C': ['SQ', '1', 'HangingProtocolDefinitionSequence'],
    '0x000E': ['SQ', '1', 'HangingProtocolUserIdentificationCodeSequence'],
    '0x0010': ['LO', '1', 'HangingProtocolUserGroupName'],
    '0x0012': ['SQ', '1', 'SourceHangingProtocolSequence'],
    '0x0014': ['US', '1', 'NumberOfPriorsReferenced'],
    '0x0020': ['SQ', '1', 'ImageSetsSequence'],
    '0x0022': ['SQ', '1', 'ImageSetSelectorSequence'],
    '0x0024': ['CS', '1', 'ImageSetSelectorUsageFlag'],
    '0x0026': ['AT', '1', 'SelectorAttribute'],
    '0x0028': ['US', '1', 'SelectorValueNumber'],
    '0x0030': ['SQ', '1', 'TimeBasedImageSetsSequence'],
    '0x0032': ['US', '1', 'ImageSetNumber'],
    '0x0034': ['CS', '1', 'ImageSetSelectorCategory'],
    '0x0038': ['US', '2', 'RelativeTime'],
    '0x003A': ['CS', '1', 'RelativeTimeUnits'],
    '0x003C': ['SS', '2', 'AbstractPriorValue'],
    '0x003E': ['SQ', '1', 'AbstractPriorCodeSequence'],
    '0x0040': ['LO', '1', 'ImageSetLabel'],
    '0x0050': ['CS', '1', 'SelectorAttributeVR'],
    '0x0052': ['AT', '1-n', 'SelectorSequencePointer'],
    '0x0054': ['LO', '1-n', 'SelectorSequencePointerPrivateCreator'],
    '0x0056': ['LO', '1', 'SelectorAttributePrivateCreator'],
    '0x005E': ['AE', '1-n', 'SelectorAEValue'],
    '0x005F': ['AS', '1-n', 'SelectorASValue'],
    '0x0060': ['AT', '1-n', 'SelectorATValue'],
    '0x0061': ['DA', '1-n', 'SelectorDAValue'],
    '0x0062': ['CS', '1-n', 'SelectorCSValue'],
    '0x0063': ['DT', '1-n', 'SelectorDTValue'],
    '0x0064': ['IS', '1-n', 'SelectorISValue'],
    '0x0065': ['OB', '1', 'SelectorOBValue'],
    '0x0066': ['LO', '1-n', 'SelectorLOValue'],
    '0x0067': ['OF', '1', 'SelectorOFValue'],
    '0x0068': ['LT', '1', 'SelectorLTValue'],
    '0x0069': ['OW', '1', 'SelectorOWValue'],
    '0x006A': ['PN', '1-n', 'SelectorPNValue'],
    '0x006B': ['TM', '1-n', 'SelectorTMValue'],
    '0x006C': ['SH', '1-n', 'SelectorSHValue'],
    '0x006D': ['UN', '1', 'SelectorUNValue'],
    '0x006E': ['ST', '1', 'SelectorSTValue'],
    '0x006F': ['UC', '1-n', 'SelectorUCValue'],
    '0x0070': ['UT', '1', 'SelectorUTValue'],
    '0x0071': ['UR', '1', 'SelectorURValue'],
    '0x0072': ['DS', '1-n', 'SelectorDSValue'],
    '0x0073': ['OD', '1', 'SelectorODValue'],
    '0x0074': ['FD', '1-n', 'SelectorFDValue'],
    '0x0075': ['OL', '1', 'SelectorOLValue'],
    '0x0076': ['FL', '1-n', 'SelectorFLValue'],
    '0x0078': ['UL', '1-n', 'SelectorULValue'],
    '0x007A': ['US', '1-n', 'SelectorUSValue'],
    '0x007C': ['SL', '1-n', 'SelectorSLValue'],
    '0x007E': ['SS', '1-n', 'SelectorSSValue'],
    '0x007F': ['UI', '1-n', 'SelectorUIValue'],
    '0x0080': ['SQ', '1', 'SelectorCodeSequenceValue'],
    '0x0081': ['OV', '1', 'SelectorOVValue'],
    '0x0082': ['SV', '1-n', 'SelectorSVValue'],
    '0x0083': ['UV', '1-n', 'SelectorUVValue'],
    '0x0100': ['US', '1', 'NumberOfScreens'],
    '0x0102': ['SQ', '1', 'NominalScreenDefinitionSequence'],
    '0x0104': ['US', '1', 'NumberOfVerticalPixels'],
    '0x0106': ['US', '1', 'NumberOfHorizontalPixels'],
    '0x0108': ['FD', '4', 'DisplayEnvironmentSpatialPosition'],
    '0x010A': ['US', '1', 'ScreenMinimumGrayscaleBitDepth'],
    '0x010C': ['US', '1', 'ScreenMinimumColorBitDepth'],
    '0x010E': ['US', '1', 'ApplicationMaximumRepaintTime'],
    '0x0200': ['SQ', '1', 'DisplaySetsSequence'],
    '0x0202': ['US', '1', 'DisplaySetNumber'],
    '0x0203': ['LO', '1', 'DisplaySetLabel'],
    '0x0204': ['US', '1', 'DisplaySetPresentationGroup'],
    '0x0206': ['LO', '1', 'DisplaySetPresentationGroupDescription'],
    '0x0208': ['CS', '1', 'PartialDataDisplayHandling'],
    '0x0210': ['SQ', '1', 'SynchronizedScrollingSequence'],
    '0x0212': ['US', '2-n', 'DisplaySetScrollingGroup'],
    '0x0214': ['SQ', '1', 'NavigationIndicatorSequence'],
    '0x0216': ['US', '1', 'NavigationDisplaySet'],
    '0x0218': ['US', '1-n', 'ReferenceDisplaySets'],
    '0x0300': ['SQ', '1', 'ImageBoxesSequence'],
    '0x0302': ['US', '1', 'ImageBoxNumber'],
    '0x0304': ['CS', '1', 'ImageBoxLayoutType'],
    '0x0306': ['US', '1', 'ImageBoxTileHorizontalDimension'],
    '0x0308': ['US', '1', 'ImageBoxTileVerticalDimension'],
    '0x0310': ['CS', '1', 'ImageBoxScrollDirection'],
    '0x0312': ['CS', '1', 'ImageBoxSmallScrollType'],
    '0x0314': ['US', '1', 'ImageBoxSmallScrollAmount'],
    '0x0316': ['CS', '1', 'ImageBoxLargeScrollType'],
    '0x0318': ['US', '1', 'ImageBoxLargeScrollAmount'],
    '0x0320': ['US', '1', 'ImageBoxOverlapPriority'],
    '0x0330': ['FD', '1', 'CineRelativeToRealTime'],
    '0x0400': ['SQ', '1', 'FilterOperationsSequence'],
    '0x0402': ['CS', '1', 'FilterByCategory'],
    '0x0404': ['CS', '1', 'FilterByAttributePresence'],
    '0x0406': ['CS', '1', 'FilterByOperator'],
    '0x0420': ['US', '3', 'StructuredDisplayBackgroundCIELabValue'],
    '0x0421': ['US', '3', 'EmptyImageBoxCIELabValue'],
    '0x0422': ['SQ', '1', 'StructuredDisplayImageBoxSequence'],
    '0x0424': ['SQ', '1', 'StructuredDisplayTextBoxSequence'],
    '0x0427': ['SQ', '1', 'ReferencedFirstFrameSequence'],
    '0x0430': ['SQ', '1', 'ImageBoxSynchronizationSequence'],
    '0x0432': ['US', '2-n', 'SynchronizedImageBoxList'],
    '0x0434': ['CS', '1', 'TypeOfSynchronization'],
    '0x0500': ['CS', '1', 'BlendingOperationType'],
    '0x0510': ['CS', '1', 'ReformattingOperationType'],
    '0x0512': ['FD', '1', 'ReformattingThickness'],
    '0x0514': ['FD', '1', 'ReformattingInterval'],
    '0x0516': ['CS', '1', 'ReformattingOperationInitialViewDirection'],
    '0x0520': ['CS', '1-n', 'ThreeDRenderingType'],
    '0x0600': ['SQ', '1', 'SortingOperationsSequence'],
    '0x0602': ['CS', '1', 'SortByCategory'],
    '0x0604': ['CS', '1', 'SortingDirection'],
    '0x0700': ['CS', '2', 'DisplaySetPatientOrientation'],
    '0x0702': ['CS', '1', 'VOIType'],
    '0x0704': ['CS', '1', 'PseudoColorType'],
    '0x0705': ['SQ', '1', 'PseudoColorPaletteInstanceReferenceSequence'],
    '0x0706': ['CS', '1', 'ShowGrayscaleInverted'],
    '0x0710': ['CS', '1', 'ShowImageTrueSizeFlag'],
    '0x0712': ['CS', '1', 'ShowGraphicAnnotationFlag'],
    '0x0714': ['CS', '1', 'ShowPatientDemographicsFlag'],
    '0x0716': ['CS', '1', 'ShowAcquisitionTechniquesFlag'],
    '0x0717': ['CS', '1', 'DisplaySetHorizontalJustification'],
    '0x0718': ['CS', '1', 'DisplaySetVerticalJustification']
  },
  '0x0074': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0120': ['FD', '1', 'ContinuationStartMeterset'],
    '0x0121': ['FD', '1', 'ContinuationEndMeterset'],
    '0x1000': ['CS', '1', 'ProcedureStepState'],
    '0x1002': ['SQ', '1', 'ProcedureStepProgressInformationSequence'],
    '0x1004': ['DS', '1', 'ProcedureStepProgress'],
    '0x1006': ['ST', '1', 'ProcedureStepProgressDescription'],
    '0x1007': ['SQ', '1', 'ProcedureStepProgressParametersSequence'],
    '0x1008': ['SQ', '1', 'ProcedureStepCommunicationsURISequence'],
    '0x100A': ['UR', '1', 'ContactURI'],
    '0x100C': ['LO', '1', 'ContactDisplayName'],
    '0x100E': ['SQ', '1', 'ProcedureStepDiscontinuationReasonCodeSequence'],
    '0x1020': ['SQ', '1', 'BeamTaskSequence'],
    '0x1022': ['CS', '1', 'BeamTaskType'],
    '0x1024': ['IS', '1', 'BeamOrderIndexTrial'],
    '0x1025': ['CS', '1', 'AutosequenceFlag'],
    '0x1026': ['FD', '1', 'TableTopVerticalAdjustedPosition'],
    '0x1027': ['FD', '1', 'TableTopLongitudinalAdjustedPosition'],
    '0x1028': ['FD', '1', 'TableTopLateralAdjustedPosition'],
    '0x102A': ['FD', '1', 'PatientSupportAdjustedAngle'],
    '0x102B': ['FD', '1', 'TableTopEccentricAdjustedAngle'],
    '0x102C': ['FD', '1', 'TableTopPitchAdjustedAngle'],
    '0x102D': ['FD', '1', 'TableTopRollAdjustedAngle'],
    '0x1030': ['SQ', '1', 'DeliveryVerificationImageSequence'],
    '0x1032': ['CS', '1', 'VerificationImageTiming'],
    '0x1034': ['CS', '1', 'DoubleExposureFlag'],
    '0x1036': ['CS', '1', 'DoubleExposureOrdering'],
    '0x1038': ['DS', '1', 'DoubleExposureMetersetTrial'],
    '0x103A': ['DS', '4', 'DoubleExposureFieldDeltaTrial'],
    '0x1040': ['SQ', '1', 'RelatedReferenceRTImageSequence'],
    '0x1042': ['SQ', '1', 'GeneralMachineVerificationSequence'],
    '0x1044': ['SQ', '1', 'ConventionalMachineVerificationSequence'],
    '0x1046': ['SQ', '1', 'IonMachineVerificationSequence'],
    '0x1048': ['SQ', '1', 'FailedAttributesSequence'],
    '0x104A': ['SQ', '1', 'OverriddenAttributesSequence'],
    '0x104C': ['SQ', '1', 'ConventionalControlPointVerificationSequence'],
    '0x104E': ['SQ', '1', 'IonControlPointVerificationSequence'],
    '0x1050': ['SQ', '1', 'AttributeOccurrenceSequence'],
    '0x1052': ['AT', '1', 'AttributeOccurrencePointer'],
    '0x1054': ['UL', '1', 'AttributeItemSelector'],
    '0x1056': ['LO', '1', 'AttributeOccurrencePrivateCreator'],
    '0x1057': ['IS', '1-n', 'SelectorSequencePointerItems'],
    '0x1200': ['CS', '1', 'ScheduledProcedureStepPriority'],
    '0x1202': ['LO', '1', 'WorklistLabel'],
    '0x1204': ['LO', '1', 'ProcedureStepLabel'],
    '0x1210': ['SQ', '1', 'ScheduledProcessingParametersSequence'],
    '0x1212': ['SQ', '1', 'PerformedProcessingParametersSequence'],
    '0x1216': ['SQ', '1', 'UnifiedProcedureStepPerformedProcedureSequence'],
    '0x1220': ['SQ', '1', 'RelatedProcedureStepSequence'],
    '0x1222': ['LO', '1', 'ProcedureStepRelationshipType'],
    '0x1224': ['SQ', '1', 'ReplacedProcedureStepSequence'],
    '0x1230': ['LO', '1', 'DeletionLock'],
    '0x1234': ['AE', '1', 'ReceivingAE'],
    '0x1236': ['AE', '1', 'RequestingAE'],
    '0x1238': ['LT', '1', 'ReasonForCancellation'],
    '0x1242': ['CS', '1', 'SCPStatus'],
    '0x1244': ['CS', '1', 'SubscriptionListStatus'],
    '0x1246': ['CS', '1', 'UnifiedProcedureStepListStatus'],
    '0x1324': ['UL', '1', 'BeamOrderIndex'],
    '0x1338': ['FD', '1', 'DoubleExposureMeterset'],
    '0x133A': ['FD', '4', 'DoubleExposureFieldDelta'],
    '0x1401': ['SQ', '1', 'BrachyTaskSequence'],
    '0x1402': ['DS', '1', 'ContinuationStartTotalReferenceAirKerma'],
    '0x1403': ['DS', '1', 'ContinuationEndTotalReferenceAirKerma'],
    '0x1404': ['IS', '1', 'ContinuationPulseNumber'],
    '0x1405': ['SQ', '1', 'ChannelDeliveryOrderSequence'],
    '0x1406': ['IS', '1', 'ReferencedChannelNumber'],
    '0x1407': ['DS', '1', 'StartCumulativeTimeWeight'],
    '0x1408': ['DS', '1', 'EndCumulativeTimeWeight'],
    '0x1409': ['SQ', '1', 'OmittedChannelSequence'],
    '0x140A': ['CS', '1', 'ReasonForChannelOmission'],
    '0x140B': ['LO', '1', 'ReasonForChannelOmissionDescription'],
    '0x140C': ['IS', '1', 'ChannelDeliveryOrderIndex'],
    '0x140D': ['SQ', '1', 'ChannelDeliveryContinuationSequence'],
    '0x140E': ['SQ', '1', 'OmittedApplicationSetupSequence']
  },
  '0x0076': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0001': ['LO', '1', 'ImplantAssemblyTemplateName'],
    '0x0003': ['LO', '1', 'ImplantAssemblyTemplateIssuer'],
    '0x0006': ['LO', '1', 'ImplantAssemblyTemplateVersion'],
    '0x0008': ['SQ', '1', 'ReplacedImplantAssemblyTemplateSequence'],
    '0x000A': ['CS', '1', 'ImplantAssemblyTemplateType'],
    '0x000C': ['SQ', '1', 'OriginalImplantAssemblyTemplateSequence'],
    '0x000E': ['SQ', '1', 'DerivationImplantAssemblyTemplateSequence'],
    '0x0010': ['SQ', '1', 'ImplantAssemblyTemplateTargetAnatomySequence'],
    '0x0020': ['SQ', '1', 'ProcedureTypeCodeSequence'],
    '0x0030': ['LO', '1', 'SurgicalTechnique'],
    '0x0032': ['SQ', '1', 'ComponentTypesSequence'],
    '0x0034': ['SQ', '1', 'ComponentTypeCodeSequence'],
    '0x0036': ['CS', '1', 'ExclusiveComponentType'],
    '0x0038': ['CS', '1', 'MandatoryComponentType'],
    '0x0040': ['SQ', '1', 'ComponentSequence'],
    '0x0055': ['US', '1', 'ComponentID'],
    '0x0060': ['SQ', '1', 'ComponentAssemblySequence'],
    '0x0070': ['US', '1', 'Component1ReferencedID'],
    '0x0080': ['US', '1', 'Component1ReferencedMatingFeatureSetID'],
    '0x0090': ['US', '1', 'Component1ReferencedMatingFeatureID'],
    '0x00A0': ['US', '1', 'Component2ReferencedID'],
    '0x00B0': ['US', '1', 'Component2ReferencedMatingFeatureSetID'],
    '0x00C0': ['US', '1', 'Component2ReferencedMatingFeatureID']
  },
  '0x0078': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0001': ['LO', '1', 'ImplantTemplateGroupName'],
    '0x0010': ['ST', '1', 'ImplantTemplateGroupDescription'],
    '0x0020': ['LO', '1', 'ImplantTemplateGroupIssuer'],
    '0x0024': ['LO', '1', 'ImplantTemplateGroupVersion'],
    '0x0026': ['SQ', '1', 'ReplacedImplantTemplateGroupSequence'],
    '0x0028': ['SQ', '1', 'ImplantTemplateGroupTargetAnatomySequence'],
    '0x002A': ['SQ', '1', 'ImplantTemplateGroupMembersSequence'],
    '0x002E': ['US', '1', 'ImplantTemplateGroupMemberID'],
    '0x0050': ['FD', '3', 'ThreeDImplantTemplateGroupMemberMatchingPoint'],
    '0x0060': ['FD', '9', 'ThreeDImplantTemplateGroupMemberMatchingAxes'],
    '0x0070': ['SQ', '1', 'ImplantTemplateGroupMemberMatching2DCoordinatesSequence'],
    '0x0090': ['FD', '2', 'TwoDImplantTemplateGroupMemberMatchingPoint'],
    '0x00A0': ['FD', '4', 'TwoDImplantTemplateGroupMemberMatchingAxes'],
    '0x00B0': ['SQ', '1', 'ImplantTemplateGroupVariationDimensionSequence'],
    '0x00B2': ['LO', '1', 'ImplantTemplateGroupVariationDimensionName'],
    '0x00B4': ['SQ', '1', 'ImplantTemplateGroupVariationDimensionRankSequence'],
    '0x00B6': ['US', '1', 'ReferencedImplantTemplateGroupMemberID'],
    '0x00B8': ['US', '1', 'ImplantTemplateGroupVariationDimensionRank']
  },
  '0x0080': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0001': ['SQ', '1', 'SurfaceScanAcquisitionTypeCodeSequence'],
    '0x0002': ['SQ', '1', 'SurfaceScanModeCodeSequence'],
    '0x0003': ['SQ', '1', 'RegistrationMethodCodeSequence'],
    '0x0004': ['FD', '1', 'ShotDurationTime'],
    '0x0005': ['FD', '1', 'ShotOffsetTime'],
    '0x0006': ['US', '1-n', 'SurfacePointPresentationValueData'],
    '0x0007': ['US', '3-3n', 'SurfacePointColorCIELabValueData'],
    '0x0008': ['SQ', '1', 'UVMappingSequence'],
    '0x0009': ['SH', '1', 'TextureLabel'],
    '0x0010': ['OF', '1', 'UValueData'],
    '0x0011': ['OF', '1', 'VValueData'],
    '0x0012': ['SQ', '1', 'ReferencedTextureSequence'],
    '0x0013': ['SQ', '1', 'ReferencedSurfaceDataSequence']
  },
  '0x0082': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0001': ['CS', '1', 'AssessmentSummary'],
    '0x0003': ['UT', '1', 'AssessmentSummaryDescription'],
    '0x0004': ['SQ', '1', 'AssessedSOPInstanceSequence'],
    '0x0005': ['SQ', '1', 'ReferencedComparisonSOPInstanceSequence'],
    '0x0006': ['UL', '1', 'NumberOfAssessmentObservations'],
    '0x0007': ['SQ', '1', 'AssessmentObservationsSequence'],
    '0x0008': ['CS', '1', 'ObservationSignificance'],
    '0x000A': ['UT', '1', 'ObservationDescription'],
    '0x000C': ['SQ', '1', 'StructuredConstraintObservationSequence'],
    '0x0010': ['SQ', '1', 'AssessedAttributeValueSequence'],
    '0x0016': ['LO', '1', 'AssessmentSetID'],
    '0x0017': ['SQ', '1', 'AssessmentRequesterSequence'],
    '0x0018': ['LO', '1', 'SelectorAttributeName'],
    '0x0019': ['LO', '1', 'SelectorAttributeKeyword'],
    '0x0021': ['SQ', '1', 'AssessmentTypeCodeSequence'],
    '0x0022': ['SQ', '1', 'ObservationBasisCodeSequence'],
    '0x0023': ['LO', '1', 'AssessmentLabel'],
    '0x0032': ['CS', '1', 'ConstraintType'],
    '0x0033': ['UT', '1', 'SpecificationSelectionGuidance'],
    '0x0034': ['SQ', '1', 'ConstraintValueSequence'],
    '0x0035': ['SQ', '1', 'RecommendedDefaultValueSequence'],
    '0x0036': ['CS', '1', 'ConstraintViolationSignificance'],
    '0x0037': ['UT', '1', 'ConstraintViolationCondition'],
    '0x0038': ['CS', '1', 'ModifiableConstraintFlag']
  },
  '0x0088': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0130': ['SH', '1', 'StorageMediaFileSetID'],
    '0x0140': ['UI', '1', 'StorageMediaFileSetUID'],
    '0x0200': ['SQ', '1', 'IconImageSequence'],
    '0x0904': ['LO', '1', 'TopicTitle'],
    '0x0906': ['ST', '1', 'TopicSubject'],
    '0x0910': ['LO', '1', 'TopicAuthor'],
    '0x0912': ['LO', '1-32', 'TopicKeywords']
  },
  '0x0100': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0410': ['CS', '1', 'SOPInstanceStatus'],
    '0x0420': ['DT', '1', 'SOPAuthorizationDateTime'],
    '0x0424': ['LT', '1', 'SOPAuthorizationComment'],
    '0x0426': ['LO', '1', 'AuthorizationEquipmentCertificationNumber']
  },
  '0x0400': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0005': ['US', '1', 'MACIDNumber'],
    '0x0010': ['UI', '1', 'MACCalculationTransferSyntaxUID'],
    '0x0015': ['CS', '1', 'MACAlgorithm'],
    '0x0020': ['AT', '1-n', 'DataElementsSigned'],
    '0x0100': ['UI', '1', 'DigitalSignatureUID'],
    '0x0105': ['DT', '1', 'DigitalSignatureDateTime'],
    '0x0110': ['CS', '1', 'CertificateType'],
    '0x0115': ['OB', '1', 'CertificateOfSigner'],
    '0x0120': ['OB', '1', 'Signature'],
    '0x0305': ['CS', '1', 'CertifiedTimestampType'],
    '0x0310': ['OB', '1', 'CertifiedTimestamp'],
    '0x0315': ['FL', '1', ''],
    '0x0401': ['SQ', '1', 'DigitalSignaturePurposeCodeSequence'],
    '0x0402': ['SQ', '1', 'ReferencedDigitalSignatureSequence'],
    '0x0403': ['SQ', '1', 'ReferencedSOPInstanceMACSequence'],
    '0x0404': ['OB', '1', 'MAC'],
    '0x0500': ['SQ', '1', 'EncryptedAttributesSequence'],
    '0x0510': ['UI', '1', 'EncryptedContentTransferSyntaxUID'],
    '0x0520': ['OB', '1', 'EncryptedContent'],
    '0x0550': ['SQ', '1', 'ModifiedAttributesSequence'],
    '0x0551': ['SQ', '1', 'NonconformingModifiedAttributesSequence'],
    '0x0552': ['OB', '1', 'NonconformingDataElementValue'],
    '0x0561': ['SQ', '1', 'OriginalAttributesSequence'],
    '0x0562': ['DT', '1', 'AttributeModificationDateTime'],
    '0x0563': ['LO', '1', 'ModifyingSystem'],
    '0x0564': ['LO', '1', 'SourceOfPreviousValues'],
    '0x0565': ['CS', '1', 'ReasonForTheAttributeModification'],
    '0x0600': ['CS', '1', 'InstanceOriginStatus']
  },
  '0x1000': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0010': ['US', '3', 'EscapeTriplet'],
    '0x0011': ['US', '3', 'RunLengthTriplet'],
    '0x0012': ['US', '1', 'HuffmanTableSize'],
    '0x0013': ['US', '3', 'HuffmanTableTriplet'],
    '0x0014': ['US', '1', 'ShiftTableSize'],
    '0x0015': ['US', '3', 'ShiftTableTriplet']
  },
  '0x1010': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0004': ['US', '1-n', 'ZonalMap']
  },
  '0x2000': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0010': ['IS', '1', 'NumberOfCopies'],
    '0x001E': ['SQ', '1', 'PrinterConfigurationSequence'],
    '0x0020': ['CS', '1', 'PrintPriority'],
    '0x0030': ['CS', '1', 'MediumType'],
    '0x0040': ['CS', '1', 'FilmDestination'],
    '0x0050': ['LO', '1', 'FilmSessionLabel'],
    '0x0060': ['IS', '1', 'MemoryAllocation'],
    '0x0061': ['IS', '1', 'MaximumMemoryAllocation'],
    '0x0062': ['CS', '1', 'ColorImagePrintingFlag'],
    '0x0063': ['CS', '1', 'CollationFlag'],
    '0x0065': ['CS', '1', 'AnnotationFlag'],
    '0x0067': ['CS', '1', 'ImageOverlayFlag'],
    '0x0069': ['CS', '1', 'PresentationLUTFlag'],
    '0x006A': ['CS', '1', 'ImageBoxPresentationLUTFlag'],
    '0x00A0': ['US', '1', 'MemoryBitDepth'],
    '0x00A1': ['US', '1', 'PrintingBitDepth'],
    '0x00A2': ['SQ', '1', 'MediaInstalledSequence'],
    '0x00A4': ['SQ', '1', 'OtherMediaAvailableSequence'],
    '0x00A8': ['SQ', '1', 'SupportedImageDisplayFormatsSequence'],
    '0x0500': ['SQ', '1', 'ReferencedFilmBoxSequence'],
    '0x0510': ['SQ', '1', 'ReferencedStoredPrintSequence']
  },
  '0x2010': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0010': ['ST', '1', 'ImageDisplayFormat'],
    '0x0030': ['CS', '1', 'AnnotationDisplayFormatID'],
    '0x0040': ['CS', '1', 'FilmOrientation'],
    '0x0050': ['CS', '1', 'FilmSizeID'],
    '0x0052': ['CS', '1', 'PrinterResolutionID'],
    '0x0054': ['CS', '1', 'DefaultPrinterResolutionID'],
    '0x0060': ['CS', '1', 'MagnificationType'],
    '0x0080': ['CS', '1', 'SmoothingType'],
    '0x00A6': ['CS', '1', 'DefaultMagnificationType'],
    '0x00A7': ['CS', '1-n', 'OtherMagnificationTypesAvailable'],
    '0x00A8': ['CS', '1', 'DefaultSmoothingType'],
    '0x00A9': ['CS', '1-n', 'OtherSmoothingTypesAvailable'],
    '0x0100': ['CS', '1', 'BorderDensity'],
    '0x0110': ['CS', '1', 'EmptyImageDensity'],
    '0x0120': ['US', '1', 'MinDensity'],
    '0x0130': ['US', '1', 'MaxDensity'],
    '0x0140': ['CS', '1', 'Trim'],
    '0x0150': ['ST', '1', 'ConfigurationInformation'],
    '0x0152': ['LT', '1', 'ConfigurationInformationDescription'],
    '0x0154': ['IS', '1', 'MaximumCollatedFilms'],
    '0x015E': ['US', '1', 'Illumination'],
    '0x0160': ['US', '1', 'ReflectedAmbientLight'],
    '0x0376': ['DS', '2', 'PrinterPixelSpacing'],
    '0x0500': ['SQ', '1', 'ReferencedFilmSessionSequence'],
    '0x0510': ['SQ', '1', 'ReferencedImageBoxSequence'],
    '0x0520': ['SQ', '1', 'ReferencedBasicAnnotationBoxSequence']
  },
  '0x2020': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0010': ['US', '1', 'ImageBoxPosition'],
    '0x0020': ['CS', '1', 'Polarity'],
    '0x0030': ['DS', '1', 'RequestedImageSize'],
    '0x0040': ['CS', '1', 'RequestedDecimateCropBehavior'],
    '0x0050': ['CS', '1', 'RequestedResolutionID'],
    '0x00A0': ['CS', '1', 'RequestedImageSizeFlag'],
    '0x00A2': ['CS', '1', 'DecimateCropResult'],
    '0x0110': ['SQ', '1', 'BasicGrayscaleImageSequence'],
    '0x0111': ['SQ', '1', 'BasicColorImageSequence'],
    '0x0130': ['SQ', '1', 'ReferencedImageOverlayBoxSequence'],
    '0x0140': ['SQ', '1', 'ReferencedVOILUTBoxSequence']
  },
  '0x2030': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0010': ['US', '1', 'AnnotationPosition'],
    '0x0020': ['LO', '1', 'TextString']
  },
  '0x2040': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0010': ['SQ', '1', 'ReferencedOverlayPlaneSequence'],
    '0x0011': ['US', '1-99', 'ReferencedOverlayPlaneGroups'],
    '0x0020': ['SQ', '1', 'OverlayPixelDataSequence'],
    '0x0060': ['CS', '1', 'OverlayMagnificationType'],
    '0x0070': ['CS', '1', 'OverlaySmoothingType'],
    '0x0072': ['CS', '1', 'OverlayOrImageMagnification'],
    '0x0074': ['US', '1', 'MagnifyToNumberOfColumns'],
    '0x0080': ['CS', '1', 'OverlayForegroundDensity'],
    '0x0082': ['CS', '1', 'OverlayBackgroundDensity'],
    '0x0090': ['CS', '1', 'OverlayMode'],
    '0x0100': ['CS', '1', 'ThresholdDensity'],
    '0x0500': ['SQ', '1', 'ReferencedImageBoxSequenceRetired']
  },
  '0x2050': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0010': ['SQ', '1', 'PresentationLUTSequence'],
    '0x0020': ['CS', '1', 'PresentationLUTShape'],
    '0x0500': ['SQ', '1', 'ReferencedPresentationLUTSequence']
  },
  '0x2100': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0010': ['SH', '1', 'PrintJobID'],
    '0x0020': ['CS', '1', 'ExecutionStatus'],
    '0x0030': ['CS', '1', 'ExecutionStatusInfo'],
    '0x0040': ['DA', '1', 'CreationDate'],
    '0x0050': ['TM', '1', 'CreationTime'],
    '0x0070': ['AE', '1', 'Originator'],
    '0x0140': ['AE', '1', 'DestinationAE'],
    '0x0160': ['SH', '1', 'OwnerID'],
    '0x0170': ['IS', '1', 'NumberOfFilms'],
    '0x0500': ['SQ', '1', 'ReferencedPrintJobSequencePullStoredPrint']
  },
  '0x2110': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0010': ['CS', '1', 'PrinterStatus'],
    '0x0020': ['CS', '1', 'PrinterStatusInfo'],
    '0x0030': ['LO', '1', 'PrinterName'],
    '0x0099': ['SH', '1', 'PrintQueueID']
  },
  '0x2120': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0010': ['CS', '1', 'QueueStatus'],
    '0x0050': ['SQ', '1', 'PrintJobDescriptionSequence'],
    '0x0070': ['SQ', '1', 'ReferencedPrintJobSequence']
  },
  '0x2130': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0010': ['SQ', '1', 'PrintManagementCapabilitiesSequence'],
    '0x0015': ['SQ', '1', 'PrinterCharacteristicsSequence'],
    '0x0030': ['SQ', '1', 'FilmBoxContentSequence'],
    '0x0040': ['SQ', '1', 'ImageBoxContentSequence'],
    '0x0050': ['SQ', '1', 'AnnotationContentSequence'],
    '0x0060': ['SQ', '1', 'ImageOverlayBoxContentSequence'],
    '0x0080': ['SQ', '1', 'PresentationLUTContentSequence'],
    '0x00A0': ['SQ', '1', 'ProposedStudySequence'],
    '0x00C0': ['SQ', '1', 'OriginalImageSequence']
  },
  '0x2200': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0001': ['CS', '1', 'LabelUsingInformationExtractedFromInstances'],
    '0x0002': ['UT', '1', 'LabelText'],
    '0x0003': ['CS', '1', 'LabelStyleSelection'],
    '0x0004': ['LT', '1', 'MediaDisposition'],
    '0x0005': ['LT', '1', 'BarcodeValue'],
    '0x0006': ['CS', '1', 'BarcodeSymbology'],
    '0x0007': ['CS', '1', 'AllowMediaSplitting'],
    '0x0008': ['CS', '1', 'IncludeNonDICOMObjects'],
    '0x0009': ['CS', '1', 'IncludeDisplayApplication'],
    '0x000A': ['CS', '1', 'PreserveCompositeInstancesAfterMediaCreation'],
    '0x000B': ['US', '1', 'TotalNumberOfPiecesOfMediaCreated'],
    '0x000C': ['LO', '1', 'RequestedMediaApplicationProfile'],
    '0x000D': ['SQ', '1', 'ReferencedStorageMediaSequence'],
    '0x000E': ['AT', '1-n', 'FailureAttributes'],
    '0x000F': ['CS', '1', 'AllowLossyCompression'],
    '0x0020': ['CS', '1', 'RequestPriority']
  },
  '0x3002': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0002': ['SH', '1', 'RTImageLabel'],
    '0x0003': ['LO', '1', 'RTImageName'],
    '0x0004': ['ST', '1', 'RTImageDescription'],
    '0x000A': ['CS', '1', 'ReportedValuesOrigin'],
    '0x000C': ['CS', '1', 'RTImagePlane'],
    '0x000D': ['DS', '3', 'XRayImageReceptorTranslation'],
    '0x000E': ['DS', '1', 'XRayImageReceptorAngle'],
    '0x0010': ['DS', '6', 'RTImageOrientation'],
    '0x0011': ['DS', '2', 'ImagePlanePixelSpacing'],
    '0x0012': ['DS', '2', 'RTImagePosition'],
    '0x0020': ['SH', '1', 'RadiationMachineName'],
    '0x0022': ['DS', '1', 'RadiationMachineSAD'],
    '0x0024': ['DS', '1', 'RadiationMachineSSD'],
    '0x0026': ['DS', '1', 'RTImageSID'],
    '0x0028': ['DS', '1', 'SourceToReferenceObjectDistance'],
    '0x0029': ['IS', '1', 'FractionNumber'],
    '0x0030': ['SQ', '1', 'ExposureSequence'],
    '0x0032': ['DS', '1', 'MetersetExposure'],
    '0x0034': ['DS', '4', 'DiaphragmPosition'],
    '0x0040': ['SQ', '1', 'FluenceMapSequence'],
    '0x0041': ['CS', '1', 'FluenceDataSource'],
    '0x0042': ['DS', '1', 'FluenceDataScale'],
    '0x0050': ['SQ', '1', 'PrimaryFluenceModeSequence'],
    '0x0051': ['CS', '1', 'FluenceMode'],
    '0x0052': ['SH', '1', 'FluenceModeID']
  },
  '0x3004': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0001': ['CS', '1', 'DVHType'],
    '0x0002': ['CS', '1', 'DoseUnits'],
    '0x0004': ['CS', '1', 'DoseType'],
    '0x0005': ['CS', '1', 'SpatialTransformOfDose'],
    '0x0006': ['LO', '1', 'DoseComment'],
    '0x0008': ['DS', '3', 'NormalizationPoint'],
    '0x000A': ['CS', '1', 'DoseSummationType'],
    '0x000C': ['DS', '2-n', 'GridFrameOffsetVector'],
    '0x000E': ['DS', '1', 'DoseGridScaling'],
    '0x0010': ['SQ', '1', 'RTDoseROISequence'],
    '0x0012': ['DS', '1', 'DoseValue'],
    '0x0014': ['CS', '1-3', 'TissueHeterogeneityCorrection'],
    '0x0040': ['DS', '3', 'DVHNormalizationPoint'],
    '0x0042': ['DS', '1', 'DVHNormalizationDoseValue'],
    '0x0050': ['SQ', '1', 'DVHSequence'],
    '0x0052': ['DS', '1', 'DVHDoseScaling'],
    '0x0054': ['CS', '1', 'DVHVolumeUnits'],
    '0x0056': ['IS', '1', 'DVHNumberOfBins'],
    '0x0058': ['DS', '2-2n', 'DVHData'],
    '0x0060': ['SQ', '1', 'DVHReferencedROISequence'],
    '0x0062': ['CS', '1', 'DVHROIContributionType'],
    '0x0070': ['DS', '1', 'DVHMinimumDose'],
    '0x0072': ['DS', '1', 'DVHMaximumDose'],
    '0x0074': ['DS', '1', 'DVHMeanDose']
  },
  '0x3006': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0002': ['SH', '1', 'StructureSetLabel'],
    '0x0004': ['LO', '1', 'StructureSetName'],
    '0x0006': ['ST', '1', 'StructureSetDescription'],
    '0x0008': ['DA', '1', 'StructureSetDate'],
    '0x0009': ['TM', '1', 'StructureSetTime'],
    '0x0010': ['SQ', '1', 'ReferencedFrameOfReferenceSequence'],
    '0x0012': ['SQ', '1', 'RTReferencedStudySequence'],
    '0x0014': ['SQ', '1', 'RTReferencedSeriesSequence'],
    '0x0016': ['SQ', '1', 'ContourImageSequence'],
    '0x0018': ['SQ', '1', 'PredecessorStructureSetSequence'],
    '0x0020': ['SQ', '1', 'StructureSetROISequence'],
    '0x0022': ['IS', '1', 'ROINumber'],
    '0x0024': ['UI', '1', 'ReferencedFrameOfReferenceUID'],
    '0x0026': ['LO', '1', 'ROIName'],
    '0x0028': ['ST', '1', 'ROIDescription'],
    '0x002A': ['IS', '3', 'ROIDisplayColor'],
    '0x002C': ['DS', '1', 'ROIVolume'],
    '0x0030': ['SQ', '1', 'RTRelatedROISequence'],
    '0x0033': ['CS', '1', 'RTROIRelationship'],
    '0x0036': ['CS', '1', 'ROIGenerationAlgorithm'],
    '0x0037': ['SQ', '1', 'ROIDerivationAlgorithmIdentificationSequence'],
    '0x0038': ['LO', '1', 'ROIGenerationDescription'],
    '0x0039': ['SQ', '1', 'ROIContourSequence'],
    '0x0040': ['SQ', '1', 'ContourSequence'],
    '0x0042': ['CS', '1', 'ContourGeometricType'],
    '0x0044': ['DS', '1', 'ContourSlabThickness'],
    '0x0045': ['DS', '3', 'ContourOffsetVector'],
    '0x0046': ['IS', '1', 'NumberOfContourPoints'],
    '0x0048': ['IS', '1', 'ContourNumber'],
    '0x0049': ['IS', '1-n', 'AttachedContours'],
    '0x004A': ['SQ', '1', 'SourcePixelPlanesCharacteristicsSequence'],
    '0x0050': ['DS', '3-3n', 'ContourData'],
    '0x0080': ['SQ', '1', 'RTROIObservationsSequence'],
    '0x0082': ['IS', '1', 'ObservationNumber'],
    '0x0084': ['IS', '1', 'ReferencedROINumber'],
    '0x0085': ['SH', '1', 'ROIObservationLabel'],
    '0x0086': ['SQ', '1', 'RTROIIdentificationCodeSequence'],
    '0x0088': ['ST', '1', 'ROIObservationDescription'],
    '0x00A0': ['SQ', '1', 'RelatedRTROIObservationsSequence'],
    '0x00A4': ['CS', '1', 'RTROIInterpretedType'],
    '0x00A6': ['PN', '1', 'ROIInterpreter'],
    '0x00B0': ['SQ', '1', 'ROIPhysicalPropertiesSequence'],
    '0x00B2': ['CS', '1', 'ROIPhysicalProperty'],
    '0x00B4': ['DS', '1', 'ROIPhysicalPropertyValue'],
    '0x00B6': ['SQ', '1', 'ROIElementalCompositionSequence'],
    '0x00B7': ['US', '1', 'ROIElementalCompositionAtomicNumber'],
    '0x00B8': ['FL', '1', 'ROIElementalCompositionAtomicMassFraction'],
    '0x00B9': ['SQ', '1', 'AdditionalRTROIIdentificationCodeSequence'],
    '0x00C0': ['SQ', '1', 'FrameOfReferenceRelationshipSequence'],
    '0x00C2': ['UI', '1', 'RelatedFrameOfReferenceUID'],
    '0x00C4': ['CS', '1', 'FrameOfReferenceTransformationType'],
    '0x00C6': ['DS', '16', 'FrameOfReferenceTransformationMatrix'],
    '0x00C8': ['LO', '1', 'FrameOfReferenceTransformationComment'],
    '0x00C9': ['SQ', '1', 'PatientLocationCoordinatesSequence'],
    '0x00CA': ['SQ', '1', 'PatientLocationCoordinatesCodeSequence'],
    '0x00CB': ['SQ', '1', 'PatientSupportPositionSequence']
  },
  '0x3008': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0010': ['SQ', '1', 'MeasuredDoseReferenceSequence'],
    '0x0012': ['ST', '1', 'MeasuredDoseDescription'],
    '0x0014': ['CS', '1', 'MeasuredDoseType'],
    '0x0016': ['DS', '1', 'MeasuredDoseValue'],
    '0x0020': ['SQ', '1', 'TreatmentSessionBeamSequence'],
    '0x0021': ['SQ', '1', 'TreatmentSessionIonBeamSequence'],
    '0x0022': ['IS', '1', 'CurrentFractionNumber'],
    '0x0024': ['DA', '1', 'TreatmentControlPointDate'],
    '0x0025': ['TM', '1', 'TreatmentControlPointTime'],
    '0x002A': ['CS', '1', 'TreatmentTerminationStatus'],
    '0x002B': ['SH', '1', 'TreatmentTerminationCode'],
    '0x002C': ['CS', '1', 'TreatmentVerificationStatus'],
    '0x0030': ['SQ', '1', 'ReferencedTreatmentRecordSequence'],
    '0x0032': ['DS', '1', 'SpecifiedPrimaryMeterset'],
    '0x0033': ['DS', '1', 'SpecifiedSecondaryMeterset'],
    '0x0036': ['DS', '1', 'DeliveredPrimaryMeterset'],
    '0x0037': ['DS', '1', 'DeliveredSecondaryMeterset'],
    '0x003A': ['DS', '1', 'SpecifiedTreatmentTime'],
    '0x003B': ['DS', '1', 'DeliveredTreatmentTime'],
    '0x0040': ['SQ', '1', 'ControlPointDeliverySequence'],
    '0x0041': ['SQ', '1', 'IonControlPointDeliverySequence'],
    '0x0042': ['DS', '1', 'SpecifiedMeterset'],
    '0x0044': ['DS', '1', 'DeliveredMeterset'],
    '0x0045': ['FL', '1', 'MetersetRateSet'],
    '0x0046': ['FL', '1', 'MetersetRateDelivered'],
    '0x0047': ['FL', '1-n', 'ScanSpotMetersetsDelivered'],
    '0x0048': ['DS', '1', 'DoseRateDelivered'],
    '0x0050': ['SQ', '1', 'TreatmentSummaryCalculatedDoseReferenceSequence'],
    '0x0052': ['DS', '1', 'CumulativeDoseToDoseReference'],
    '0x0054': ['DA', '1', 'FirstTreatmentDate'],
    '0x0056': ['DA', '1', 'MostRecentTreatmentDate'],
    '0x005A': ['IS', '1', 'NumberOfFractionsDelivered'],
    '0x0060': ['SQ', '1', 'OverrideSequence'],
    '0x0061': ['AT', '1', 'ParameterSequencePointer'],
    '0x0062': ['AT', '1', 'OverrideParameterPointer'],
    '0x0063': ['IS', '1', 'ParameterItemIndex'],
    '0x0064': ['IS', '1', 'MeasuredDoseReferenceNumber'],
    '0x0065': ['AT', '1', 'ParameterPointer'],
    '0x0066': ['ST', '1', 'OverrideReason'],
    '0x0067': ['US', '1', 'ParameterValueNumber'],
    '0x0068': ['SQ', '1', 'CorrectedParameterSequence'],
    '0x006A': ['FL', '1', 'CorrectionValue'],
    '0x0070': ['SQ', '1', 'CalculatedDoseReferenceSequence'],
    '0x0072': ['IS', '1', 'CalculatedDoseReferenceNumber'],
    '0x0074': ['ST', '1', 'CalculatedDoseReferenceDescription'],
    '0x0076': ['DS', '1', 'CalculatedDoseReferenceDoseValue'],
    '0x0078': ['DS', '1', 'StartMeterset'],
    '0x007A': ['DS', '1', 'EndMeterset'],
    '0x0080': ['SQ', '1', 'ReferencedMeasuredDoseReferenceSequence'],
    '0x0082': ['IS', '1', 'ReferencedMeasuredDoseReferenceNumber'],
    '0x0090': ['SQ', '1', 'ReferencedCalculatedDoseReferenceSequence'],
    '0x0092': ['IS', '1', 'ReferencedCalculatedDoseReferenceNumber'],
    '0x00A0': ['SQ', '1', 'BeamLimitingDeviceLeafPairsSequence'],
    '0x00B0': ['SQ', '1', 'RecordedWedgeSequence'],
    '0x00C0': ['SQ', '1', 'RecordedCompensatorSequence'],
    '0x00D0': ['SQ', '1', 'RecordedBlockSequence'],
    '0x00D1': ['SQ', '1', 'RecordedBlockSlabSequence'],
    '0x00E0': ['SQ', '1', 'TreatmentSummaryMeasuredDoseReferenceSequence'],
    '0x00F0': ['SQ', '1', 'RecordedSnoutSequence'],
    '0x00F2': ['SQ', '1', 'RecordedRangeShifterSequence'],
    '0x00F4': ['SQ', '1', 'RecordedLateralSpreadingDeviceSequence'],
    '0x00F6': ['SQ', '1', 'RecordedRangeModulatorSequence'],
    '0x0100': ['SQ', '1', 'RecordedSourceSequence'],
    '0x0105': ['LO', '1', 'SourceSerialNumber'],
    '0x0110': ['SQ', '1', 'TreatmentSessionApplicationSetupSequence'],
    '0x0116': ['CS', '1', 'ApplicationSetupCheck'],
    '0x0120': ['SQ', '1', 'RecordedBrachyAccessoryDeviceSequence'],
    '0x0122': ['IS', '1', 'ReferencedBrachyAccessoryDeviceNumber'],
    '0x0130': ['SQ', '1', 'RecordedChannelSequence'],
    '0x0132': ['DS', '1', 'SpecifiedChannelTotalTime'],
    '0x0134': ['DS', '1', 'DeliveredChannelTotalTime'],
    '0x0136': ['IS', '1', 'SpecifiedNumberOfPulses'],
    '0x0138': ['IS', '1', 'DeliveredNumberOfPulses'],
    '0x013A': ['DS', '1', 'SpecifiedPulseRepetitionInterval'],
    '0x013C': ['DS', '1', 'DeliveredPulseRepetitionInterval'],
    '0x0140': ['SQ', '1', 'RecordedSourceApplicatorSequence'],
    '0x0142': ['IS', '1', 'ReferencedSourceApplicatorNumber'],
    '0x0150': ['SQ', '1', 'RecordedChannelShieldSequence'],
    '0x0152': ['IS', '1', 'ReferencedChannelShieldNumber'],
    '0x0160': ['SQ', '1', 'BrachyControlPointDeliveredSequence'],
    '0x0162': ['DA', '1', 'SafePositionExitDate'],
    '0x0164': ['TM', '1', 'SafePositionExitTime'],
    '0x0166': ['DA', '1', 'SafePositionReturnDate'],
    '0x0168': ['TM', '1', 'SafePositionReturnTime'],
    '0x0171': ['SQ', '1', 'PulseSpecificBrachyControlPointDeliveredSequence'],
    '0x0172': ['US', '1', 'PulseNumber'],
    '0x0173': ['SQ', '1', 'BrachyPulseControlPointDeliveredSequence'],
    '0x0200': ['CS', '1', 'CurrentTreatmentStatus'],
    '0x0202': ['ST', '1', 'TreatmentStatusComment'],
    '0x0220': ['SQ', '1', 'FractionGroupSummarySequence'],
    '0x0223': ['IS', '1', 'ReferencedFractionNumber'],
    '0x0224': ['CS', '1', 'FractionGroupType'],
    '0x0230': ['CS', '1', 'BeamStopperPosition'],
    '0x0240': ['SQ', '1', 'FractionStatusSummarySequence'],
    '0x0250': ['DA', '1', 'TreatmentDate'],
    '0x0251': ['TM', '1', 'TreatmentTime']
  },
  '0x300A': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0002': ['SH', '1', 'RTPlanLabel'],
    '0x0003': ['LO', '1', 'RTPlanName'],
    '0x0004': ['ST', '1', 'RTPlanDescription'],
    '0x0006': ['DA', '1', 'RTPlanDate'],
    '0x0007': ['TM', '1', 'RTPlanTime'],
    '0x0009': ['LO', '1-n', 'TreatmentProtocols'],
    '0x000A': ['CS', '1', 'PlanIntent'],
    '0x000B': ['LO', '1-n', 'TreatmentSites'],
    '0x000C': ['CS', '1', 'RTPlanGeometry'],
    '0x000E': ['ST', '1', 'PrescriptionDescription'],
    '0x0010': ['SQ', '1', 'DoseReferenceSequence'],
    '0x0012': ['IS', '1', 'DoseReferenceNumber'],
    '0x0013': ['UI', '1', 'DoseReferenceUID'],
    '0x0014': ['CS', '1', 'DoseReferenceStructureType'],
    '0x0015': ['CS', '1', 'NominalBeamEnergyUnit'],
    '0x0016': ['LO', '1', 'DoseReferenceDescription'],
    '0x0018': ['DS', '3', 'DoseReferencePointCoordinates'],
    '0x001A': ['DS', '1', 'NominalPriorDose'],
    '0x0020': ['CS', '1', 'DoseReferenceType'],
    '0x0021': ['DS', '1', 'ConstraintWeight'],
    '0x0022': ['DS', '1', 'DeliveryWarningDose'],
    '0x0023': ['DS', '1', 'DeliveryMaximumDose'],
    '0x0025': ['DS', '1', 'TargetMinimumDose'],
    '0x0026': ['DS', '1', 'TargetPrescriptionDose'],
    '0x0027': ['DS', '1', 'TargetMaximumDose'],
    '0x0028': ['DS', '1', 'TargetUnderdoseVolumeFraction'],
    '0x002A': ['DS', '1', 'OrganAtRiskFullVolumeDose'],
    '0x002B': ['DS', '1', 'OrganAtRiskLimitDose'],
    '0x002C': ['DS', '1', 'OrganAtRiskMaximumDose'],
    '0x002D': ['DS', '1', 'OrganAtRiskOverdoseVolumeFraction'],
    '0x0040': ['SQ', '1', 'ToleranceTableSequence'],
    '0x0042': ['IS', '1', 'ToleranceTableNumber'],
    '0x0043': ['SH', '1', 'ToleranceTableLabel'],
    '0x0044': ['DS', '1', 'GantryAngleTolerance'],
    '0x0046': ['DS', '1', 'BeamLimitingDeviceAngleTolerance'],
    '0x0048': ['SQ', '1', 'BeamLimitingDeviceToleranceSequence'],
    '0x004A': ['DS', '1', 'BeamLimitingDevicePositionTolerance'],
    '0x004B': ['FL', '1', 'SnoutPositionTolerance'],
    '0x004C': ['DS', '1', 'PatientSupportAngleTolerance'],
    '0x004E': ['DS', '1', 'TableTopEccentricAngleTolerance'],
    '0x004F': ['FL', '1', 'TableTopPitchAngleTolerance'],
    '0x0050': ['FL', '1', 'TableTopRollAngleTolerance'],
    '0x0051': ['DS', '1', 'TableTopVerticalPositionTolerance'],
    '0x0052': ['DS', '1', 'TableTopLongitudinalPositionTolerance'],
    '0x0053': ['DS', '1', 'TableTopLateralPositionTolerance'],
    '0x0055': ['CS', '1', 'RTPlanRelationship'],
    '0x0070': ['SQ', '1', 'FractionGroupSequence'],
    '0x0071': ['IS', '1', 'FractionGroupNumber'],
    '0x0072': ['LO', '1', 'FractionGroupDescription'],
    '0x0078': ['IS', '1', 'NumberOfFractionsPlanned'],
    '0x0079': ['IS', '1', 'NumberOfFractionPatternDigitsPerDay'],
    '0x007A': ['IS', '1', 'RepeatFractionCycleLength'],
    '0x007B': ['LT', '1', 'FractionPattern'],
    '0x0080': ['IS', '1', 'NumberOfBeams'],
    '0x0082': ['DS', '3', 'BeamDoseSpecificationPoint'],
    '0x0083': ['UI', '1', 'ReferencedDoseReferenceUID'],
    '0x0084': ['DS', '1', 'BeamDose'],
    '0x0086': ['DS', '1', 'BeamMeterset'],
    '0x0088': ['FL', '1', 'BeamDosePointDepth'],
    '0x0089': ['FL', '1', 'BeamDosePointEquivalentDepth'],
    '0x008A': ['FL', '1', 'BeamDosePointSSD'],
    '0x008B': ['CS', '1', 'BeamDoseMeaning'],
    '0x008C': ['SQ', '1', 'BeamDoseVerificationControlPointSequence'],
    '0x008D': ['FL', '1', 'AverageBeamDosePointDepth'],
    '0x008E': ['FL', '1', 'AverageBeamDosePointEquivalentDepth'],
    '0x008F': ['FL', '1', 'AverageBeamDosePointSSD'],
    '0x0090': ['CS', '1', 'BeamDoseType'],
    '0x0091': ['DS', '1', 'AlternateBeamDose'],
    '0x0092': ['CS', '1', 'AlternateBeamDoseType'],
    '0x0093': ['CS', '1', 'DepthValueAveragingFlag'],
    '0x0094': ['DS', '1', 'BeamDosePointSourceToExternalContourDistance'],
    '0x00A0': ['IS', '1', 'NumberOfBrachyApplicationSetups'],
    '0x00A2': ['DS', '3', 'BrachyApplicationSetupDoseSpecificationPoint'],
    '0x00A4': ['DS', '1', 'BrachyApplicationSetupDose'],
    '0x00B0': ['SQ', '1', 'BeamSequence'],
    '0x00B2': ['SH', '1', 'TreatmentMachineName'],
    '0x00B3': ['CS', '1', 'PrimaryDosimeterUnit'],
    '0x00B4': ['DS', '1', 'SourceAxisDistance'],
    '0x00B6': ['SQ', '1', 'BeamLimitingDeviceSequence'],
    '0x00B8': ['CS', '1', 'RTBeamLimitingDeviceType'],
    '0x00BA': ['DS', '1', 'SourceToBeamLimitingDeviceDistance'],
    '0x00BB': ['FL', '1', 'IsocenterToBeamLimitingDeviceDistance'],
    '0x00BC': ['IS', '1', 'NumberOfLeafJawPairs'],
    '0x00BE': ['DS', '3-n', 'LeafPositionBoundaries'],
    '0x00C0': ['IS', '1', 'BeamNumber'],
    '0x00C2': ['LO', '1', 'BeamName'],
    '0x00C3': ['ST', '1', 'BeamDescription'],
    '0x00C4': ['CS', '1', 'BeamType'],
    '0x00C5': ['FD', '1', 'BeamDeliveryDurationLimit'],
    '0x00C6': ['CS', '1', 'RadiationType'],
    '0x00C7': ['CS', '1', 'HighDoseTechniqueType'],
    '0x00C8': ['IS', '1', 'ReferenceImageNumber'],
    '0x00CA': ['SQ', '1', 'PlannedVerificationImageSequence'],
    '0x00CC': ['LO', '1-n', 'ImagingDeviceSpecificAcquisitionParameters'],
    '0x00CE': ['CS', '1', 'TreatmentDeliveryType'],
    '0x00D0': ['IS', '1', 'NumberOfWedges'],
    '0x00D1': ['SQ', '1', 'WedgeSequence'],
    '0x00D2': ['IS', '1', 'WedgeNumber'],
    '0x00D3': ['CS', '1', 'WedgeType'],
    '0x00D4': ['SH', '1', 'WedgeID'],
    '0x00D5': ['IS', '1', 'WedgeAngle'],
    '0x00D6': ['DS', '1', 'WedgeFactor'],
    '0x00D7': ['FL', '1', 'TotalWedgeTrayWaterEquivalentThickness'],
    '0x00D8': ['DS', '1', 'WedgeOrientation'],
    '0x00D9': ['FL', '1', 'IsocenterToWedgeTrayDistance'],
    '0x00DA': ['DS', '1', 'SourceToWedgeTrayDistance'],
    '0x00DB': ['FL', '1', 'WedgeThinEdgePosition'],
    '0x00DC': ['SH', '1', 'BolusID'],
    '0x00DD': ['ST', '1', 'BolusDescription'],
    '0x00DE': ['DS', '1', 'EffectiveWedgeAngle'],
    '0x00E0': ['IS', '1', 'NumberOfCompensators'],
    '0x00E1': ['SH', '1', 'MaterialID'],
    '0x00E2': ['DS', '1', 'TotalCompensatorTrayFactor'],
    '0x00E3': ['SQ', '1', 'CompensatorSequence'],
    '0x00E4': ['IS', '1', 'CompensatorNumber'],
    '0x00E5': ['SH', '1', 'CompensatorID'],
    '0x00E6': ['DS', '1', 'SourceToCompensatorTrayDistance'],
    '0x00E7': ['IS', '1', 'CompensatorRows'],
    '0x00E8': ['IS', '1', 'CompensatorColumns'],
    '0x00E9': ['DS', '2', 'CompensatorPixelSpacing'],
    '0x00EA': ['DS', '2', 'CompensatorPosition'],
    '0x00EB': ['DS', '1-n', 'CompensatorTransmissionData'],
    '0x00EC': ['DS', '1-n', 'CompensatorThicknessData'],
    '0x00ED': ['IS', '1', 'NumberOfBoli'],
    '0x00EE': ['CS', '1', 'CompensatorType'],
    '0x00EF': ['SH', '1', 'CompensatorTrayID'],
    '0x00F0': ['IS', '1', 'NumberOfBlocks'],
    '0x00F2': ['DS', '1', 'TotalBlockTrayFactor'],
    '0x00F3': ['FL', '1', 'TotalBlockTrayWaterEquivalentThickness'],
    '0x00F4': ['SQ', '1', 'BlockSequence'],
    '0x00F5': ['SH', '1', 'BlockTrayID'],
    '0x00F6': ['DS', '1', 'SourceToBlockTrayDistance'],
    '0x00F7': ['FL', '1', 'IsocenterToBlockTrayDistance'],
    '0x00F8': ['CS', '1', 'BlockType'],
    '0x00F9': ['LO', '1', 'AccessoryCode'],
    '0x00FA': ['CS', '1', 'BlockDivergence'],
    '0x00FB': ['CS', '1', 'BlockMountingPosition'],
    '0x00FC': ['IS', '1', 'BlockNumber'],
    '0x00FE': ['LO', '1', 'BlockName'],
    '0x0100': ['DS', '1', 'BlockThickness'],
    '0x0102': ['DS', '1', 'BlockTransmission'],
    '0x0104': ['IS', '1', 'BlockNumberOfPoints'],
    '0x0106': ['DS', '2-2n', 'BlockData'],
    '0x0107': ['SQ', '1', 'ApplicatorSequence'],
    '0x0108': ['SH', '1', 'ApplicatorID'],
    '0x0109': ['CS', '1', 'ApplicatorType'],
    '0x010A': ['LO', '1', 'ApplicatorDescription'],
    '0x010C': ['DS', '1', 'CumulativeDoseReferenceCoefficient'],
    '0x010E': ['DS', '1', 'FinalCumulativeMetersetWeight'],
    '0x0110': ['IS', '1', 'NumberOfControlPoints'],
    '0x0111': ['SQ', '1', 'ControlPointSequence'],
    '0x0112': ['IS', '1', 'ControlPointIndex'],
    '0x0114': ['DS', '1', 'NominalBeamEnergy'],
    '0x0115': ['DS', '1', 'DoseRateSet'],
    '0x0116': ['SQ', '1', 'WedgePositionSequence'],
    '0x0118': ['CS', '1', 'WedgePosition'],
    '0x011A': ['SQ', '1', 'BeamLimitingDevicePositionSequence'],
    '0x011C': ['DS', '2-2n', 'LeafJawPositions'],
    '0x011E': ['DS', '1', 'GantryAngle'],
    '0x011F': ['CS', '1', 'GantryRotationDirection'],
    '0x0120': ['DS', '1', 'BeamLimitingDeviceAngle'],
    '0x0121': ['CS', '1', 'BeamLimitingDeviceRotationDirection'],
    '0x0122': ['DS', '1', 'PatientSupportAngle'],
    '0x0123': ['CS', '1', 'PatientSupportRotationDirection'],
    '0x0124': ['DS', '1', 'TableTopEccentricAxisDistance'],
    '0x0125': ['DS', '1', 'TableTopEccentricAngle'],
    '0x0126': ['CS', '1', 'TableTopEccentricRotationDirection'],
    '0x0128': ['DS', '1', 'TableTopVerticalPosition'],
    '0x0129': ['DS', '1', 'TableTopLongitudinalPosition'],
    '0x012A': ['DS', '1', 'TableTopLateralPosition'],
    '0x012C': ['DS', '3', 'IsocenterPosition'],
    '0x012E': ['DS', '3', 'SurfaceEntryPoint'],
    '0x0130': ['DS', '1', 'SourceToSurfaceDistance'],
    '0x0131': ['FL', '1', 'AverageBeamDosePointSourceToExternalContourDistance'],
    '0x0132': ['FL', '1', 'SourceToExternalContourDistance'],
    '0x0133': ['FL', '3', 'ExternalContourEntryPoint'],
    '0x0134': ['DS', '1', 'CumulativeMetersetWeight'],
    '0x0140': ['FL', '1', 'TableTopPitchAngle'],
    '0x0142': ['CS', '1', 'TableTopPitchRotationDirection'],
    '0x0144': ['FL', '1', 'TableTopRollAngle'],
    '0x0146': ['CS', '1', 'TableTopRollRotationDirection'],
    '0x0148': ['FL', '1', 'HeadFixationAngle'],
    '0x014A': ['FL', '1', 'GantryPitchAngle'],
    '0x014C': ['CS', '1', 'GantryPitchRotationDirection'],
    '0x014E': ['FL', '1', 'GantryPitchAngleTolerance'],
    '0x0150': ['CS', '1', 'FixationEye'],
    '0x0151': ['DS', '1', 'ChairHeadFramePosition'],
    '0x0152': ['DS', '1', 'HeadFixationAngleTolerance'],
    '0x0153': ['DS', '1', 'ChairHeadFramePositionTolerance'],
    '0x0154': ['DS', '1', 'FixationLightAzimuthalAngleTolerance'],
    '0x0155': ['DS', '1', 'FixationLightPolarAngleTolerance'],
    '0x0180': ['SQ', '1', 'PatientSetupSequence'],
    '0x0182': ['IS', '1', 'PatientSetupNumber'],
    '0x0183': ['LO', '1', 'PatientSetupLabel'],
    '0x0184': ['LO', '1', 'PatientAdditionalPosition'],
    '0x0190': ['SQ', '1', 'FixationDeviceSequence'],
    '0x0192': ['CS', '1', 'FixationDeviceType'],
    '0x0194': ['SH', '1', 'FixationDeviceLabel'],
    '0x0196': ['ST', '1', 'FixationDeviceDescription'],
    '0x0198': ['SH', '1', 'FixationDevicePosition'],
    '0x0199': ['FL', '1', 'FixationDevicePitchAngle'],
    '0x019A': ['FL', '1', 'FixationDeviceRollAngle'],
    '0x01A0': ['SQ', '1', 'ShieldingDeviceSequence'],
    '0x01A2': ['CS', '1', 'ShieldingDeviceType'],
    '0x01A4': ['SH', '1', 'ShieldingDeviceLabel'],
    '0x01A6': ['ST', '1', 'ShieldingDeviceDescription'],
    '0x01A8': ['SH', '1', 'ShieldingDevicePosition'],
    '0x01B0': ['CS', '1', 'SetupTechnique'],
    '0x01B2': ['ST', '1', 'SetupTechniqueDescription'],
    '0x01B4': ['SQ', '1', 'SetupDeviceSequence'],
    '0x01B6': ['CS', '1', 'SetupDeviceType'],
    '0x01B8': ['SH', '1', 'SetupDeviceLabel'],
    '0x01BA': ['ST', '1', 'SetupDeviceDescription'],
    '0x01BC': ['DS', '1', 'SetupDeviceParameter'],
    '0x01D0': ['ST', '1', 'SetupReferenceDescription'],
    '0x01D2': ['DS', '1', 'TableTopVerticalSetupDisplacement'],
    '0x01D4': ['DS', '1', 'TableTopLongitudinalSetupDisplacement'],
    '0x01D6': ['DS', '1', 'TableTopLateralSetupDisplacement'],
    '0x0200': ['CS', '1', 'BrachyTreatmentTechnique'],
    '0x0202': ['CS', '1', 'BrachyTreatmentType'],
    '0x0206': ['SQ', '1', 'TreatmentMachineSequence'],
    '0x0210': ['SQ', '1', 'SourceSequence'],
    '0x0212': ['IS', '1', 'SourceNumber'],
    '0x0214': ['CS', '1', 'SourceType'],
    '0x0216': ['LO', '1', 'SourceManufacturer'],
    '0x0218': ['DS', '1', 'ActiveSourceDiameter'],
    '0x021A': ['DS', '1', 'ActiveSourceLength'],
    '0x021B': ['SH', '1', 'SourceModelID'],
    '0x021C': ['LO', '1', 'SourceDescription'],
    '0x0222': ['DS', '1', 'SourceEncapsulationNominalThickness'],
    '0x0224': ['DS', '1', 'SourceEncapsulationNominalTransmission'],
    '0x0226': ['LO', '1', 'SourceIsotopeName'],
    '0x0228': ['DS', '1', 'SourceIsotopeHalfLife'],
    '0x0229': ['CS', '1', 'SourceStrengthUnits'],
    '0x022A': ['DS', '1', 'ReferenceAirKermaRate'],
    '0x022B': ['DS', '1', 'SourceStrength'],
    '0x022C': ['DA', '1', 'SourceStrengthReferenceDate'],
    '0x022E': ['TM', '1', 'SourceStrengthReferenceTime'],
    '0x0230': ['SQ', '1', 'ApplicationSetupSequence'],
    '0x0232': ['CS', '1', 'ApplicationSetupType'],
    '0x0234': ['IS', '1', 'ApplicationSetupNumber'],
    '0x0236': ['LO', '1', 'ApplicationSetupName'],
    '0x0238': ['LO', '1', 'ApplicationSetupManufacturer'],
    '0x0240': ['IS', '1', 'TemplateNumber'],
    '0x0242': ['SH', '1', 'TemplateType'],
    '0x0244': ['LO', '1', 'TemplateName'],
    '0x0250': ['DS', '1', 'TotalReferenceAirKerma'],
    '0x0260': ['SQ', '1', 'BrachyAccessoryDeviceSequence'],
    '0x0262': ['IS', '1', 'BrachyAccessoryDeviceNumber'],
    '0x0263': ['SH', '1', 'BrachyAccessoryDeviceID'],
    '0x0264': ['CS', '1', 'BrachyAccessoryDeviceType'],
    '0x0266': ['LO', '1', 'BrachyAccessoryDeviceName'],
    '0x026A': ['DS', '1', 'BrachyAccessoryDeviceNominalThickness'],
    '0x026C': ['DS', '1', 'BrachyAccessoryDeviceNominalTransmission'],
    '0x0271': ['DS', '1', 'ChannelEffectiveLength'],
    '0x0272': ['DS', '1', 'ChannelInnerLength'],
    '0x0273': ['SH', '1', 'AfterloaderChannelID'],
    '0x0274': ['DS', '1', 'SourceApplicatorTipLength'],
    '0x0280': ['SQ', '1', 'ChannelSequence'],
    '0x0282': ['IS', '1', 'ChannelNumber'],
    '0x0284': ['DS', '1', 'ChannelLength'],
    '0x0286': ['DS', '1', 'ChannelTotalTime'],
    '0x0288': ['CS', '1', 'SourceMovementType'],
    '0x028A': ['IS', '1', 'NumberOfPulses'],
    '0x028C': ['DS', '1', 'PulseRepetitionInterval'],
    '0x0290': ['IS', '1', 'SourceApplicatorNumber'],
    '0x0291': ['SH', '1', 'SourceApplicatorID'],
    '0x0292': ['CS', '1', 'SourceApplicatorType'],
    '0x0294': ['LO', '1', 'SourceApplicatorName'],
    '0x0296': ['DS', '1', 'SourceApplicatorLength'],
    '0x0298': ['LO', '1', 'SourceApplicatorManufacturer'],
    '0x029C': ['DS', '1', 'SourceApplicatorWallNominalThickness'],
    '0x029E': ['DS', '1', 'SourceApplicatorWallNominalTransmission'],
    '0x02A0': ['DS', '1', 'SourceApplicatorStepSize'],
    '0x02A1': ['IS', '1', 'ApplicatorShapeReferencedROINumber'],
    '0x02A2': ['IS', '1', 'TransferTubeNumber'],
    '0x02A4': ['DS', '1', 'TransferTubeLength'],
    '0x02B0': ['SQ', '1', 'ChannelShieldSequence'],
    '0x02B2': ['IS', '1', 'ChannelShieldNumber'],
    '0x02B3': ['SH', '1', 'ChannelShieldID'],
    '0x02B4': ['LO', '1', 'ChannelShieldName'],
    '0x02B8': ['DS', '1', 'ChannelShieldNominalThickness'],
    '0x02BA': ['DS', '1', 'ChannelShieldNominalTransmission'],
    '0x02C8': ['DS', '1', 'FinalCumulativeTimeWeight'],
    '0x02D0': ['SQ', '1', 'BrachyControlPointSequence'],
    '0x02D2': ['DS', '1', 'ControlPointRelativePosition'],
    '0x02D4': ['DS', '3', 'ControlPoint3DPosition'],
    '0x02D6': ['DS', '1', 'CumulativeTimeWeight'],
    '0x02E0': ['CS', '1', 'CompensatorDivergence'],
    '0x02E1': ['CS', '1', 'CompensatorMountingPosition'],
    '0x02E2': ['DS', '1-n', 'SourceToCompensatorDistance'],
    '0x02E3': ['FL', '1', 'TotalCompensatorTrayWaterEquivalentThickness'],
    '0x02E4': ['FL', '1', 'IsocenterToCompensatorTrayDistance'],
    '0x02E5': ['FL', '1', 'CompensatorColumnOffset'],
    '0x02E6': ['FL', '1-n', 'IsocenterToCompensatorDistances'],
    '0x02E7': ['FL', '1', 'CompensatorRelativeStoppingPowerRatio'],
    '0x02E8': ['FL', '1', 'CompensatorMillingToolDiameter'],
    '0x02EA': ['SQ', '1', 'IonRangeCompensatorSequence'],
    '0x02EB': ['LT', '1', 'CompensatorDescription'],
    '0x0302': ['IS', '1', 'RadiationMassNumber'],
    '0x0304': ['IS', '1', 'RadiationAtomicNumber'],
    '0x0306': ['SS', '1', 'RadiationChargeState'],
    '0x0308': ['CS', '1', 'ScanMode'],
    '0x0309': ['CS', '1', 'ModulatedScanModeType'],
    '0x030A': ['FL', '2', 'VirtualSourceAxisDistances'],
    '0x030C': ['SQ', '1', 'SnoutSequence'],
    '0x030D': ['FL', '1', 'SnoutPosition'],
    '0x030F': ['SH', '1', 'SnoutID'],
    '0x0312': ['IS', '1', 'NumberOfRangeShifters'],
    '0x0314': ['SQ', '1', 'RangeShifterSequence'],
    '0x0316': ['IS', '1', 'RangeShifterNumber'],
    '0x0318': ['SH', '1', 'RangeShifterID'],
    '0x0320': ['CS', '1', 'RangeShifterType'],
    '0x0322': ['LO', '1', 'RangeShifterDescription'],
    '0x0330': ['IS', '1', 'NumberOfLateralSpreadingDevices'],
    '0x0332': ['SQ', '1', 'LateralSpreadingDeviceSequence'],
    '0x0334': ['IS', '1', 'LateralSpreadingDeviceNumber'],
    '0x0336': ['SH', '1', 'LateralSpreadingDeviceID'],
    '0x0338': ['CS', '1', 'LateralSpreadingDeviceType'],
    '0x033A': ['LO', '1', 'LateralSpreadingDeviceDescription'],
    '0x033C': ['FL', '1', 'LateralSpreadingDeviceWaterEquivalentThickness'],
    '0x0340': ['IS', '1', 'NumberOfRangeModulators'],
    '0x0342': ['SQ', '1', 'RangeModulatorSequence'],
    '0x0344': ['IS', '1', 'RangeModulatorNumber'],
    '0x0346': ['SH', '1', 'RangeModulatorID'],
    '0x0348': ['CS', '1', 'RangeModulatorType'],
    '0x034A': ['LO', '1', 'RangeModulatorDescription'],
    '0x034C': ['SH', '1', 'BeamCurrentModulationID'],
    '0x0350': ['CS', '1', 'PatientSupportType'],
    '0x0352': ['SH', '1', 'PatientSupportID'],
    '0x0354': ['LO', '1', 'PatientSupportAccessoryCode'],
    '0x0355': ['LO', '1', 'TrayAccessoryCode'],
    '0x0356': ['FL', '1', 'FixationLightAzimuthalAngle'],
    '0x0358': ['FL', '1', 'FixationLightPolarAngle'],
    '0x035A': ['FL', '1', 'MetersetRate'],
    '0x0360': ['SQ', '1', 'RangeShifterSettingsSequence'],
    '0x0362': ['LO', '1', 'RangeShifterSetting'],
    '0x0364': ['FL', '1', 'IsocenterToRangeShifterDistance'],
    '0x0366': ['FL', '1', 'RangeShifterWaterEquivalentThickness'],
    '0x0370': ['SQ', '1', 'LateralSpreadingDeviceSettingsSequence'],
    '0x0372': ['LO', '1', 'LateralSpreadingDeviceSetting'],
    '0x0374': ['FL', '1', 'IsocenterToLateralSpreadingDeviceDistance'],
    '0x0380': ['SQ', '1', 'RangeModulatorSettingsSequence'],
    '0x0382': ['FL', '1', 'RangeModulatorGatingStartValue'],
    '0x0384': ['FL', '1', 'RangeModulatorGatingStopValue'],
    '0x0386': ['FL', '1', 'RangeModulatorGatingStartWaterEquivalentThickness'],
    '0x0388': ['FL', '1', 'RangeModulatorGatingStopWaterEquivalentThickness'],
    '0x038A': ['FL', '1', 'IsocenterToRangeModulatorDistance'],
    '0x038F': ['FL', '1-n', 'ScanSpotTimeOffset'],
    '0x0390': ['SH', '1', 'ScanSpotTuneID'],
    '0x0391': ['IS', '1-n', 'ScanSpotPrescribedIndices'],
    '0x0392': ['IS', '1', 'NumberOfScanSpotPositions'],
    '0x0393': ['CS', '1', 'ScanSpotReordered'],
    '0x0394': ['FL', '1-n', 'ScanSpotPositionMap'],
    '0x0395': ['CS', '1', 'ScanSpotReorderingAllowed'],
    '0x0396': ['FL', '1-n', 'ScanSpotMetersetWeights'],
    '0x0398': ['FL', '2', 'ScanningSpotSize'],
    '0x0399': ['FL', '2-2n', 'ScanSpotSizesDelivered'],
    '0x039A': ['IS', '1', 'NumberOfPaintings'],
    '0x03A0': ['SQ', '1', 'IonToleranceTableSequence'],
    '0x03A2': ['SQ', '1', 'IonBeamSequence'],
    '0x03A4': ['SQ', '1', 'IonBeamLimitingDeviceSequence'],
    '0x03A6': ['SQ', '1', 'IonBlockSequence'],
    '0x03A8': ['SQ', '1', 'IonControlPointSequence'],
    '0x03AA': ['SQ', '1', 'IonWedgeSequence'],
    '0x03AC': ['SQ', '1', 'IonWedgePositionSequence'],
    '0x0401': ['SQ', '1', 'ReferencedSetupImageSequence'],
    '0x0402': ['ST', '1', 'SetupImageComment'],
    '0x0410': ['SQ', '1', 'MotionSynchronizationSequence'],
    '0x0412': ['FL', '3', 'ControlPointOrientation'],
    '0x0420': ['SQ', '1', 'GeneralAccessorySequence'],
    '0x0421': ['SH', '1', 'GeneralAccessoryID'],
    '0x0422': ['ST', '1', 'GeneralAccessoryDescription'],
    '0x0423': ['CS', '1', 'GeneralAccessoryType'],
    '0x0424': ['IS', '1', 'GeneralAccessoryNumber'],
    '0x0425': ['FL', '1', 'SourceToGeneralAccessoryDistance'],
    '0x0426': ['DS', '1', 'IsocenterToGeneralAccessoryDistance'],
    '0x0431': ['SQ', '1', 'ApplicatorGeometrySequence'],
    '0x0432': ['CS', '1', 'ApplicatorApertureShape'],
    '0x0433': ['FL', '1', 'ApplicatorOpening'],
    '0x0434': ['FL', '1', 'ApplicatorOpeningX'],
    '0x0435': ['FL', '1', 'ApplicatorOpeningY'],
    '0x0436': ['FL', '1', 'SourceToApplicatorMountingPositionDistance'],
    '0x0440': ['IS', '1', 'NumberOfBlockSlabItems'],
    '0x0441': ['SQ', '1', 'BlockSlabSequence'],
    '0x0442': ['DS', '1', 'BlockSlabThickness'],
    '0x0443': ['US', '1', 'BlockSlabNumber'],
    '0x0450': ['SQ', '1', 'DeviceMotionControlSequence'],
    '0x0451': ['CS', '1', 'DeviceMotionExecutionMode'],
    '0x0452': ['CS', '1', 'DeviceMotionObservationMode'],
    '0x0453': ['SQ', '1', 'DeviceMotionParameterCodeSequence'],
    '0x0501': ['FL', '1', 'DistalDepthFraction'],
    '0x0502': ['FL', '1', 'DistalDepth'],
    '0x0503': ['FL', '2', 'NominalRangeModulationFractions'],
    '0x0504': ['FL', '2', 'NominalRangeModulatedRegionDepths'],
    '0x0505': ['SQ', '1', 'DepthDoseParametersSequence'],
    '0x0506': ['SQ', '1', 'DeliveredDepthDoseParametersSequence'],
    '0x0507': ['FL', '1', 'DeliveredDistalDepthFraction'],
    '0x0508': ['FL', '1', 'DeliveredDistalDepth'],
    '0x0509': ['FL', '2', 'DeliveredNominalRangeModulationFractions'],
    '0x0510': ['FL', '2', 'DeliveredNominalRangeModulatedRegionDepths'],
    '0x0511': ['CS', '1', 'DeliveredReferenceDoseDefinition'],
    '0x0512': ['CS', '1', 'ReferenceDoseDefinition'],
    '0x0600': ['US', '1', 'RTControlPointIndex'],
    '0x0601': ['US', '1', 'RadiationGenerationModeIndex'],
    '0x0602': ['US', '1', 'ReferencedDefinedDeviceIndex'],
    '0x0603': ['US', '1', 'RadiationDoseIdentificationIndex'],
    '0x0604': ['US', '1', 'NumberOfRTControlPoints'],
    '0x0605': ['US', '1', 'ReferencedRadiationGenerationModeIndex'],
    '0x0606': ['US', '1', 'TreatmentPositionIndex'],
    '0x0607': ['US', '1', 'ReferencedDeviceIndex'],
    '0x0608': ['LO', '1', 'TreatmentPositionGroupLabel'],
    '0x0609': ['UI', '1', 'TreatmentPositionGroupUID'],
    '0x060A': ['SQ', '1', 'TreatmentPositionGroupSequence'],
    '0x060B': ['US', '1', 'ReferencedTreatmentPositionIndex'],
    '0x060C': ['US', '1', 'ReferencedRadiationDoseIdentificationIndex'],
    '0x060D': ['FD', '1', 'RTAccessoryHolderWaterEquivalentThickness'],
    '0x060E': ['US', '1', 'ReferencedRTAccessoryHolderDeviceIndex'],
    '0x060F': ['CS', '1', 'RTAccessoryHolderSlotExistenceFlag'],
    '0x0610': ['SQ', '1', 'RTAccessoryHolderSlotSequence'],
    '0x0611': ['LO', '1', 'RTAccessoryHolderSlotID'],
    '0x0612': ['FD', '1', 'RTAccessoryHolderSlotDistance'],
    '0x0613': ['FD', '1', 'RTAccessorySlotDistance'],
    '0x0614': ['SQ', '1', 'RTAccessoryHolderDefinitionSequence'],
    '0x0615': ['LO', '1', 'RTAccessoryDeviceSlotID'],
    '0x0616': ['SQ', '1', 'RTRadiationSequence'],
    '0x0617': ['SQ', '1', 'RadiationDoseSequence'],
    '0x0618': ['SQ', '1', 'RadiationDoseIdentificationSequence'],
    '0x0619': ['LO', '1', 'RadiationDoseIdentificationLabel'],
    '0x061A': ['CS', '1', 'ReferenceDoseType'],
    '0x061B': ['CS', '1', 'PrimaryDoseValueIndicator'],
    '0x061C': ['SQ', '1', 'DoseValuesSequence'],
    '0x061D': ['CS', '1-n', 'DoseValuePurpose'],
    '0x061E': ['FD', '3', 'ReferenceDosePointCoordinates'],
    '0x061F': ['SQ', '1', 'RadiationDoseValuesParametersSequence'],
    '0x0620': ['SQ', '1', 'MetersetToDoseMappingSequence'],
    '0x0621': ['SQ', '1', 'ExpectedInVivoMeasurementValuesSequence'],
    '0x0622': ['US', '1', 'ExpectedInVivoMeasurementValueIndex'],
    '0x0623': ['LO', '1', 'RadiationDoseInVivoMeasurementLabel'],
    '0x0624': ['FD', '2', 'RadiationDoseCentralAxisDisplacement'],
    '0x0625': ['FD', '1', 'RadiationDoseValue'],
    '0x0626': ['FD', '1', 'RadiationDoseSourceToSkinDistance'],
    '0x0627': ['FD', '3', 'RadiationDoseMeasurementPointCoordinates'],
    '0x0628': ['FD', '1', 'RadiationDoseSourceToExternalContourDistance'],
    '0x0629': ['SQ', '1', 'RTToleranceSetSequence'],
    '0x062A': ['LO', '1', 'RTToleranceSetLabel'],
    '0x062B': ['SQ', '1', 'AttributeToleranceValuesSequence'],
    '0x062C': ['FD', '1', 'ToleranceValue'],
    '0x062D': ['SQ', '1', 'PatientSupportPositionToleranceSequence'],
    '0x062E': ['FD', '1', 'TreatmentTimeLimit'],
    '0x062F': ['SQ', '1', 'CArmPhotonElectronControlPointSequence'],
    '0x0630': ['SQ', '1', 'ReferencedRTRadiationSequence'],
    '0x0631': ['SQ', '1', 'ReferencedRTInstanceSequence'],
    '0x0632': ['SQ', '1', 'ReferencedRTPatientSetupSequence'],
    '0x0634': ['FD', '1', 'SourceToPatientSurfaceDistance'],
    '0x0635': ['SQ', '1', 'TreatmentMachineSpecialModeCodeSequence'],
    '0x0636': ['US', '1', 'IntendedNumberOfFractions'],
    '0x0637': ['CS', '1', 'RTRadiationSetIntent'],
    '0x0638': ['CS', '1', 'RTRadiationPhysicalAndGeometricContentDetailFlag'],
    '0x0639': ['CS', '1', 'RTRecordFlag'],
    '0x063A': ['SQ', '1', 'TreatmentDeviceIdentificationSequence'],
    '0x063B': ['SQ', '1', 'ReferencedRTPhysicianIntentSequence'],
    '0x063C': ['FD', '1', 'CumulativeMeterset'],
    '0x063D': ['FD', '1', 'DeliveryRate'],
    '0x063E': ['SQ', '1', 'DeliveryRateUnitSequence'],
    '0x063F': ['SQ', '1', 'TreatmentPositionSequence'],
    '0x0640': ['FD', '1', 'RadiationSourceAxisDistance'],
    '0x0641': ['US', '1', 'NumberOfRTBeamLimitingDevices'],
    '0x0642': ['FD', '1', 'RTBeamLimitingDeviceProximalDistance'],
    '0x0643': ['FD', '1', 'RTBeamLimitingDeviceDistalDistance'],
    '0x0644': ['SQ', '1', 'ParallelRTBeamDelimiterDeviceOrientationLabelCodeSequence'],
    '0x0645': ['FD', '1', 'BeamModifierOrientationAngle'],
    '0x0646': ['SQ', '1', 'FixedRTBeamDelimiterDeviceSequence'],
    '0x0647': ['SQ', '1', 'ParallelRTBeamDelimiterDeviceSequence'],
    '0x0648': ['US', '1', 'NumberOfParallelRTBeamDelimiters'],
    '0x0649': ['FD', '2-n', 'ParallelRTBeamDelimiterBoundaries'],
    '0x064A': ['FD', '2-n', 'ParallelRTBeamDelimiterPositions'],
    '0x064B': ['FD', '2', 'RTBeamLimitingDeviceOffset'],
    '0x064C': ['SQ', '1', 'RTBeamDelimiterGeometrySequence'],
    '0x064D': ['SQ', '1', 'RTBeamLimitingDeviceDefinitionSequence'],
    '0x064E': ['CS', '1', 'ParallelRTBeamDelimiterOpeningMode'],
    '0x064F': ['CS', '1-n', 'ParallelRTBeamDelimiterLeafMountingSide'],
    '0x0650': ['UI', '1', 'PatientSetupUID'],
    '0x0651': ['SQ', '1', 'WedgeDefinitionSequence'],
    '0x0652': ['FD', '1', 'RadiationBeamWedgeAngle'],
    '0x0653': ['FD', '1', 'RadiationBeamWedgeThinEdgeDistance'],
    '0x0654': ['FD', '1', 'RadiationBeamEffectiveWedgeAngle'],
    '0x0655': ['US', '1', 'NumberOfWedgePositions'],
    '0x0656': ['SQ', '1', 'RTBeamLimitingDeviceOpeningSequence'],
    '0x0657': ['US', '1', 'NumberOfRTBeamLimitingDeviceOpenings'],
    '0x0658': ['SQ', '1', 'RadiationDosimeterUnitSequence'],
    '0x0659': ['SQ', '1', 'RTDeviceDistanceReferenceLocationCodeSequence'],
    '0x065A': ['SQ', '1', 'RadiationDeviceConfigurationAndCommissioningKeySequence'],
    '0x065B': ['SQ', '1', 'PatientSupportPositionParameterSequence'],
    '0x065C': ['CS', '1', 'PatientSupportPositionSpecificationMethod'],
    '0x065D': ['SQ', '1', 'PatientSupportPositionDeviceParameterSequence'],
    '0x065E': ['US', '1', 'DeviceOrderIndex'],
    '0x065F': ['US', '1', 'PatientSupportPositionParameterOrderIndex'],
    '0x0660': ['SQ', '1', 'PatientSupportPositionDeviceToleranceSequence'],
    '0x0661': ['US', '1', 'PatientSupportPositionToleranceOrderIndex'],
    '0x0662': ['SQ', '1', 'CompensatorDefinitionSequence'],
    '0x0663': ['CS', '1', 'CompensatorMapOrientation'],
    '0x0664': ['OF', '1', 'CompensatorProximalThicknessMap'],
    '0x0665': ['OF', '1', 'CompensatorDistalThicknessMap'],
    '0x0666': ['FD', '1', 'CompensatorBasePlaneOffset'],
    '0x0667': ['SQ', '1', 'CompensatorShapeFabricationCodeSequence'],
    '0x0668': ['SQ', '1', 'CompensatorShapeSequence'],
    '0x0669': ['FD', '1', 'RadiationBeamCompensatorMillingToolDiameter'],
    '0x066A': ['SQ', '1', 'BlockDefinitionSequence'],
    '0x066B': ['OF', '1', 'BlockEdgeData'],
    '0x066C': ['CS', '1', 'BlockOrientation'],
    '0x066D': ['FD', '1', 'RadiationBeamBlockThickness'],
    '0x066E': ['FD', '1', 'RadiationBeamBlockSlabThickness'],
    '0x066F': ['SQ', '1', 'BlockEdgeDataSequence'],
    '0x0670': ['US', '1', 'NumberOfRTAccessoryHolders'],
    '0x0671': ['SQ', '1', 'GeneralAccessoryDefinitionSequence'],
    '0x0672': ['US', '1', 'NumberOfGeneralAccessories'],
    '0x0673': ['SQ', '1', 'BolusDefinitionSequence'],
    '0x0674': ['US', '1', 'NumberOfBoluses'],
    '0x0675': ['UI', '1', 'EquipmentFrameOfReferenceUID'],
    '0x0676': ['ST', '1', 'EquipmentFrameOfReferenceDescription'],
    '0x0677': ['SQ', '1', 'EquipmentReferencePointCoordinatesSequence'],
    '0x0678': ['SQ', '1', 'EquipmentReferencePointCodeSequence'],
    '0x0679': ['FD', '1', 'RTBeamLimitingDeviceAngle'],
    '0x067A': ['FD', '1', 'SourceRollAngle'],
    '0x067B': ['SQ', '1', 'RadiationGenerationModeSequence'],
    '0x067C': ['SH', '1', 'RadiationGenerationModeLabel'],
    '0x067D': ['ST', '1', 'RadiationGenerationModeDescription'],
    '0x067E': ['SQ', '1', 'RadiationGenerationModeMachineCodeSequence'],
    '0x067F': ['SQ', '1', 'RadiationTypeCodeSequence'],
    '0x0680': ['DS', '1', 'NominalEnergy'],
    '0x0681': ['DS', '1', 'MinimumNominalEnergy'],
    '0x0682': ['DS', '1', 'MaximumNominalEnergy'],
    '0x0683': ['SQ', '1', 'RadiationFluenceModifierCodeSequence'],
    '0x0684': ['SQ', '1', 'EnergyUnitCodeSequence'],
    '0x0685': ['US', '1', 'NumberOfRadiationGenerationModes'],
    '0x0686': ['SQ', '1', 'PatientSupportDevicesSequence'],
    '0x0687': ['US', '1', 'NumberOfPatientSupportDevices'],
    '0x0688': ['FD', '1', 'RTBeamModifierDefinitionDistance'],
    '0x0689': ['SQ', '1', 'BeamAreaLimitSequence'],
    '0x068A': ['SQ', '1', 'ReferencedRTPrescriptionSequence'],
    '0x0700': ['UI', '1', 'TreatmentSessionUID'],
    '0x0701': ['CS', '1', 'RTRadiationUsage'],
    '0x0702': ['SQ', '1', 'ReferencedRTRadiationSetSequence'],
    '0x0703': ['SQ', '1', 'ReferencedRTRadiationRecordSequence'],
    '0x0704': ['US', '1', 'RTRadiationSetDeliveryNumber'],
    '0x0705': ['US', '1', 'ClinicalFractionNumber'],
    '0x0706': ['CS', '1', 'RTTreatmentFractionCompletionStatus'],
    '0x0707': ['CS', '1', 'RTRadiationSetUsage'],
    '0x0708': ['CS', '1', 'TreatmentDeliveryContinuationFlag'],
    '0x0709': ['CS', '1', 'TreatmentRecordContentOrigin'],
    '0x0714': ['CS', '1', 'RTTreatmentTerminationStatus'],
    '0x0715': ['SQ', '1', 'RTTreatmentTerminationReasonCodeSequence'],
    '0x0716': ['SQ', '1', 'MachineSpecificTreatmentTerminationCodeSequence'],
    '0x0722': ['SQ', '1', 'RTRadiationSalvageRecordControlPointSequence'],
    '0x0723': ['CS', '1', 'StartingMetersetValueKnownFlag'],
    '0x0730': ['ST', '1', 'TreatmentTerminationDescription'],
    '0x0731': ['SQ', '1', 'TreatmentToleranceViolationSequence'],
    '0x0732': ['CS', '1', 'TreatmentToleranceViolationCategory'],
    '0x0733': ['SQ', '1', 'TreatmentToleranceViolationAttributeSequence'],
    '0x0734': ['ST', '1', 'TreatmentToleranceViolationDescription'],
    '0x0735': ['ST', '1', 'TreatmentToleranceViolationIdentification'],
    '0x0736': ['DT', '1', 'TreatmentToleranceViolationDateTime'],
    '0x073A': ['DT', '1', 'RecordedRTControlPointDateTime'],
    '0x073B': ['US', '1', 'ReferencedRadiationRTControlPointIndex'],
    '0x073E': ['SQ', '1', 'AlternateValueSequence'],
    '0x073F': ['SQ', '1', 'ConfirmationSequence'],
    '0x0740': ['SQ', '1', 'InterlockSequence'],
    '0x0741': ['DT', '1', 'InterlockDateTime'],
    '0x0742': ['ST', '1', 'InterlockDescription'],
    '0x0743': ['SQ', '1', 'InterlockOriginatingDeviceSequence'],
    '0x0744': ['SQ', '1', 'InterlockCodeSequence'],
    '0x0745': ['SQ', '1', 'InterlockResolutionCodeSequence'],
    '0x0746': ['SQ', '1', 'InterlockResolutionUserSequence'],
    '0x0760': ['DT', '1', 'OverrideDateTime'],
    '0x0761': ['SQ', '1', 'TreatmentToleranceViolationTypeCodeSequence'],
    '0x0762': ['SQ', '1', 'TreatmentToleranceViolationCauseCodeSequence'],
    '0x0772': ['SQ', '1', 'MeasuredMetersetToDoseMappingSequence'],
    '0x0773': ['US', '1', 'ReferencedExpectedInVivoMeasurementValueIndex'],
    '0x0774': ['SQ', '1', 'DoseMeasurementDeviceCodeSequence'],
    '0x0780': ['SQ', '1', 'AdditionalParameterRecordingInstanceSequence'],
    '0x0782': ['US', '1', ''],
    '0x0783': ['ST', '1', 'InterlockOriginDescription'],
    '0x0784': ['SQ', '1', 'RTPatientPositionScopeSequence'],
    '0x0785': ['UI', '1', 'ReferencedTreatmentPositionGroupUID'],
    '0x0786': ['US', '1', 'RadiationOrderIndex'],
    '0x0787': ['SQ', '1', 'OmittedRadiationSequence'],
    '0x0788': ['SQ', '1', 'ReasonForOmissionCodeSequence'],
    '0x0789': ['SQ', '1', 'RTDeliveryStartPatientPositionSequence'],
    '0x078A': ['SQ', '1', 'RTTreatmentPreparationPatientPositionSequence'],
    '0x078B': ['SQ', '1', 'ReferencedRTTreatmentPreparationSequence'],
    '0x078C': ['SQ', '1', 'ReferencedPatientSetupPhotoSequence'],
    '0x078D': ['SQ', '1', 'PatientTreatmentPreparationMethodCodeSequence'],
    '0x078E': ['LT', '1', 'PatientTreatmentPreparationProcedureParameterDescription'],
    '0x078F': ['SQ', '1', 'PatientTreatmentPreparationDeviceSequence'],
    '0x0790': ['SQ', '1', 'PatientTreatmentPreparationProcedureSequence'],
    '0x0791': ['SQ', '1', 'PatientTreatmentPreparationProcedureCodeSequence'],
    '0x0792': ['LT', '1', 'PatientTreatmentPreparationMethodDescription'],
    '0x0793': ['SQ', '1', 'PatientTreatmentPreparationProcedureParameterSequence'],
    '0x0794': ['LT', '1', 'PatientSetupPhotoDescription'],
    '0x0795': ['US', '1', 'PatientTreatmentPreparationProcedureIndex'],
    '0x0796': ['US', '1', 'ReferencedPatientSetupProcedureIndex'],
    '0x0797': ['SQ', '1', 'RTRadiationTaskSequence'],
    '0x0798': ['SQ', '1', 'RTPatientPositionDisplacementSequence'],
    '0x0799': ['SQ', '1', 'RTPatientPositionSequence'],
    '0x079A': ['LO', '1', 'DisplacementReferenceLabel'],
    '0x079B': ['FD', '16', 'DisplacementMatrix'],
    '0x079C': ['SQ', '1', 'PatientSupportDisplacementSequence'],
    '0x079D': ['SQ', '1', 'DisplacementReferenceLocationCodeSequence'],
    '0x079E': ['CS', '1', 'RTRadiationSetDeliveryUsage']
  },
  '0x300C': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0002': ['SQ', '1', 'ReferencedRTPlanSequence'],
    '0x0004': ['SQ', '1', 'ReferencedBeamSequence'],
    '0x0006': ['IS', '1', 'ReferencedBeamNumber'],
    '0x0007': ['IS', '1', 'ReferencedReferenceImageNumber'],
    '0x0008': ['DS', '1', 'StartCumulativeMetersetWeight'],
    '0x0009': ['DS', '1', 'EndCumulativeMetersetWeight'],
    '0x000A': ['SQ', '1', 'ReferencedBrachyApplicationSetupSequence'],
    '0x000C': ['IS', '1', 'ReferencedBrachyApplicationSetupNumber'],
    '0x000E': ['IS', '1', 'ReferencedSourceNumber'],
    '0x0020': ['SQ', '1', 'ReferencedFractionGroupSequence'],
    '0x0022': ['IS', '1', 'ReferencedFractionGroupNumber'],
    '0x0040': ['SQ', '1', 'ReferencedVerificationImageSequence'],
    '0x0042': ['SQ', '1', 'ReferencedReferenceImageSequence'],
    '0x0050': ['SQ', '1', 'ReferencedDoseReferenceSequence'],
    '0x0051': ['IS', '1', 'ReferencedDoseReferenceNumber'],
    '0x0055': ['SQ', '1', 'BrachyReferencedDoseReferenceSequence'],
    '0x0060': ['SQ', '1', 'ReferencedStructureSetSequence'],
    '0x006A': ['IS', '1', 'ReferencedPatientSetupNumber'],
    '0x0080': ['SQ', '1', 'ReferencedDoseSequence'],
    '0x00A0': ['IS', '1', 'ReferencedToleranceTableNumber'],
    '0x00B0': ['SQ', '1', 'ReferencedBolusSequence'],
    '0x00C0': ['IS', '1', 'ReferencedWedgeNumber'],
    '0x00D0': ['IS', '1', 'ReferencedCompensatorNumber'],
    '0x00E0': ['IS', '1', 'ReferencedBlockNumber'],
    '0x00F0': ['IS', '1', 'ReferencedControlPointIndex'],
    '0x00F2': ['SQ', '1', 'ReferencedControlPointSequence'],
    '0x00F4': ['IS', '1', 'ReferencedStartControlPointIndex'],
    '0x00F6': ['IS', '1', 'ReferencedStopControlPointIndex'],
    '0x0100': ['IS', '1', 'ReferencedRangeShifterNumber'],
    '0x0102': ['IS', '1', 'ReferencedLateralSpreadingDeviceNumber'],
    '0x0104': ['IS', '1', 'ReferencedRangeModulatorNumber'],
    '0x0111': ['SQ', '1', 'OmittedBeamTaskSequence'],
    '0x0112': ['CS', '1', 'ReasonForOmission'],
    '0x0113': ['LO', '1', 'ReasonForOmissionDescription'],
    '0x0114': ['SQ', '1', 'PrescriptionOverviewSequence'],
    '0x0115': ['FL', '1', 'TotalPrescriptionDose'],
    '0x0116': ['SQ', '1', 'PlanOverviewSequence'],
    '0x0117': ['US', '1', 'PlanOverviewIndex'],
    '0x0118': ['US', '1', 'ReferencedPlanOverviewIndex'],
    '0x0119': ['US', '1', 'NumberOfFractionsIncluded'],
    '0x0120': ['SQ', '1', 'DoseCalibrationConditionsSequence'],
    '0x0121': ['FD', '1', 'AbsorbedDoseToMetersetRatio'],
    '0x0122': ['FD', '2', 'DelineatedRadiationFieldSize'],
    '0x0123': ['CS', '1', 'DoseCalibrationConditionsVerifiedFlag'],
    '0x0124': ['FD', '1', 'CalibrationReferencePointDepth'],
    '0x0125': ['SQ', '1', 'GatingBeamHoldTransitionSequence'],
    '0x0126': ['CS', '1', 'BeamHoldTransition'],
    '0x0127': ['DT', '1', 'BeamHoldTransitionDateTime'],
    '0x0128': ['SQ', '1', 'BeamHoldOriginatingDeviceSequence']
  },
  '0x300E': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0002': ['CS', '1', 'ApprovalStatus'],
    '0x0004': ['DA', '1', 'ReviewDate'],
    '0x0005': ['TM', '1', 'ReviewTime'],
    '0x0008': ['PN', '1', 'ReviewerName']
  },
  '0x3010': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0001': ['SQ', '1', 'RadiobiologicalDoseEffectSequence'],
    '0x0002': ['CS', '1', 'RadiobiologicalDoseEffectFlag'],
    '0x0003': ['SQ', '1', 'EffectiveDoseCalculationMethodCategoryCodeSequence'],
    '0x0004': ['SQ', '1', 'EffectiveDoseCalculationMethodCodeSequence'],
    '0x0005': ['LO', '1', 'EffectiveDoseCalculationMethodDescription'],
    '0x0006': ['UI', '1', 'ConceptualVolumeUID'],
    '0x0007': ['SQ', '1', 'OriginatingSOPInstanceReferenceSequence'],
    '0x0008': ['SQ', '1', 'ConceptualVolumeConstituentSequence'],
    '0x0009': ['SQ', '1', 'EquivalentConceptualVolumeInstanceReferenceSequence'],
    '0x000A': ['SQ', '1', 'EquivalentConceptualVolumesSequence'],
    '0x000B': ['UI', '1', 'ReferencedConceptualVolumeUID'],
    '0x000C': ['UT', '1', 'ConceptualVolumeCombinationExpression'],
    '0x000D': ['US', '1', 'ConceptualVolumeConstituentIndex'],
    '0x000E': ['CS', '1', 'ConceptualVolumeCombinationFlag'],
    '0x000F': ['ST', '1', 'ConceptualVolumeCombinationDescription'],
    '0x0010': ['CS', '1', 'ConceptualVolumeSegmentationDefinedFlag'],
    '0x0011': ['SQ', '1', 'ConceptualVolumeSegmentationReferenceSequence'],
    '0x0012': ['SQ', '1', 'ConceptualVolumeConstituentSegmentationReferenceSequence'],
    '0x0013': ['UI', '1', 'ConstituentConceptualVolumeUID'],
    '0x0014': ['SQ', '1', 'DerivationConceptualVolumeSequence'],
    '0x0015': ['UI', '1', 'SourceConceptualVolumeUID'],
    '0x0016': ['SQ', '1', 'ConceptualVolumeDerivationAlgorithmSequence'],
    '0x0017': ['ST', '1', 'ConceptualVolumeDescription'],
    '0x0018': ['SQ', '1', 'SourceConceptualVolumeSequence'],
    '0x0019': ['SQ', '1', 'AuthorIdentificationSequence'],
    '0x001A': ['LO', '1', 'ManufacturerModelVersion'],
    '0x001B': ['UC', '1', 'DeviceAlternateIdentifier'],
    '0x001C': ['CS', '1', 'DeviceAlternateIdentifierType'],
    '0x001D': ['LT', '1', 'DeviceAlternateIdentifierFormat'],
    '0x001E': ['LO', '1', 'SegmentationCreationTemplateLabel'],
    '0x001F': ['UI', '1', 'SegmentationTemplateUID'],
    '0x0020': ['US', '1', 'ReferencedSegmentReferenceIndex'],
    '0x0021': ['SQ', '1', 'SegmentReferenceSequence'],
    '0x0022': ['US', '1', 'SegmentReferenceIndex'],
    '0x0023': ['SQ', '1', 'DirectSegmentReferenceSequence'],
    '0x0024': ['SQ', '1', 'CombinationSegmentReferenceSequence'],
    '0x0025': ['SQ', '1', 'ConceptualVolumeSequence'],
    '0x0026': ['SQ', '1', 'SegmentedRTAccessoryDeviceSequence'],
    '0x0027': ['SQ', '1', 'SegmentCharacteristicsSequence'],
    '0x0028': ['SQ', '1', 'RelatedSegmentCharacteristicsSequence'],
    '0x0029': ['US', '1', 'SegmentCharacteristicsPrecedence'],
    '0x002A': ['SQ', '1', 'RTSegmentAnnotationSequence'],
    '0x002B': ['SQ', '1', 'SegmentAnnotationCategoryCodeSequence'],
    '0x002C': ['SQ', '1', 'SegmentAnnotationTypeCodeSequence'],
    '0x002D': ['LO', '1', 'DeviceLabel'],
    '0x002E': ['SQ', '1', 'DeviceTypeCodeSequence'],
    '0x002F': ['SQ', '1', 'SegmentAnnotationTypeModifierCodeSequence'],
    '0x0030': ['SQ', '1', 'PatientEquipmentRelationshipCodeSequence'],
    '0x0031': ['UI', '1', 'ReferencedFiducialsUID'],
    '0x0032': ['SQ', '1', 'PatientTreatmentOrientationSequence'],
    '0x0033': ['SH', '1', 'UserContentLabel'],
    '0x0034': ['LO', '1', 'UserContentLongLabel'],
    '0x0035': ['SH', '1', 'EntityLabel'],
    '0x0036': ['LO', '1', 'EntityName'],
    '0x0037': ['ST', '1', 'EntityDescription'],
    '0x0038': ['LO', '1', 'EntityLongLabel'],
    '0x0039': ['US', '1', 'DeviceIndex'],
    '0x003A': ['US', '1', 'RTTreatmentPhaseIndex'],
    '0x003B': ['UI', '1', 'RTTreatmentPhaseUID'],
    '0x003C': ['US', '1', 'RTPrescriptionIndex'],
    '0x003D': ['US', '1', 'RTSegmentAnnotationIndex'],
    '0x003E': ['US', '1', 'BasisRTTreatmentPhaseIndex'],
    '0x003F': ['US', '1', 'RelatedRTTreatmentPhaseIndex'],
    '0x0040': ['US', '1', 'ReferencedRTTreatmentPhaseIndex'],
    '0x0041': ['US', '1', 'ReferencedRTPrescriptionIndex'],
    '0x0042': ['US', '1', 'ReferencedParentRTPrescriptionIndex'],
    '0x0043': ['ST', '1', 'ManufacturerDeviceIdentifier'],
    '0x0044': ['SQ', '1', 'InstanceLevelReferencedPerformedProcedureStepSequence'],
    '0x0045': ['CS', '1', 'RTTreatmentPhaseIntentPresenceFlag'],
    '0x0046': ['CS', '1', 'RadiotherapyTreatmentType'],
    '0x0047': ['CS', '1-n', 'TeletherapyRadiationType'],
    '0x0048': ['CS', '1-n', 'BrachytherapySourceType'],
    '0x0049': ['SQ', '1', 'ReferencedRTTreatmentPhaseSequence'],
    '0x004A': ['SQ', '1', 'ReferencedDirectSegmentInstanceSequence'],
    '0x004B': ['SQ', '1', 'IntendedRTTreatmentPhaseSequence'],
    '0x004C': ['DA', '1', 'IntendedPhaseStartDate'],
    '0x004D': ['DA', '1', 'IntendedPhaseEndDate'],
    '0x004E': ['SQ', '1', 'RTTreatmentPhaseIntervalSequence'],
    '0x004F': ['CS', '1', 'TemporalRelationshipIntervalAnchor'],
    '0x0050': ['FD', '1', 'MinimumNumberOfIntervalDays'],
    '0x0051': ['FD', '1', 'MaximumNumberOfIntervalDays'],
    '0x0052': ['UI', '1-n', 'PertinentSOPClassesInStudy'],
    '0x0053': ['UI', '1-n', 'PertinentSOPClassesInSeries'],
    '0x0054': ['LO', '1', 'RTPrescriptionLabel'],
    '0x0055': ['SQ', '1', 'RTPhysicianIntentPredecessorSequence'],
    '0x0056': ['LO', '1', 'RTTreatmentApproachLabel'],
    '0x0057': ['SQ', '1', 'RTPhysicianIntentSequence'],
    '0x0058': ['US', '1', 'RTPhysicianIntentIndex'],
    '0x0059': ['CS', '1', 'RTTreatmentIntentType'],
    '0x005A': ['UT', '1', 'RTPhysicianIntentNarrative'],
    '0x005B': ['SQ', '1', 'RTProtocolCodeSequence'],
    '0x005C': ['ST', '1', 'ReasonForSuperseding'],
    '0x005D': ['SQ', '1', 'RTDiagnosisCodeSequence'],
    '0x005E': ['US', '1', 'ReferencedRTPhysicianIntentIndex'],
    '0x005F': ['SQ', '1', 'RTPhysicianIntentInputInstanceSequence'],
    '0x0060': ['SQ', '1', 'RTAnatomicPrescriptionSequence'],
    '0x0061': ['UT', '1', 'PriorTreatmentDoseDescription'],
    '0x0062': ['SQ', '1', 'PriorTreatmentReferenceSequence'],
    '0x0063': ['CS', '1', 'DosimetricObjectiveEvaluationScope'],
    '0x0064': ['SQ', '1', 'TherapeuticRoleCategoryCodeSequence'],
    '0x0065': ['SQ', '1', 'TherapeuticRoleTypeCodeSequence'],
    '0x0066': ['US', '1', 'ConceptualVolumeOptimizationPrecedence'],
    '0x0067': ['SQ', '1', 'ConceptualVolumeCategoryCodeSequence'],
    '0x0068': ['CS', '1', 'ConceptualVolumeBlockingConstraint'],
    '0x0069': ['SQ', '1', 'ConceptualVolumeTypeCodeSequence'],
    '0x006A': ['SQ', '1', 'ConceptualVolumeTypeModifierCodeSequence'],
    '0x006B': ['SQ', '1', 'RTPrescriptionSequence'],
    '0x006C': ['SQ', '1', 'DosimetricObjectiveSequence'],
    '0x006D': ['SQ', '1', 'DosimetricObjectiveTypeCodeSequence'],
    '0x006E': ['UI', '1', 'DosimetricObjectiveUID'],
    '0x006F': ['UI', '1', 'ReferencedDosimetricObjectiveUID'],
    '0x0070': ['SQ', '1', 'DosimetricObjectiveParameterSequence'],
    '0x0071': ['SQ', '1', 'ReferencedDosimetricObjectivesSequence'],
    '0x0073': ['CS', '1', 'AbsoluteDosimetricObjectiveFlag'],
    '0x0074': ['FD', '1', 'DosimetricObjectiveWeight'],
    '0x0075': ['CS', '1', 'DosimetricObjectivePurpose'],
    '0x0076': ['SQ', '1', 'PlanningInputInformationSequence'],
    '0x0077': ['LO', '1', 'TreatmentSite'],
    '0x0078': ['SQ', '1', 'TreatmentSiteCodeSequence'],
    '0x0079': ['SQ', '1', 'FractionPatternSequence'],
    '0x007A': ['UT', '1', 'TreatmentTechniqueNotes'],
    '0x007B': ['UT', '1', 'PrescriptionNotes'],
    '0x007C': ['IS', '1', 'NumberOfIntervalFractions'],
    '0x007D': ['US', '1', 'NumberOfFractions'],
    '0x007E': ['US', '1', 'IntendedDeliveryDuration'],
    '0x007F': ['UT', '1', 'FractionationNotes'],
    '0x0080': ['SQ', '1', 'RTTreatmentTechniqueCodeSequence'],
    '0x0081': ['SQ', '1', 'PrescriptionNotesSequence'],
    '0x0082': ['SQ', '1', 'FractionBasedRelationshipSequence'],
    '0x0083': ['CS', '1', 'FractionBasedRelationshipIntervalAnchor'],
    '0x0084': ['FD', '1', 'MinimumHoursBetweenFractions'],
    '0x0085': ['TM', '1-n', 'IntendedFractionStartTime'],
    '0x0086': ['LT', '1', 'IntendedStartDayOfWeek'],
    '0x0087': ['SQ', '1', 'WeekdayFractionPatternSequence'],
    '0x0088': ['SQ', '1', 'DeliveryTimeStructureCodeSequence'],
    '0x0089': ['SQ', '1', 'TreatmentSiteModifierCodeSequence'],
    '0x0090': ['CS', '1', 'RoboticBaseLocationIndicator'],
    '0x0091': ['SQ', '1', 'RoboticPathNodeSetCodeSequence'],
    '0x0092': ['UL', '1', 'RoboticNodeIdentifier'],
    '0x0093': ['FD', '3', 'RTTreatmentSourceCoordinates'],
    '0x0094': ['FD', '1', 'RadiationSourceCoordinateSystemYawAngle'],
    '0x0095': ['FD', '1', 'RadiationSourceCoordinateSystemRollAngle'],
    '0x0096': ['FD', '1', 'RadiationSourceCoordinateSystemPitchAngle'],
    '0x0097': ['SQ', '1', 'RoboticPathControlPointSequence'],
    '0x0098': ['SQ', '1', 'TomotherapeuticControlPointSequence'],
    '0x0099': ['FD', '1-n', 'TomotherapeuticLeafOpenDurations'],
    '0x009A': ['FD', '1-n', 'TomotherapeuticLeafInitialClosedDurations']
  },
  '0x4000': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0010': ['LT', '1', 'Arbitrary'],
    '0x4000': ['LT', '1', 'TextComments']
  },
  '0x4008': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0040': ['SH', '1', 'ResultsID'],
    '0x0042': ['LO', '1', 'ResultsIDIssuer'],
    '0x0050': ['SQ', '1', 'ReferencedInterpretationSequence'],
    '0x00FF': ['CS', '1', 'ReportProductionStatusTrial'],
    '0x0100': ['DA', '1', 'InterpretationRecordedDate'],
    '0x0101': ['TM', '1', 'InterpretationRecordedTime'],
    '0x0102': ['PN', '1', 'InterpretationRecorder'],
    '0x0103': ['LO', '1', 'ReferenceToRecordedSound'],
    '0x0108': ['DA', '1', 'InterpretationTranscriptionDate'],
    '0x0109': ['TM', '1', 'InterpretationTranscriptionTime'],
    '0x010A': ['PN', '1', 'InterpretationTranscriber'],
    '0x010B': ['ST', '1', 'InterpretationText'],
    '0x010C': ['PN', '1', 'InterpretationAuthor'],
    '0x0111': ['SQ', '1', 'InterpretationApproverSequence'],
    '0x0112': ['DA', '1', 'InterpretationApprovalDate'],
    '0x0113': ['TM', '1', 'InterpretationApprovalTime'],
    '0x0114': ['PN', '1', 'PhysicianApprovingInterpretation'],
    '0x0115': ['LT', '1', 'InterpretationDiagnosisDescription'],
    '0x0117': ['SQ', '1', 'InterpretationDiagnosisCodeSequence'],
    '0x0118': ['SQ', '1', 'ResultsDistributionListSequence'],
    '0x0119': ['PN', '1', 'DistributionName'],
    '0x011A': ['LO', '1', 'DistributionAddress'],
    '0x0200': ['SH', '1', 'InterpretationID'],
    '0x0202': ['LO', '1', 'InterpretationIDIssuer'],
    '0x0210': ['CS', '1', 'InterpretationTypeID'],
    '0x0212': ['CS', '1', 'InterpretationStatusID'],
    '0x0300': ['ST', '1', 'Impressions'],
    '0x4000': ['ST', '1', 'ResultsComments']
  },
  '0x4010': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0001': ['CS', '1', 'LowEnergyDetectors'],
    '0x0002': ['CS', '1', 'HighEnergyDetectors'],
    '0x0004': ['SQ', '1', 'DetectorGeometrySequence'],
    '0x1001': ['SQ', '1', 'ThreatROIVoxelSequence'],
    '0x1004': ['FL', '3', 'ThreatROIBase'],
    '0x1005': ['FL', '3', 'ThreatROIExtents'],
    '0x1006': ['OB', '1', 'ThreatROIBitmap'],
    '0x1007': ['SH', '1', 'RouteSegmentID'],
    '0x1008': ['CS', '1', 'GantryType'],
    '0x1009': ['CS', '1', 'OOIOwnerType'],
    '0x100A': ['SQ', '1', 'RouteSegmentSequence'],
    '0x1010': ['US', '1', 'PotentialThreatObjectID'],
    '0x1011': ['SQ', '1', 'ThreatSequence'],
    '0x1012': ['CS', '1', 'ThreatCategory'],
    '0x1013': ['LT', '1', 'ThreatCategoryDescription'],
    '0x1014': ['CS', '1', 'ATDAbilityAssessment'],
    '0x1015': ['CS', '1', 'ATDAssessmentFlag'],
    '0x1016': ['FL', '1', 'ATDAssessmentProbability'],
    '0x1017': ['FL', '1', 'Mass'],
    '0x1018': ['FL', '1', 'Density'],
    '0x1019': ['FL', '1', 'ZEffective'],
    '0x101A': ['SH', '1', 'BoardingPassID'],
    '0x101B': ['FL', '3', 'CenterOfMass'],
    '0x101C': ['FL', '3', 'CenterOfPTO'],
    '0x101D': ['FL', '6-n', 'BoundingPolygon'],
    '0x101E': ['SH', '1', 'RouteSegmentStartLocationID'],
    '0x101F': ['SH', '1', 'RouteSegmentEndLocationID'],
    '0x1020': ['CS', '1', 'RouteSegmentLocationIDType'],
    '0x1021': ['CS', '1-n', 'AbortReason'],
    '0x1023': ['FL', '1', 'VolumeOfPTO'],
    '0x1024': ['CS', '1', 'AbortFlag'],
    '0x1025': ['DT', '1', 'RouteSegmentStartTime'],
    '0x1026': ['DT', '1', 'RouteSegmentEndTime'],
    '0x1027': ['CS', '1', 'TDRType'],
    '0x1028': ['CS', '1', 'InternationalRouteSegment'],
    '0x1029': ['LO', '1-n', 'ThreatDetectionAlgorithmAndVersion'],
    '0x102A': ['SH', '1', 'AssignedLocation'],
    '0x102B': ['DT', '1', 'AlarmDecisionTime'],
    '0x1031': ['CS', '1', 'AlarmDecision'],
    '0x1033': ['US', '1', 'NumberOfTotalObjects'],
    '0x1034': ['US', '1', 'NumberOfAlarmObjects'],
    '0x1037': ['SQ', '1', 'PTORepresentationSequence'],
    '0x1038': ['SQ', '1', 'ATDAssessmentSequence'],
    '0x1039': ['CS', '1', 'TIPType'],
    '0x103A': ['CS', '1', 'DICOSVersion'],
    '0x1041': ['DT', '1', 'OOIOwnerCreationTime'],
    '0x1042': ['CS', '1', 'OOIType'],
    '0x1043': ['FL', '3', 'OOISize'],
    '0x1044': ['CS', '1', 'AcquisitionStatus'],
    '0x1045': ['SQ', '1', 'BasisMaterialsCodeSequence'],
    '0x1046': ['CS', '1', 'PhantomType'],
    '0x1047': ['SQ', '1', 'OOIOwnerSequence'],
    '0x1048': ['CS', '1', 'ScanType'],
    '0x1051': ['LO', '1', 'ItineraryID'],
    '0x1052': ['SH', '1', 'ItineraryIDType'],
    '0x1053': ['LO', '1', 'ItineraryIDAssigningAuthority'],
    '0x1054': ['SH', '1', 'RouteID'],
    '0x1055': ['SH', '1', 'RouteIDAssigningAuthority'],
    '0x1056': ['CS', '1', 'InboundArrivalType'],
    '0x1058': ['SH', '1', 'CarrierID'],
    '0x1059': ['CS', '1', 'CarrierIDAssigningAuthority'],
    '0x1060': ['FL', '3', 'SourceOrientation'],
    '0x1061': ['FL', '3', 'SourcePosition'],
    '0x1062': ['FL', '1', 'BeltHeight'],
    '0x1064': ['SQ', '1', 'AlgorithmRoutingCodeSequence'],
    '0x1067': ['CS', '1', 'TransportClassification'],
    '0x1068': ['LT', '1', 'OOITypeDescriptor'],
    '0x1069': ['FL', '1', 'TotalProcessingTime'],
    '0x106C': ['OB', '1', 'DetectorCalibrationData'],
    '0x106D': ['CS', '1', 'AdditionalScreeningPerformed'],
    '0x106E': ['CS', '1', 'AdditionalInspectionSelectionCriteria'],
    '0x106F': ['SQ', '1', 'AdditionalInspectionMethodSequence'],
    '0x1070': ['CS', '1', 'AITDeviceType'],
    '0x1071': ['SQ', '1', 'QRMeasurementsSequence'],
    '0x1072': ['SQ', '1', 'TargetMaterialSequence'],
    '0x1073': ['FD', '1', 'SNRThreshold'],
    '0x1075': ['DS', '1', 'ImageScaleRepresentation'],
    '0x1076': ['SQ', '1', 'ReferencedPTOSequence'],
    '0x1077': ['SQ', '1', 'ReferencedTDRInstanceSequence'],
    '0x1078': ['ST', '1', 'PTOLocationDescription'],
    '0x1079': ['SQ', '1', 'AnomalyLocatorIndicatorSequence'],
    '0x107A': ['FL', '3', 'AnomalyLocatorIndicator'],
    '0x107B': ['SQ', '1', 'PTORegionSequence'],
    '0x107C': ['CS', '1', 'InspectionSelectionCriteria'],
    '0x107D': ['SQ', '1', 'SecondaryInspectionMethodSequence'],
    '0x107E': ['DS', '6', 'PRCSToRCSOrientation']
  },
  '0x4FFE': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0001': ['SQ', '1', 'MACParametersSequence']
  },
  '0x5000': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0005': ['US', '1', 'CurveDimensions'],
    '0x0010': ['US', '1', 'NumberOfPoints'],
    '0x0020': ['CS', '1', 'TypeOfData'],
    '0x0022': ['LO', '1', 'CurveDescription'],
    '0x0030': ['SH', '1-n', 'AxisUnits'],
    '0x0040': ['SH', '1-n', 'AxisLabels'],
    '0x0103': ['US', '1', 'DataValueRepresentation'],
    '0x0104': ['US', '1-n', 'MinimumCoordinateValue'],
    '0x0105': ['US', '1-n', 'MaximumCoordinateValue'],
    '0x0106': ['SH', '1-n', 'CurveRange'],
    '0x0110': ['US', '1-n', 'CurveDataDescriptor'],
    '0x0112': ['US', '1-n', 'CoordinateStartValue'],
    '0x0114': ['US', '1-n', 'CoordinateStepValue'],
    '0x1001': ['CS', '1', 'CurveActivationLayer'],
    '0x2000': ['US', '1', 'AudioType'],
    '0x2002': ['US', '1', 'AudioSampleFormat'],
    '0x2004': ['US', '1', 'NumberOfChannels'],
    '0x2006': ['UL', '1', 'NumberOfSamples'],
    '0x2008': ['UL', '1', 'SampleRate'],
    '0x200A': ['UL', '1', 'TotalTime'],
    '0x200C': ['ox', '1', 'AudioSampleData'],
    '0x200E': ['LT', '1', 'AudioComments'],
    '0x2500': ['LO', '1', 'CurveLabel'],
    '0x2600': ['SQ', '1', 'CurveReferencedOverlaySequence'],
    '0x2610': ['US', '1', 'CurveReferencedOverlayGroup'],
    '0x3000': ['ox', '1', 'CurveData']
  },
  '0x5200': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x9229': ['SQ', '1', 'SharedFunctionalGroupsSequence'],
    '0x9230': ['SQ', '1', 'PerFrameFunctionalGroupsSequence']
  },
  '0x5400': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0100': ['SQ', '1', 'WaveformSequence'],
    '0x0110': ['ox', '1', 'ChannelMinimumValue'],
    '0x0112': ['ox', '1', 'ChannelMaximumValue'],
    '0x1004': ['US', '1', 'WaveformBitsAllocated'],
    '0x1006': ['CS', '1', 'WaveformSampleInterpretation'],
    '0x100A': ['ox', '1', 'WaveformPaddingValue'],
    '0x1010': ['ox', '1', 'WaveformData']
  },
  '0x5600': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0010': ['OF', '1', 'FirstOrderPhaseCorrectionAngle'],
    '0x0020': ['OF', '1', 'SpectroscopyData']
  },
  '0x6000': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0010': ['US', '1', 'OverlayRows'],
    '0x0011': ['US', '1', 'OverlayColumns'],
    '0x0012': ['US', '1', 'OverlayPlanes'],
    '0x0015': ['IS', '1', 'NumberOfFramesInOverlay'],
    '0x0022': ['LO', '1', 'OverlayDescription'],
    '0x0040': ['CS', '1', 'OverlayType'],
    '0x0045': ['LO', '1', 'OverlaySubtype'],
    '0x0050': ['SS', '2', 'OverlayOrigin'],
    '0x0051': ['US', '1', 'ImageFrameOrigin'],
    '0x0052': ['US', '1', 'OverlayPlaneOrigin'],
    '0x0060': ['CS', '1', 'OverlayCompressionCode'],
    '0x0061': ['SH', '1', 'OverlayCompressionOriginator'],
    '0x0062': ['SH', '1', 'OverlayCompressionLabel'],
    '0x0063': ['CS', '1', 'OverlayCompressionDescription'],
    '0x0066': ['AT', '1-n', 'OverlayCompressionStepPointers'],
    '0x0068': ['US', '1', 'OverlayRepeatInterval'],
    '0x0069': ['US', '1', 'OverlayBitsGrouped'],
    '0x0100': ['US', '1', 'OverlayBitsAllocated'],
    '0x0102': ['US', '1', 'OverlayBitPosition'],
    '0x0110': ['CS', '1', 'OverlayFormat'],
    '0x0200': ['US', '1', 'OverlayLocation'],
    '0x0800': ['CS', '1-n', 'OverlayCodeLabel'],
    '0x0802': ['US', '1', 'OverlayNumberOfTables'],
    '0x0803': ['AT', '1-n', 'OverlayCodeTableLocation'],
    '0x0804': ['US', '1', 'OverlayBitsForCodeWord'],
    '0x1001': ['CS', '1', 'OverlayActivationLayer'],
    '0x1100': ['US', '1', 'OverlayDescriptorGray'],
    '0x1101': ['US', '1', 'OverlayDescriptorRed'],
    '0x1102': ['US', '1', 'OverlayDescriptorGreen'],
    '0x1103': ['US', '1', 'OverlayDescriptorBlue'],
    '0x1200': ['US', '1-n', 'OverlaysGray'],
    '0x1201': ['US', '1-n', 'OverlaysRed'],
    '0x1202': ['US', '1-n', 'OverlaysGreen'],
    '0x1203': ['US', '1-n', 'OverlaysBlue'],
    '0x1301': ['IS', '1', 'ROIArea'],
    '0x1302': ['DS', '1', 'ROIMean'],
    '0x1303': ['DS', '1', 'ROIStandardDeviation'],
    '0x1500': ['LO', '1', 'OverlayLabel'],
    '0x3000': ['ox', '1', 'OverlayData'],
    '0x4000': ['LT', '1', 'OverlayComments']
  },
  '0x7F00': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0010': ['ox', '1', 'VariablePixelData'],
    '0x0011': ['US', '1', 'VariableNextDataGroup'],
    '0x0020': ['OW', '1', 'VariableCoefficientsSDVN'],
    '0x0030': ['OW', '1', 'VariableCoefficientsSDHN'],
    '0x0040': ['OW', '1', 'VariableCoefficientsSDDN']
  },
  '0x7FE0': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0x0001': ['OV', '1', 'ExtendedOffsetTable'],
    '0x0002': ['OV', '1', 'ExtendedOffsetTableLengths'],
    '0x0008': ['OF', '1', 'FloatPixelData'],
    '0x0009': ['OD', '1', 'DoubleFloatPixelData'],
    '0x0010': ['ox', '1', 'PixelData'],
    '0x0020': ['OW', '1', 'CoefficientsSDVN'],
    '0x0030': ['OW', '1', 'CoefficientsSDHN'],
    '0x0040': ['OW', '1', 'CoefficientsSDDN']
  },
  '0xFFFA': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0xFFFA': ['SQ', '1', 'DigitalSignaturesSequence']
  },
  '0xFFFC': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0xFFFC': ['OB', '1', 'DataSetTrailingPadding']
  },
  '0xFFFE': {
    '0x0000': ['UL', '1', 'GenericGroupLength'],
    '0xE000': ['NONE', '1', 'Item'],
    '0xE00D': ['NONE', '1', 'ItemDelimitationItem'],
    '0xE0DD': ['NONE', '1', 'SequenceDelimitationItem']
  }
}; // dwv.dicom.Dictionnary

// taken from gdcm-2.6.1\Source\DataDictionary\GroupName.dic
// -> removed duplicates (commented)
dwv.dicom.TagGroups = {
  x0000: 'Command',
  x0002: 'Meta Element',
  x0004: 'File Set',
  //'x0004': 'Directory',
  x0008: 'Identifying',
  x0009: 'SPI Identifying',
  x0010: 'Patient',
  x0012: 'Clinical Trial',
  x0018: 'Acquisition',
  x0019: 'SPI Acquisition',
  x0020: 'Image',
  x0021: 'SPI Image',
  x0022: 'Ophtalmology',
  x0028: 'Image Presentation',
  x0032: 'Study',
  x0038: 'Visit',
  x003A: 'Waveform',
  x0040: 'Procedure',
  //'x0040': ''Modality Worklist',
  x0042: 'Encapsulated Document',
  x0050: 'Device Informations',
  //'x0050': 'XRay Angio Device',
  x0054: 'Nuclear Medicine',
  x0060: 'Histogram',
  x0070: 'Presentation State',
  x0072: 'Hanging Protocol',
  x0088: 'Storage',
  //'x0088': 'Medicine',
  x0100: 'Authorization',
  x0400: 'Digital Signature',
  x1000: 'Code Table',
  x1010: 'Zonal Map',
  x2000: 'Film Session',
  x2010: 'Film Box',
  x2020: 'Image Box',
  x2030: 'Annotation',
  x2040: 'Overlay Box',
  x2050: 'Presentation LUT',
  x2100: 'Print Job',
  x2110: 'Printer',
  x2120: 'Queue',
  x2130: 'Print Content',
  x2200: 'Media Creation',
  x3002: 'RT Image',
  x3004: 'RT Dose',
  x3006: 'RT StructureSet',
  x3008: 'RT Treatment',
  x300A: 'RT Plan',
  x300C: 'RT Relationship',
  x300E: 'RT Approval',
  x4000: 'Text',
  x4008: 'Results',
  x4FFE: 'MAC Parameters',
  x5000: 'Curve',
  x5002: 'Curve',
  x5004: 'Curve',
  x5006: 'Curve',
  x5008: 'Curve',
  x500A: 'Curve',
  x500C: 'Curve',
  x500E: 'Curve',
  x5400: 'Waveform Data',
  x6000: 'Overlays',
  x6002: 'Overlays',
  x6004: 'Overlays',
  x6008: 'Overlays',
  x600A: 'Overlays',
  x600C: 'Overlays',
  x600E: 'Overlays',
  xFFFC: 'Generic',
  x7FE0: 'Pixel Data',
  xFFFF: 'Unknown'
};

// Value Representation (VR) with 32bit Value Length (VL)
// Added locally used 'ox'
// see http://dicom.nema.org/medical/dicom/2022a/output/chtml/part05/chapter_7.html#table_7.1-1
dwv.dicom.vr32bitVL = [
  'OB', 'OD', 'OF', 'OL', 'OV', 'OW', 'SQ', 'SV', 'UC', 'UN', 'UR', 'UT', 'UV', 'ox'
];

// String VR with extended or replaced default character repertoire defined in
// Specific Character Set (0008,0005)
// see https://dicom.nema.org/medical/dicom/2022a/output/chtml/part05/chapter_6.html#sect_6.1.2.2
dwv.dicom.charSetString = [
  'SH', 'LO', 'UC', 'ST', 'LT', 'UT', 'PN'
];

// VR types
// see https://dicom.nema.org/medical/dicom/2022a/output/chtml/part05/sect_6.2.html#table_6.2-1
dwv.dicom.vrTypes = {
  AE: 'string',
  AS: 'string',
  AT: undefined,
  CS: 'string',
  DA: 'string',
  DS: 'string',
  DT: 'string',
  FL: 'Float32',
  FD: 'Float64',
  IS: 'string',
  LO: 'string',
  LT: 'string',
  OB: 'Uint8',
  OD: 'Uint64',
  OF: 'Uint32',
  OL: 'Uint32',
  OV: 'Uint64',
  OW: 'Uint16',
  PN: 'string',
  SH: 'string',
  SL: 'Int32',
  SQ: undefined,
  SS: 'Int16',
  ST: 'string',
  SV: 'Int64',
  TM: 'string',
  UC: 'string',
  UI: 'string',
  UL: 'Uint32',
  UN: 'Uint8',
  UR: 'string',
  US: 'Uint16',
  UT: 'string',
  UV: 'Uint64'
};

// namespaces
var dwv = dwv || {};
/** @namespace */
dwv.gui = dwv.gui || {};

/**
 * The Konva namespace.
 *
 * @external Konva
 * @see https://konvajs.org/
 */
var Konva = Konva || {};

/**
 * Draw layer.
 *
 * @param {HTMLElement} containerDiv The layer div, its id will be used
 *   as this layer id.
 * @class
 */
dwv.gui.DrawLayer = function (containerDiv) {

  // specific css class name
  containerDiv.className += ' drawLayer';

  // closure to self
  var self = this;

  // konva stage
  var konvaStage = null;

  /**
   * The layer base size as {x,y}.
   *
   * @private
   * @type {object}
   */
  var baseSize;

  /**
   * The layer base spacing as {x,y}.
   *
   * @private
   * @type {object}
   */
  var baseSpacing;

  /**
   * The layer fit scale.
   *
   * @private
   * @type {object}
   */
  var fitScale = {x: 1, y: 1};

  /**
   * The base layer offset.
   *
   * @private
   * @type {object}
   */
  var baseOffset = {x: 0, y: 0};

  /**
   * The view offset.
   *
   * @private
   * @type {object}
   */
  var viewOffset = {x: 0, y: 0};

  /**
   * The zoom offset.
   *
   * @private
   * @type {object}
   */
  var zoomOffset = {x: 0, y: 0};

  /**
   * The flip offset.
   *
   * @private
   * @type {object}
   */
  var flipOffset = {x: 0, y: 0};

  /**
   * The draw controller.
   *
   * @private
   * @type {object}
   */
  var drawController = null;

  /**
   * The plane helper.
   *
   * @private
   * @type {object}
   */
  var planeHelper;

  /**
   * The associated data index.
   *
   * @private
   * @type {number}
   */
  var dataIndex = null;

  /**
   * Get the associated data index.
   *
   * @returns {number} The index.
   */
  this.getDataIndex = function () {
    return dataIndex;
  };

  /**
   * Listener handler.
   *
   * @type {object}
   * @private
   */
  var listenerHandler = new dwv.utils.ListenerHandler();

  /**
   * Get the Konva stage.
   *
   * @returns {object} The stage.
   */
  this.getKonvaStage = function () {
    return konvaStage;
  };

  /**
   * Get the Konva layer.
   *
   * @returns {object} The layer.
   */
  this.getKonvaLayer = function () {
    // there should only be one layer
    return konvaStage.getLayers()[0];
  };

  /**
   * Get the draw controller.
   *
   * @returns {object} The controller.
   */
  this.getDrawController = function () {
    return drawController;
  };

  /**
   * Set the plane helper.
   *
   * @param {object} helper The helper.
   */
  this.setPlaneHelper = function (helper) {
    planeHelper = helper;
  };

  // common layer methods [start] ---------------

  /**
   * Get the id of the layer.
   *
   * @returns {string} The string id.
   */
  this.getId = function () {
    return containerDiv.id;
  };

  /**
   * Get the layer base size (without scale).
   *
   * @returns {object} The size as {x,y}.
   */
  this.getBaseSize = function () {
    return baseSize;
  };

  /**
   * Get the layer opacity.
   *
   * @returns {number} The opacity ([0:1] range).
   */
  this.getOpacity = function () {
    return konvaStage.opacity();
  };

  /**
   * Set the layer opacity.
   *
   * @param {number} alpha The opacity ([0:1] range).
   */
  this.setOpacity = function (alpha) {
    konvaStage.opacity(Math.min(Math.max(alpha, 0), 1));
  };

  /**
   * Add a flip offset along the layer X axis.
   */
  this.addFlipOffsetX = function () {
    // flip scale is handled by layer group
    // flip offset
    var scale = konvaStage.scale();
    var size = konvaStage.size();
    flipOffset.x += size.width / scale.x;
    // apply
    var offset = konvaStage.offset();
    offset.x += flipOffset.x;
    konvaStage.offset(offset);
  };

  /**
   * Add a flip offset along the layer Y axis.
   */
  this.addFlipOffsetY = function () {
    // flip scale is handled by layer group
    // flip offset
    var scale = konvaStage.scale();
    var size = konvaStage.size();
    flipOffset.y += size.height / scale.y;
    // apply
    var offset = konvaStage.offset();
    offset.y += flipOffset.y;
    konvaStage.offset(offset);
  };

  /**
   * Set the layer scale.
   *
   * @param {object} newScale The scale as {x,y}.
   * @param {dwv.math.Point3D} center The scale center.
   */
  this.setScale = function (newScale, center) {
    var orientedNewScale = planeHelper.getTargetOrientedPositiveXYZ(newScale);
    var finalNewScale = {
      x: fitScale.x * orientedNewScale.x,
      y: fitScale.y * orientedNewScale.y
    };

    var offset = konvaStage.offset();

    if (Math.abs(newScale.x) === 1 &&
      Math.abs(newScale.y) === 1 &&
      Math.abs(newScale.z) === 1) {
      // reset zoom offset for scale=1
      var resetOffset = {
        x: offset.x - zoomOffset.x,
        y: offset.y - zoomOffset.y
      };
      // store new offset
      zoomOffset = {x: 0, y: 0};
      konvaStage.offset(resetOffset);
    } else {
      if (typeof center !== 'undefined') {
        var worldCenter = planeHelper.getPlaneOffsetFromOffset3D({
          x: center.getX(),
          y: center.getY(),
          z: center.getZ()
        });
        // center was obtained with viewLayer.displayToMainPlanePos
        // compensated for baseOffset
        // TODO: justify...
        worldCenter = {
          x: worldCenter.x + baseOffset.x,
          y: worldCenter.y + baseOffset.y
        };

        var newOffset = dwv.gui.getScaledOffset(
          offset, konvaStage.scale(), finalNewScale, worldCenter);

        var newZoomOffset = {
          x: zoomOffset.x + newOffset.x - offset.x,
          y: zoomOffset.y + newOffset.y - offset.y
        };
        // store new offset
        zoomOffset = newZoomOffset;
        konvaStage.offset(newOffset);
      }
    }

    konvaStage.scale(finalNewScale);
    // update labels
    updateLabelScale(finalNewScale);
  };

  /**
   * Set the layer offset.
   *
   * @param {object} newOffset The offset as {x,y}.
   */
  this.setOffset = function (newOffset) {
    var planeNewOffset = planeHelper.getPlaneOffsetFromOffset3D(newOffset);
    konvaStage.offset({
      x: planeNewOffset.x +
        viewOffset.x + baseOffset.x + zoomOffset.x + flipOffset.x,
      y: planeNewOffset.y +
        viewOffset.y + baseOffset.y + zoomOffset.y + flipOffset.y
    });
  };

  /**
   * Set the base layer offset. Updates the layer offset.
   *
   * @param {dwv.math.Vector3D} scrollOffset The scroll offset vector.
   * @param {dwv.math.Vector3D} planeOffset The plane offset vector.
   * @returns {boolean} True if the offset was updated.
   */
  this.setBaseOffset = function (scrollOffset, planeOffset) {
    var scrollIndex = planeHelper.getNativeScrollIndex();
    var newOffset = planeHelper.getPlaneOffsetFromOffset3D({
      x: scrollIndex === 0 ? scrollOffset.getX() : planeOffset.getX(),
      y: scrollIndex === 1 ? scrollOffset.getY() : planeOffset.getY(),
      z: scrollIndex === 2 ? scrollOffset.getZ() : planeOffset.getZ(),
    });
    var needsUpdate = baseOffset.x !== newOffset.x ||
      baseOffset.y !== newOffset.y;
    // reset offset if needed
    if (needsUpdate) {
      var offset = konvaStage.offset();
      konvaStage.offset({
        x: offset.x - baseOffset.x + newOffset.x,
        y: offset.y - baseOffset.y + newOffset.y
      });
      baseOffset = newOffset;
    }
    return needsUpdate;
  };

  /**
   * Display the layer.
   *
   * @param {boolean} flag Whether to display the layer or not.
   */
  this.display = function (flag) {
    containerDiv.style.display = flag ? '' : 'none';
  };

  /**
   * Check if the layer is visible.
   *
   * @returns {boolean} True if the layer is visible.
   */
  this.isVisible = function () {
    return containerDiv.style.display === '';
  };

  /**
   * Draw the content (imageData) of the layer.
   * The imageData variable needs to be set
   */
  this.draw = function () {
    konvaStage.draw();
  };

  /**
   * Initialise the layer: set the canvas and context
   *
   * @param {object} size The image size as {x,y}.
   * @param {object} spacing The image spacing as {x,y}.
   * @param {number} index The associated data index.
   */
  this.initialise = function (size, spacing, index) {
    // set locals
    baseSize = size;
    baseSpacing = spacing;
    dataIndex = index;

    // create stage
    konvaStage = new Konva.Stage({
      container: containerDiv,
      width: baseSize.x,
      height: baseSize.y,
      listening: false
    });
    // reset style
    // (avoids a not needed vertical scrollbar)
    konvaStage.getContent().setAttribute('style', '');

    // create layer
    var konvaLayer = new Konva.Layer({
      listening: false,
      visible: true
    });
    konvaStage.add(konvaLayer);

    // create draw controller
    drawController = new dwv.ctrl.DrawController(konvaLayer);
  };

  /**
   * Fit the layer to its parent container.
   *
   * @param {number} fitScale1D The 1D fit scale.
   * @param {object} fitSize The fit size as {x,y}.
   * @param {object} fitOffset The fit offset as {x,y}.
   */
  this.fitToContainer = function (fitScale1D, fitSize, fitOffset) {
    // update konva
    konvaStage.setWidth(fitSize.x);
    konvaStage.setHeight(fitSize.y);

    // previous scale without fit
    var previousScale = {
      x: konvaStage.scale().x / fitScale.x,
      y: konvaStage.scale().y / fitScale.y
    };
    // update fit scale
    fitScale = {
      x: fitScale1D * baseSpacing.x,
      y: fitScale1D * baseSpacing.y
    };
    // update scale
    konvaStage.scale({
      x: previousScale.x * fitScale.x,
      y: previousScale.y * fitScale.y
    });

    // update offsets
    viewOffset = {
      x: fitOffset.x / fitScale.x,
      y: fitOffset.y / fitScale.y
    };
    konvaStage.offset({
      x: viewOffset.x + baseOffset.x + zoomOffset.x + flipOffset.x,
      y: viewOffset.y + baseOffset.y + zoomOffset.y + flipOffset.y
    });
  };

  /**
   * Check the visibility of a given group.
   *
   * @param {string} id The id of the group.
   * @returns {boolean} True if the group is visible.
   */
  this.isGroupVisible = function (id) {
    // get the group
    var group = drawController.getGroup(id);
    if (typeof group === 'undefined') {
      return false;
    }
    // get visibility
    return group.isVisible();
  };

  /**
   * Toggle the visibility of a given group.
   *
   * @param {string} id The id of the group.
   * @returns {boolean} False if the group cannot be found.
   */
  this.toogleGroupVisibility = function (id) {
    // get the group
    var group = drawController.getGroup(id);
    if (typeof group === 'undefined') {
      return false;
    }
    // toggle visible
    group.visible(!group.isVisible());

    // udpate
    this.draw();

    return true;
  };

  /**
   * Delete a Draw from the stage.
   *
   * @param {string} id The id of the group to delete.
   * @param {object} exeCallback The callback to call once the
   *  DeleteCommand has been executed.
   */
  this.deleteDraw = function (id, exeCallback) {
    drawController.deleteDraw(id, fireEvent, exeCallback);
  };

  /**
   * Delete all Draws from the stage.
   *
   * @param {object} exeCallback The callback to call once the
   *  DeleteCommand has been executed.
   */
  this.deleteDraws = function (exeCallback) {
    drawController.deleteDraws(fireEvent, exeCallback);
  };

  /**
   * Enable and listen to container interaction events.
   */
  this.bindInteraction = function () {
    konvaStage.listening(true);
    // allow pointer events
    containerDiv.style.pointerEvents = 'auto';
    // interaction events
    var names = dwv.gui.interactionEventNames;
    for (var i = 0; i < names.length; ++i) {
      containerDiv.addEventListener(names[i], fireEvent);
    }
  };

  /**
   * Disable and stop listening to container interaction events.
   */
  this.unbindInteraction = function () {
    konvaStage.listening(false);
    // disable pointer events
    containerDiv.style.pointerEvents = 'none';
    // interaction events
    var names = dwv.gui.interactionEventNames;
    for (var i = 0; i < names.length; ++i) {
      containerDiv.removeEventListener(names[i], fireEvent);
    }
  };

  /**
   * Set the current position.
   *
   * @param {dwv.math.Point} position The new position.
   * @param {dwv.math.Index} index The new index.
   * @returns {boolean} True if the position was updated.
   */
  this.setCurrentPosition = function (position, index) {
    this.getDrawController().activateDrawLayer(
      index, planeHelper.getScrollIndex());
    // TODO: add check
    return true;
  };

  /**
   * Add an event listener to this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type, will be called with the fired event.
   */
  this.addEventListener = function (type, callback) {
    listenerHandler.add(type, callback);
  };

  /**
   * Remove an event listener from this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type.
   */
  this.removeEventListener = function (type, callback) {
    listenerHandler.remove(type, callback);
  };

  /**
   * Fire an event: call all associated listeners with the input event object.
   *
   * @param {object} event The event to fire.
   * @private
   */
  function fireEvent(event) {
    event.srclayerid = self.getId();
    event.dataid = dataIndex;
    listenerHandler.fireEvent(event);
  }

  // common layer methods [end] ---------------

  /**
   * Update label scale: compensate for it so
   *   that label size stays visually the same.
   *
   * @param {object} scale The scale to compensate for as {x,y}.
   */
  function updateLabelScale(scale) {
    // same formula as in style::applyZoomScale:
    // compensate for scale and times 2 so that font 10 looks like a 10
    var ratioX = 2 / scale.x;
    var ratioY = 2 / scale.y;
    // compensate scale for labels
    var labels = konvaStage.find('Label');
    for (var i = 0; i < labels.length; ++i) {
      labels[i].scale({x: ratioX, y: ratioY});
    }
  }
}; // DrawLayer class

// namespaces
var dwv = dwv || {};
dwv.gui = dwv.gui || {};

/**
 * List of interaction event names.
 */
dwv.gui.interactionEventNames = [
  'mousedown',
  'mousemove',
  'mouseup',
  'mouseout',
  'wheel',
  'dblclick',
  'touchstart',
  'touchmove',
  'touchend'
];

/**
 * Get a HTML element associated to a container div.
 *
 * @param {number} containerDivId The id of the container div.
 * @param {string} name The name or id to find.
 * @returns {object} The found element or null.
 * @deprecated
 */
dwv.gui.getElement = function (containerDivId, name) {
  // get by class in the container div
  var parent = document.getElementById(containerDivId);
  if (!parent) {
    return null;
  }
  var elements = parent.getElementsByClassName(name);
  // getting the last element since some libraries (ie jquery-mobile) create
  // span in front of regular tags (such as select)...
  var element = elements[elements.length - 1];
  // if not found get by id with 'containerDivId-className'
  if (typeof element === 'undefined') {
    element = document.getElementById(containerDivId + '-' + name);
  }
  return element;
};

/**
 * Get a HTML element associated to a container div. Defaults to local one.
 *
 * @see dwv.gui.getElement
 * @deprecated
 */
dwv.getElement = dwv.gui.getElement;

/**
 * Prompt the user for some text. Uses window.prompt.
 *
 * @param {string} message The message in front of the input field.
 * @param {string} value The input default value.
 * @returns {string} The new value.
 */
dwv.gui.prompt = function (message, value) {
  return prompt(message, value);
};

/**
 * Prompt the user for some text. Defaults to local one.
 *
 * @see dwv.gui.prompt
 */
dwv.prompt = dwv.gui.prompt;

/**
 * Open a dialogue to edit roi data. Defaults to undefined.
 *
 * @param {object} data The roi data.
 * @param {Function} callback The callback to launch on dialogue exit.
 * @see dwv.tool.Draw
 */
dwv.openRoiDialog;

/**
 * Get the positions (without the parent offset) of a list of touch events.
 *
 * @param {Array} touches The list of touch events.
 * @returns {Array} The list of positions of the touch events.
 */
dwv.gui.getTouchesPositions = function (touches) {
  // get the touch offset from all its parents
  var offsetLeft = 0;
  var offsetTop = 0;
  if (touches.length !== 0 &&
    typeof touches[0].target !== 'undefined') {
    var offsetParent = touches[0].target.offsetParent;
    while (offsetParent) {
      if (!isNaN(offsetParent.offsetLeft)) {
        offsetLeft += offsetParent.offsetLeft;
      }
      if (!isNaN(offsetParent.offsetTop)) {
        offsetTop += offsetParent.offsetTop;
      }
      offsetParent = offsetParent.offsetParent;
    }
  } else {
    dwv.logger.debug('No touch target offset parent.');
  }
  // set its position
  var positions = [];
  for (var i = 0; i < touches.length; ++i) {
    positions.push({
      x: touches[i].pageX - offsetLeft,
      y: touches[i].pageY - offsetTop
    });
  }
  return positions;
};

/**
 * Get the offset of an input event.
 *
 * @param {object} event The event to get the offset from.
 * @returns {Array} The array of offsets.
 */
dwv.gui.getEventOffset = function (event) {
  var positions = [];
  if (typeof event.targetTouches !== 'undefined' &&
    event.targetTouches.length !== 0) {
    // see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/targetTouches
    positions = dwv.gui.getTouchesPositions(event.targetTouches);
  } else if (typeof event.changedTouches !== 'undefined' &&
    event.changedTouches.length !== 0) {
    // see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/changedTouches
    positions = dwv.gui.getTouchesPositions(event.changedTouches);
  } else {
    // offsetX/Y: the offset in the X coordinate of the mouse pointer
    // between that event and the padding edge of the target node
    // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/offsetX
    // https://caniuse.com/mdn-api_mouseevent_offsetx
    positions.push({
      x: event.offsetX,
      y: event.offsetY
    });
  }
  return positions;
};

/**
 * Test if a canvas with the input size can be created.
 *
 * @see https://github.com/ivmartel/dwv/issues/902
 * @see https://github.com/jhildenbiddle/canvas-size/blob/v1.2.4/src/canvas-test.js
 * @param {number} width The canvas width.
 * @param {number} height The canvas height.
 * @returns {boolean} True is the canvas can be created.
 */
dwv.gui.canCreateCanvas = function (width, height) {
  // test canvas with input size
  var testCvs = document.createElement('canvas');
  testCvs.width = width;
  testCvs.height = height;
  // crop canvas to speed up test
  var cropCvs = document.createElement('canvas');
  cropCvs.width = 1;
  cropCvs.height = 1;
  // contexts
  var testCtx = testCvs.getContext('2d');
  var cropCtx = cropCvs.getContext('2d');
  // set data
  if (testCtx) {
    testCtx.fillRect(width - 1, height - 1, 1, 1);
    // Render the test pixel in the bottom-right corner of the
    // test canvas in the top-left of the 1x1 crop canvas. This
    // dramatically reducing the time for getImageData to complete.
    cropCtx.drawImage(testCvs, width - 1, height - 1, 1, 1, 0, 0, 1, 1);
  }
  // Verify image data (alpha component, Pass = 255, Fail = 0)
  return cropCtx && cropCtx.getImageData(0, 0, 1, 1).data[3] !== 0;
};

// namespaces
var dwv = dwv || {};
dwv.gui = dwv.gui || {};

/**
 * Get the layer div id.
 *
 * @param {string} groupDivId The layer group div id.
 * @param {number} layerId The lyaer id.
 * @returns {string} A string id.
 */
dwv.gui.getLayerDivId = function (groupDivId, layerId) {
  return groupDivId + '-layer-' + layerId;
};

/**
 * Get the layer details from a div id.
 *
 * @param {string} idString The layer div id.
 * @returns {object} The layer details as {groupDivId, layerId}.
 */
dwv.gui.getLayerDetailsFromLayerDivId = function (idString) {
  var split = idString.split('-layer-');
  if (split.length !== 2) {
    dwv.logger.warn('Not the expected layer div id format...');
  }
  return {
    groupDivId: split[0],
    layerId: split[1]
  };
};

/**
 * Get the layer details from a mouse event.
 *
 * @param {object} event The event to get the layer div id from. Expecting
 * an event origininating from a canvas inside a layer HTML div
 * with the 'layer' class and id generated with `dwv.gui.getLayerDivId`.
 * @returns {object} The layer details as {groupDivId, layerId}.
 */
dwv.gui.getLayerDetailsFromEvent = function (event) {
  var res = null;
  // get the closest element from the event target and with the 'layer' class
  var layerDiv = event.target.closest('.layer');
  if (layerDiv && typeof layerDiv.id !== 'undefined') {
    res = dwv.gui.getLayerDetailsFromLayerDivId(layerDiv.id);
  }
  return res;
};

/**
 * Get the view orientation according to an image and target orientation.
 * The view orientation is used to go from target to image space.
 *
 * @param {dwv.math.Matrix33} imageOrientation The image geometry.
 * @param {dwv.math.Matrix33} targetOrientation The target orientation.
 * @returns {dwv.math.Matrix33} The view orientation.
 */
dwv.gui.getViewOrientation = function (imageOrientation, targetOrientation) {
  var viewOrientation = dwv.math.getIdentityMat33();
  if (typeof targetOrientation !== 'undefined') {
    // i: image, v: view, t: target, O: orientation, P: point
    // [Img] -- Oi --> [Real] <-- Ot -- [Target]
    // Pi = (Oi)-1 * Ot * Pt = Ov * Pt
    // -> Ov = (Oi)-1 * Ot
    // TODO: asOneAndZeros simplifies but not nice...
    viewOrientation =
      imageOrientation.asOneAndZeros().getInverse().multiply(targetOrientation);
  }
  // TODO: why abs???
  return viewOrientation.getAbs();
};

/**
 * Get the target orientation according to an image and view orientation.
 * The target orientation is used to go from target to real space.
 *
 * @param {dwv.math.Matrix33} imageOrientation The image geometry.
 * @param {dwv.math.Matrix33} viewOrientation The view orientation.
 * @returns {dwv.math.Matrix33} The target orientation.
 */
dwv.gui.getTargetOrientation = function (imageOrientation, viewOrientation) {
  // i: image, v: view, t: target, O: orientation, P: point
  // [Img] -- Oi --> [Real] <-- Ot -- [Target]
  // Pi = (Oi)-1 * Ot * Pt = Ov * Pt
  // -> Ot = Oi * Ov
  // note: asOneAndZeros as in dwv.gui.getViewOrientation...
  var targetOrientation =
    imageOrientation.asOneAndZeros().multiply(viewOrientation);

  // TODO: why abs???
  var simpleImageOrientation = imageOrientation.asOneAndZeros().getAbs();
  if (simpleImageOrientation.equals(dwv.math.getCoronalMat33().getAbs())) {
    targetOrientation = targetOrientation.getAbs();
  }

  return targetOrientation;
};

/**
 * Get a scaled offset to adapt to new scale and such as the input center
 * stays at the same position.
 *
 * @param {object} offset The previous offset as {x,y}.
 * @param {object} scale The previous scale as {x,y}.
 * @param {object} newScale The new scale as {x,y}.
 * @param {object} center The scale center as {x,y}.
 * @returns {object} The scaled offset as {x,y}.
 */
dwv.gui.getScaledOffset = function (offset, scale, newScale, center) {
  // worldPoint = indexPoint / scale + offset
  //=> indexPoint = (worldPoint - offset ) * scale

  // plane center should stay the same:
  // indexCenter / newScale + newOffset =
  //   indexCenter / oldScale + oldOffset
  //=> newOffset = indexCenter / oldScale + oldOffset -
  //     indexCenter / newScale
  //=> newOffset = worldCenter - indexCenter / newScale
  var indexCenter = {
    x: (center.x - offset.x) * scale.x,
    y: (center.y - offset.y) * scale.y
  };
  return {
    x: center.x - (indexCenter.x / newScale.x),
    y: center.y - (indexCenter.y / newScale.y)
  };
};

/**
 * Layer group.
 *
 * Display position: {x,y}
 * Plane position: Index (access: get(i))
 * (world) Position: Point3D (access: getX, getY, getZ)
 *
 * Display -> World:
 * planePos = viewLayer.displayToPlanePos(displayPos)
 * -> compensate for layer scale and offset
 * pos = viewController.getPositionFromPlanePoint(planePos)
 *
 * World -> display
 * planePos = viewController.getOffset3DFromPlaneOffset(pos)
 * no need yet for a planePos to displayPos...
 *
 * @param {object} containerDiv The associated HTML div.
 * @class
 */
dwv.gui.LayerGroup = function (containerDiv) {

  // closure to self
  var self = this;
  // list of layers
  var layers = [];

  /**
   * The layer scale as {x,y}.
   *
   * @private
   * @type {object}
   */
  var scale = {x: 1, y: 1, z: 1};

  /**
   * The base scale as {x,y}: all posterior scale will be on top of this one.
   *
   * @private
   * @type {object}
   */
  var baseScale = {x: 1, y: 1, z: 1};

  /**
   * The layer offset as {x,y}.
   *
   * @private
   * @type {object}
   */
  var offset = {x: 0, y: 0, z: 0};

  /**
   * Active view layer index.
   *
   * @private
   * @type {number}
   */
  var activeViewLayerIndex = null;

  /**
   * Active draw layer index.
   *
   * @private
   * @type {number}
   */
  var activeDrawLayerIndex = null;

  /**
   * Listener handler.
   *
   * @type {object}
   * @private
   */
  var listenerHandler = new dwv.utils.ListenerHandler();

  /**
   * The target orientation matrix.
   *
   * @type {object}
   * @private
   */
  var targetOrientation;

  /**
   * Flag to activate crosshair or not.
   *
   * @type {boolean}
   * @private
   */
  var showCrosshair = false;

  /**
   * The current position used for the crosshair.
   *
   * @type {dwv.math.Point}
   * @private
   */
  var currentPosition;

  /**
   * Get the target orientation.
   *
   * @returns {dwv.math.Matrix33} The orientation matrix.
   */
  this.getTargetOrientation = function () {
    return targetOrientation;
  };

  /**
   * Set the target orientation.
   *
   * @param {dwv.math.Matrix33} orientation The orientation matrix.
   */
  this.setTargetOrientation = function (orientation) {
    targetOrientation = orientation;
  };

  /**
   * Get the showCrosshair flag.
   *
   * @returns {boolean} True to display the crosshair.
   */
  this.getShowCrosshair = function () {
    return showCrosshair;
  };

  /**
   * Set the showCrosshair flag.
   *
   * @param {boolean} flag True to display the crosshair.
   */
  this.setShowCrosshair = function (flag) {
    showCrosshair = flag;
    if (flag) {
      // listen to offset and zoom change
      self.addEventListener('offsetchange', updateCrosshairOnChange);
      self.addEventListener('zoomchange', updateCrosshairOnChange);
      // show crosshair div
      showCrosshairDiv();
    } else {
      // listen to offset and zoom change
      self.removeEventListener('offsetchange', updateCrosshairOnChange);
      self.removeEventListener('zoomchange', updateCrosshairOnChange);
      // remove crosshair div
      removeCrosshairDiv();
    }
  };

  /**
   * Update crosshair on offset or zoom change.
   */
  function updateCrosshairOnChange() {
    showCrosshairDiv();
  }

  /**
   * Get the Id of the container div.
   *
   * @returns {string} The id of the div.
   */
  this.getDivId = function () {
    return containerDiv.id;
  };

  /**
   * Get the layer scale.
   *
   * @returns {object} The scale as {x,y,z}.
   */
  this.getScale = function () {
    return scale;
  };

  /**
   * Get the base scale.
   *
   * @returns {object} The scale as {x,y,z}.
   */
  this.getBaseScale = function () {
    return baseScale;
  };

  /**
   * Get the added scale: the scale added to the base scale
   *
   * @returns {object} The scale as {x,y,z}.
   */
  this.getAddedScale = function () {
    return {
      x: scale.x / baseScale.x,
      y: scale.y / baseScale.y,
      z: scale.z / baseScale.z
    };
  };

  /**
   * Get the layer offset.
   *
   * @returns {object} The offset as {x,y,z}.
   */
  this.getOffset = function () {
    return offset;
  };

  /**
   * Get the number of layers handled by this class.
   *
   * @returns {number} The number of layers.
   */
  this.getNumberOfLayers = function () {
    return layers.length;
  };

  /**
   * Get the active image layer.
   *
   * @returns {object} The layer.
   */
  this.getActiveViewLayer = function () {
    return layers[activeViewLayerIndex];
  };

  /**
   * Get the view layers associated to a data index.
   *
   * @param {number} index The data index.
   * @returns {Array} The layers.
   */
  this.getViewLayersByDataIndex = function (index) {
    var res = [];
    for (var i = 0; i < layers.length; ++i) {
      if (layers[i] instanceof dwv.gui.ViewLayer &&
        layers[i].getDataIndex() === index) {
        res.push(layers[i]);
      }
    }
    return res;
  };

  /**
   * Search view layers for equal imae meta data.
   *
   * @param {object} meta The meta data to find.
   * @returns {Array} The list of view layers that contain matched data.
   */
  this.searchViewLayers = function (meta) {
    var res = [];
    for (var i = 0; i < layers.length; ++i) {
      if (layers[i] instanceof dwv.gui.ViewLayer) {
        if (layers[i].getViewController().equalImageMeta(meta)) {
          res.push(layers[i]);
        }
      }
    }
    return res;
  };

  /**
   * Get the view layers data indices.
   *
   * @returns {Array} The list of indices.
   */
  this.getViewDataIndices = function () {
    var res = [];
    for (var i = 0; i < layers.length; ++i) {
      if (layers[i] instanceof dwv.gui.ViewLayer) {
        res.push(layers[i].getDataIndex());
      }
    }
    return res;
  };

  /**
   * Get the active draw layer.
   *
   * @returns {object} The layer.
   */
  this.getActiveDrawLayer = function () {
    return layers[activeDrawLayerIndex];
  };

  /**
   * Get the draw layers associated to a data index.
   *
   * @param {number} index The data index.
   * @returns {Array} The layers.
   */
  this.getDrawLayersByDataIndex = function (index) {
    var res = [];
    for (var i = 0; i < layers.length; ++i) {
      if (layers[i] instanceof dwv.gui.DrawLayer &&
        layers[i].getDataIndex() === index) {
        res.push(layers[i]);
      }
    }
    return res;
  };

  /**
   * Set the active view layer.
   *
   * @param {number} index The index of the layer to set as active.
   */
  this.setActiveViewLayer = function (index) {
    activeViewLayerIndex = index;
  };

  /**
   * Set the active view layer with a data index.
   *
   * @param {number} index The data index.
   */
  this.setActiveViewLayerByDataIndex = function (index) {
    for (var i = 0; i < layers.length; ++i) {
      if (layers[i] instanceof dwv.gui.ViewLayer &&
        layers[i].getDataIndex() === index) {
        this.setActiveViewLayer(i);
        break;
      }
    }
  };

  /**
   * Set the active draw layer.
   *
   * @param {number} index The index of the layer to set as active.
   */
  this.setActiveDrawLayer = function (index) {
    activeDrawLayerIndex = index;
  };

  /**
   * Set the active draw layer with a data index.
   *
   * @param {number} index The data index.
   */
  this.setActiveDrawLayerByDataIndex = function (index) {
    for (var i = 0; i < layers.length; ++i) {
      if (layers[i] instanceof dwv.gui.DrawLayer &&
        layers[i].getDataIndex() === index) {
        this.setActiveDrawLayer(i);
        break;
      }
    }
  };

  /**
   * Add a view layer.
   *
   * @returns {object} The created layer.
   */
  this.addViewLayer = function () {
    // layer index
    var viewLayerIndex = layers.length;
    // create div
    var div = getNextLayerDiv();
    // prepend to container
    containerDiv.append(div);
    // view layer
    var layer = new dwv.gui.ViewLayer(div);
    // add layer
    layers.push(layer);
    // mark it as active
    this.setActiveViewLayer(viewLayerIndex);
    // bind view layer events
    bindViewLayer(layer);
    // return
    return layer;
  };

  /**
   * Add a draw layer.
   *
   * @returns {object} The created layer.
   */
  this.addDrawLayer = function () {
    // store active index
    activeDrawLayerIndex = layers.length;
    // create div
    var div = getNextLayerDiv();
    // prepend to container
    containerDiv.append(div);
    // draw layer
    var layer = new dwv.gui.DrawLayer(div);
    // add layer
    layers.push(layer);
    // bind draw layer events
    bindDrawLayer(layer);
    // return
    return layer;
  };

  /**
   * Bind view layer events to this.
   *
   * @param {object} viewLayer The view layer to bind.
   */
  function bindViewLayer(viewLayer) {
    // listen to position change to update other group layers
    viewLayer.addEventListener(
      'positionchange', self.updateLayersToPositionChange);
    // propagate view viewLayer-layer events
    for (var j = 0; j < dwv.image.viewEventNames.length; ++j) {
      viewLayer.addEventListener(dwv.image.viewEventNames[j], fireEvent);
    }
    // propagate viewLayer events
    viewLayer.addEventListener('renderstart', fireEvent);
    viewLayer.addEventListener('renderend', fireEvent);
  }

  /**
   * Bind draw layer events to this.
   *
   * @param {object} drawLayer The draw layer to bind.
   */
  function bindDrawLayer(drawLayer) {
    // propagate drawLayer events
    drawLayer.addEventListener('drawcreate', fireEvent);
    drawLayer.addEventListener('drawdelete', fireEvent);
  }

  /**
   * Get the next layer DOM div.
   *
   * @returns {HTMLElement} A DOM div.
   */
  function getNextLayerDiv() {
    var div = document.createElement('div');
    div.id = dwv.gui.getLayerDivId(self.getDivId(), layers.length);
    div.className = 'layer';
    div.style.pointerEvents = 'none';
    return div;
  }

  /**
   * Empty the layer list.
   */
  this.empty = function () {
    layers = [];
    // reset active indices
    activeViewLayerIndex = null;
    activeDrawLayerIndex = null;
    // clean container div
    var previous = containerDiv.getElementsByClassName('layer');
    if (previous) {
      while (previous.length > 0) {
        previous[0].remove();
      }
    }
  };

  /**
   * Show a crosshair at a given position.
   *
   * @param {dwv.math.Point} position The position where to show the crosshair.
   */
  function showCrosshairDiv(position) {
    if (typeof position === 'undefined') {
      position = currentPosition;
    }

    // remove previous
    removeCrosshairDiv();

    // use first layer as base for calculating position and
    // line sizes
    var layer0 = layers[0];
    var vc = layer0.getViewController();
    var p2D = vc.getPlanePositionFromPosition(position);
    var displayPos = layer0.planePosToDisplay(p2D.x, p2D.y);

    var lineH = document.createElement('hr');
    lineH.id = self.getDivId() + '-scroll-crosshair-horizontal';
    lineH.className = 'horizontal';
    lineH.style.width = containerDiv.offsetWidth + 'px';
    lineH.style.left = '0px';
    lineH.style.top = displayPos.y + 'px';

    var lineV = document.createElement('hr');
    lineV.id = self.getDivId() + '-scroll-crosshair-vertical';
    lineV.className = 'vertical';
    lineV.style.width = containerDiv.offsetHeight + 'px';
    lineV.style.left = (displayPos.x) + 'px';
    lineV.style.top = '0px';

    containerDiv.appendChild(lineH);
    containerDiv.appendChild(lineV);
  }

  /**
   * Remove crosshair divs.
   */
  function removeCrosshairDiv() {
    var div = document.getElementById(
      self.getDivId() + '-scroll-crosshair-horizontal');
    if (div) {
      div.remove();
    }
    div = document.getElementById(
      self.getDivId() + '-scroll-crosshair-vertical');
    if (div) {
      div.remove();
    }
  }

  /**
   * Update layers (but not the active view layer) to a position change.
   *
   * @param {object} event The position change event.
   */
  this.updateLayersToPositionChange = function (event) {
    // pause positionchange listeners
    for (var j = 0; j < layers.length; ++j) {
      if (layers[j] instanceof dwv.gui.ViewLayer) {
        layers[j].removeEventListener(
          'positionchange', self.updateLayersToPositionChange);
        layers[j].removeEventListener('positionchange', fireEvent);
      }
    }

    var index = new dwv.math.Index(event.value[0]);
    var position = new dwv.math.Point(event.value[1]);

    // store current position
    currentPosition = position;

    if (showCrosshair) {
      showCrosshairDiv(position);
    }

    // origin of the first view layer
    var baseViewLayerOrigin0 = null;
    var baseViewLayerOrigin = null;
    // update position for all layers except the source one
    for (var i = 0; i < layers.length; ++i) {

      // update base offset (does not trigger redraw)
      // TODO check draw layers update
      var hasSetOffset = false;
      if (layers[i] instanceof dwv.gui.ViewLayer) {
        var vc = layers[i].getViewController();
        // origin0 should always be there
        var origin0 = vc.getOrigin();
        // depending on position, origin could be undefined
        var origin = vc.getOrigin(position);

        if (!baseViewLayerOrigin) {
          baseViewLayerOrigin0 = origin0;
          baseViewLayerOrigin = origin;
        } else {
          if (vc.canSetPosition(position) &&
            typeof origin !== 'undefined') {
            // TODO: compensate for possible different orientation between views

            var scrollDiff = baseViewLayerOrigin0.minus(origin0);
            var scrollOffset = new dwv.math.Vector3D(
              scrollDiff.getX(), scrollDiff.getY(), scrollDiff.getZ());

            var planeDiff = baseViewLayerOrigin.minus(origin);
            var planeOffset = new dwv.math.Vector3D(
              planeDiff.getX(), planeDiff.getY(), planeDiff.getZ());

            hasSetOffset = layers[i].setBaseOffset(scrollOffset, planeOffset);
          }
        }
      }

      // update position (triggers redraw)
      var hasSetPos = false;
      if (layers[i].getId() !== event.srclayerid) {
        hasSetPos = layers[i].setCurrentPosition(position, index);
      }

      // force redraw if needed
      if (!hasSetPos && hasSetOffset) {
        layers[i].draw();
      }
    }

    // re-start positionchange listeners
    for (var k = 0; k < layers.length; ++k) {
      if (layers[k] instanceof dwv.gui.ViewLayer) {
        layers[k].addEventListener(
          'positionchange', self.updateLayersToPositionChange);
        layers[k].addEventListener('positionchange', fireEvent);
      }
    }
  };

  /**
   * Calculate the fit scale: the scale that fits the largest data.
   *
   * @returns {number|undefined} The fit scale.
   */
  this.calculateFitScale = function () {
    // check container
    if (containerDiv.offsetWidth === 0 &&
      containerDiv.offsetHeight === 0) {
      throw new Error('Cannot fit to zero sized container.');
    }
    // get max size
    var maxSize = this.getMaxSize();
    if (typeof maxSize === 'undefined') {
      return undefined;
    }
    // return best fit
    return Math.min(
      containerDiv.offsetWidth / maxSize.x,
      containerDiv.offsetHeight / maxSize.y
    );
  };

  /**
   * Set the layer group fit scale.
   *
   * @param {number} scaleIn The fit scale.
   */
  this.setFitScale = function (scaleIn) {
    // get maximum size
    var maxSize = this.getMaxSize();
    // exit if none
    if (typeof maxSize === 'undefined') {
      return;
    }

    var containerSize = {
      x: containerDiv.offsetWidth,
      y: containerDiv.offsetHeight
    };
    // offset to keep data centered
    var fitOffset = {
      x: -0.5 * (containerSize.x - Math.floor(maxSize.x * scaleIn)),
      y: -0.5 * (containerSize.y - Math.floor(maxSize.y * scaleIn))
    };

    // apply to layers
    for (var j = 0; j < layers.length; ++j) {
      layers[j].fitToContainer(scaleIn, containerSize, fitOffset);
    }

    // update crosshair
    if (showCrosshair) {
      showCrosshairDiv();
    }
  };

  /**
   * Get the largest data size.
   *
   * @returns {object|undefined} The largest size as {x,y}.
   */
  this.getMaxSize = function () {
    var maxSize = {x: 0, y: 0};
    for (var j = 0; j < layers.length; ++j) {
      if (layers[j] instanceof dwv.gui.ViewLayer) {
        var size = layers[j].getImageWorldSize();
        if (size.x > maxSize.x) {
          maxSize.x = size.x;
        }
        if (size.y > maxSize.y) {
          maxSize.y = size.y;
        }
      }
    }
    if (maxSize.x === 0 && maxSize.y === 0) {
      maxSize = undefined;
    }
    return maxSize;
  };

  /**
   * Flip all layers along the Z axis without offset compensation.
   */
  this.flipScaleZ = function () {
    baseScale.z *= -1;
    this.setScale(baseScale);
  };

  /**
   * Add scale to the layers. Scale cannot go lower than 0.1.
   *
   * @param {number} scaleStep The scale to add.
   * @param {dwv.math.Point3D} center The scale center Point3D.
   */
  this.addScale = function (scaleStep, center) {
    var newScale = {
      x: scale.x * (1 + scaleStep),
      y: scale.y * (1 + scaleStep),
      z: scale.z * (1 + scaleStep)
    };
    this.setScale(newScale, center);
  };

  /**
   * Set the layers' scale.
   *
   * @param {object} newScale The scale to apply as {x,y,z}.
   * @param {dwv.math.Point3D} center The scale center Point3D.
   * @fires dwv.ctrl.LayerGroup#zoomchange
   */
  this.setScale = function (newScale, center) {
    scale = newScale;
    // apply to layers
    for (var i = 0; i < layers.length; ++i) {
      layers[i].setScale(scale, center);
    }

    // event value
    var value = [
      newScale.x,
      newScale.y,
      newScale.z
    ];
    if (typeof center !== 'undefined') {
      value.push(center.getX());
      value.push(center.getY());
      value.push(center.getZ());
    }

    /**
     * Zoom change event.
     *
     * @event dwv.ctrl.LayerGroup#zoomchange
     * @type {object}
     * @property {Array} value The changed value.
     */
    fireEvent({
      type: 'zoomchange',
      value: value
    });
  };

  /**
   * Add translation to the layers.
   *
   * @param {object} translation The translation as {x,y,z}.
   */
  this.addTranslation = function (translation) {
    this.setOffset({
      x: offset.x - translation.x,
      y: offset.y - translation.y,
      z: offset.z - translation.z
    });
  };

  /**
   * Set the layers' offset.
   *
   * @param {object} newOffset The offset as {x,y,z}.
   * @fires dwv.ctrl.LayerGroup#offsetchange
   */
  this.setOffset = function (newOffset) {
    // store
    offset = newOffset;
    // apply to layers
    for (var i = 0; i < layers.length; ++i) {
      layers[i].setOffset(offset);
    }

    /**
     * Offset change event.
     *
     * @event dwv.ctrl.LayerGroup#offsetchange
     * @type {object}
     * @property {Array} value The changed value.
     */
    fireEvent({
      type: 'offsetchange',
      value: [offset.x, offset.y, offset.z],
    });
  };

  /**
   * Reset the stage to its initial scale and no offset.
   */
  this.reset = function () {
    this.setScale(baseScale);
    this.setOffset({x: 0, y: 0, z: 0});
  };

  /**
   * Draw the layer.
   */
  this.draw = function () {
    for (var i = 0; i < layers.length; ++i) {
      layers[i].draw();
    }
  };

  /**
   * Display the layer.
   *
   * @param {boolean} flag Whether to display the layer or not.
   */
  this.display = function (flag) {
    for (var i = 0; i < layers.length; ++i) {
      layers[i].display(flag);
    }
  };

  /**
   * Add an event listener to this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type, will be called with the fired event.
   */
  this.addEventListener = function (type, callback) {
    listenerHandler.add(type, callback);
  };

  /**
   * Remove an event listener from this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type.
   */
  this.removeEventListener = function (type, callback) {
    listenerHandler.remove(type, callback);
  };

  /**
   * Fire an event: call all associated listeners with the input event object.
   *
   * @param {object} event The event to fire.
   * @private
   */
  function fireEvent(event) {
    listenerHandler.fireEvent(event);
  }

}; // LayerGroup class

// namespaces
var dwv = dwv || {};
dwv.gui = dwv.gui || {};

/**
 * Window/level binder.
 */
dwv.gui.WindowLevelBinder = function () {
  this.getEventType = function () {
    return 'wlchange';
  };
  this.getCallback = function (layerGroup) {
    return function (event) {
      var viewLayers = layerGroup.getViewLayersByDataIndex(event.dataid);
      if (viewLayers.length !== 0) {
        var vc = viewLayers[0].getViewController();
        vc.setWindowLevel(event.value[0], event.value[1]);
      }
    };
  };
};

/**
 * Position binder.
 */
dwv.gui.PositionBinder = function () {
  this.getEventType = function () {
    return 'positionchange';
  };
  this.getCallback = function (layerGroup) {
    return function (event) {
      var pointValues = event.value[1];
      var vc = layerGroup.getActiveViewLayer().getViewController();
      // handle different number of dimensions
      var currentPos = vc.getCurrentPosition();
      var currentDims = currentPos.length();
      var inputDims = pointValues.length;
      if (inputDims !== currentDims) {
        if (inputDims === currentDims - 1) {
          // add missing dim, for ex: input 3D -> current 4D
          pointValues.push(currentPos.get(currentDims - 1));
        } else if (inputDims === currentDims + 1) {
          // remove extra dim, for ex: input 4D -> current 3D
          pointValues.pop();
        }
      }
      vc.setCurrentPosition(new dwv.math.Point(pointValues));
    };
  };
};

/**
 * Zoom binder.
 */
dwv.gui.ZoomBinder = function () {
  this.getEventType = function () {
    return 'zoomchange';
  };
  this.getCallback = function (layerGroup) {
    return function (event) {
      var scale = {
        x: event.value[0],
        y: event.value[1],
        z: event.value[2]
      };
      var center;
      if (event.value.length === 6) {
        center = new dwv.math.Point3D(
          event.value[3],
          event.value[4],
          event.value[5]
        );
      }
      layerGroup.setScale(scale, center);
      layerGroup.draw();
    };
  };
};

/**
 * Offset binder.
 */
dwv.gui.OffsetBinder = function () {
  this.getEventType = function () {
    return 'offsetchange';
  };
  this.getCallback = function (layerGroup) {
    return function (event) {
      layerGroup.setOffset({
        x: event.value[0],
        y: event.value[1],
        z: event.value[2]
      });
      layerGroup.draw();
    };
  };
};

/**
 * Opacity binder. Only propagates to view layers of the same data.
 */
dwv.gui.OpacityBinder = function () {
  this.getEventType = function () {
    return 'opacitychange';
  };
  this.getCallback = function (layerGroup) {
    return function (event) {
      // exit if no data index
      if (typeof event.dataid === 'undefined') {
        return;
      }
      // propagate to first view layer
      var viewLayers = layerGroup.getViewLayersByDataIndex(event.dataid);
      if (viewLayers.length !== 0) {
        viewLayers[0].setOpacity(event.value);
        viewLayers[0].draw();
      }
    };
  };
};

/**
 * Stage: controls a list of layer groups and their
 * synchronisation.
 *
 * @class
 */
dwv.gui.Stage = function () {

  // associated layer groups
  var layerGroups = [];
  // active layer group index
  var activeLayerGroupIndex = null;

  // layer group binders
  var binders = [];
  // binder callbacks
  var callbackStore = null;

  /**
   * Get the layer group at the given index.
   *
   * @param {number} index The index.
   * @returns {dwv.gui.LayerGroup} The layer group.
   */
  this.getLayerGroup = function (index) {
    return layerGroups[index];
  };

  /**
   * Get the number of layer groups that form the stage.
   *
   * @returns {number} The number of layer groups.
   */
  this.getNumberOfLayerGroups = function () {
    return layerGroups.length;
  };

  /**
   * Get the active layer group.
   *
   * @returns {dwv.gui.LayerGroup} The layer group.
   */
  this.getActiveLayerGroup = function () {
    return this.getLayerGroup(activeLayerGroupIndex);
  };

  /**
   * Get the view layers associated to a data index.
   *
   * @param {number} index The data index.
   * @returns {Array} The layers.
   */
  this.getViewLayersByDataIndex = function (index) {
    var res = [];
    for (var i = 0; i < layerGroups.length; ++i) {
      res = res.concat(layerGroups[i].getViewLayersByDataIndex(index));
    }
    return res;
  };

  /**
   * Get the draw layers associated to a data index.
   *
   * @param {number} index The data index.
   * @returns {Array} The layers.
   */
  this.getDrawLayersByDataIndex = function (index) {
    var res = [];
    for (var i = 0; i < layerGroups.length; ++i) {
      res = res.concat(layerGroups[i].getDrawLayersByDataIndex(index));
    }
    return res;
  };

  /**
   * Add a layer group to the list.
   *
   * @param {object} htmlElement The HTML element of the layer group.
   * @returns {dwv.gui.LayerGroup} The newly created layer group.
   */
  this.addLayerGroup = function (htmlElement) {
    activeLayerGroupIndex = layerGroups.length;
    var layerGroup = new dwv.gui.LayerGroup(htmlElement);
    // add to storage
    var isBound = callbackStore && callbackStore.length !== 0;
    if (isBound) {
      this.unbindLayerGroups();
    }
    layerGroups.push(layerGroup);
    if (isBound) {
      this.bindLayerGroups();
    }
    // return created group
    return layerGroup;
  };

  /**
   * Get a layer group from an HTML element id.
   *
   * @param {string} id The element id to find.
   * @returns {dwv.gui.LayerGroup} The layer group.
   */
  this.getLayerGroupByDivId = function (id) {
    return layerGroups.find(function (item) {
      return item.getDivId() === id;
    });
  };

  /**
   * Set the layer groups binders.
   *
   * @param {Array} list The list of binder objects.
   */
  this.setBinders = function (list) {
    if (typeof list === 'undefined' || list === null) {
      throw new Error('Cannot set null or undefined binders');
    }
    if (binders.length !== 0) {
      this.unbindLayerGroups();
    }
    binders = list.slice();
    this.bindLayerGroups();
  };

  /**
   * Empty the layer group list.
   */
  this.empty = function () {
    this.unbindLayerGroups();
    for (var i = 0; i < layerGroups.length; ++i) {
      layerGroups[i].empty();
    }
    layerGroups = [];
    activeLayerGroupIndex = null;
  };

  /**
   * Reset the stage: calls reset on all layer groups.
   */
  this.reset = function () {
    for (var i = 0; i < layerGroups.length; ++i) {
      layerGroups[i].reset();
    }
  };

  /**
   * Draw the stage: calls draw on all layer groups.
   */
  this.draw = function () {
    for (var i = 0; i < layerGroups.length; ++i) {
      layerGroups[i].draw();
    }
  };

  /**
   * Synchronise the fit scale of the group layers.
   */
  this.syncLayerGroupScale = function () {
    var minScale;
    var hasScale = [];
    for (var i = 0; i < layerGroups.length; ++i) {
      var scale = layerGroups[i].calculateFitScale();
      if (typeof scale !== 'undefined') {
        hasScale.push(i);
        if (typeof minScale === 'undefined' || scale < minScale) {
          minScale = scale;
        }
      }
    }
    // exit if no scale
    if (typeof minScale === 'undefined') {
      return;
    }
    // apply min scale to layers
    for (var j = 0; j < layerGroups.length; ++j) {
      if (hasScale.includes(j)) {
        layerGroups[j].setFitScale(minScale);
      }
    }
  };

  /**
   * Bind the layer groups of the stage.
   */
  this.bindLayerGroups = function () {
    if (layerGroups.length === 0 ||
      layerGroups.length === 1 ||
      binders.length === 0) {
      return;
    }
    // create callback store
    callbackStore = new Array(layerGroups.length);
    // add listeners
    for (var i = 0; i < layerGroups.length; ++i) {
      for (var j = 0; j < binders.length; ++j) {
        addEventListeners(i, binders[j]);
      }
    }
  };

  /**
   * Unbind the layer groups of the stage.
   */
  this.unbindLayerGroups = function () {
    if (layerGroups.length === 0 ||
      layerGroups.length === 1 ||
      binders.length === 0 ||
      !callbackStore) {
      return;
    }
    // remove listeners
    for (var i = 0; i < layerGroups.length; ++i) {
      for (var j = 0; j < binders.length; ++j) {
        removeEventListeners(i, binders[j]);
      }
    }
    // clear callback store
    callbackStore = null;
  };

  /**
   * Get the binder callback function for a given layer group index.
   * The function is created if not yet stored.
   *
   * @param {object} binder The layer binder.
   * @param {number} index The index of the associated layer group.
   * @returns {Function} The binder function.
   */
  function getBinderCallback(binder, index) {
    if (typeof callbackStore[index] === 'undefined') {
      callbackStore[index] = [];
    }
    var store = callbackStore[index];
    var binderObj = store.find(function (elem) {
      return elem.binder === binder;
    });
    if (typeof binderObj === 'undefined') {
      // create new callback object
      binderObj = {
        binder: binder,
        callback: function (event) {
          // stop listeners
          removeEventListeners(index, binder);
          // apply binder
          binder.getCallback(layerGroups[index])(event);
          // re-start listeners
          addEventListeners(index, binder);
        }
      };
      callbackStore[index].push(binderObj);
    }
    return binderObj.callback;
  }

  /**
   * Add event listeners for a given layer group index and binder.
   *
   * @param {number} index The index of the associated layer group.
   * @param {object} binder The layer binder.
   */
  function addEventListeners(index, binder) {
    for (var i = 0; i < layerGroups.length; ++i) {
      if (i !== index) {
        layerGroups[index].addEventListener(
          binder.getEventType(),
          getBinderCallback(binder, i)
        );
      }
    }
  }

  /**
   * Remove event listeners for a given layer group index and binder.
   *
   * @param {number} index The index of the associated layer group.
   * @param {object} binder The layer binder.
   */
  function removeEventListeners(index, binder) {
    for (var i = 0; i < layerGroups.length; ++i) {
      if (i !== index) {
        layerGroups[index].removeEventListener(
          binder.getEventType(),
          getBinderCallback(binder, i)
        );
      }
    }
  }
};

// namespaces
var dwv = dwv || {};
dwv.gui = dwv.gui || {};

/**
 * Style class.
 *
 * @class
 */
dwv.gui.Style = function () {
  /**
   * Font size.
   *
   * @private
   * @type {number}
   */
  var fontSize = 10;
  /**
   * Font family.
   *
   * @private
   * @type {string}
   */
  var fontFamily = 'Verdana';
  /**
   * Text colour.
   *
   * @private
   * @type {string}
   */
  var textColour = '#fff';
  /**
   * Line colour.
   *
   * @private
   * @type {string}
   */
  var lineColour = '#ffff80';
  /**
   * Base scale.
   *
   * @private
   * @type {object}
   */
  var baseScale = {x: 1, y: 1};
  /**
   * Zoom scale.
   *
   * @private
   * @type {object}
   */
  var zoomScale = {x: 1, y: 1};
  /**
   * Stroke width.
   *
   * @private
   * @type {number}
   */
  var strokeWidth = 2;

  /**
   * Shadow offset.
   *
   * @private
   * @type {object}
   */
  var shadowOffset = {x: 0.25, y: 0.25};
  /**
   * Tag opacity.
   *
   * @private
   * @type {number}
   */
  var tagOpacity = 0.2;
  /**
   * Text padding.
   *
   * @private
   * @type {number}
   */
  var textPadding = 3;

  /**
   * Get the font family.
   *
   * @returns {string} The font family.
   */
  this.getFontFamily = function () {
    return fontFamily;
  };

  /**
   * Get the font size.
   *
   * @returns {number} The font size.
   */
  this.getFontSize = function () {
    return fontSize;
  };

  /**
   * Get the stroke width.
   *
   * @returns {number} The stroke width.
   */
  this.getStrokeWidth = function () {
    return strokeWidth;
  };

  /**
   * Get the text colour.
   *
   * @returns {string} The text colour.
   */
  this.getTextColour = function () {
    return textColour;
  };

  /**
   * Get the line colour.
   *
   * @returns {string} The line colour.
   */
  this.getLineColour = function () {
    return lineColour;
  };

  /**
   * Set the line colour.
   *
   * @param {string} colour The line colour.
   */
  this.setLineColour = function (colour) {
    lineColour = colour;
  };

  /**
   * Set the base scale.
   *
   * @param {number} scale The scale as {x,y}.
   */
  this.setBaseScale = function (scale) {
    baseScale = scale;
  };

  /**
   * Set the zoom scale.
   *
   * @param {object} scale The scale as {x,y}.
   */
  this.setZoomScale = function (scale) {
    zoomScale = scale;
  };

  /**
   * Get the base scale.
   *
   * @returns {number} The scale as {x,y}.
   */
  this.getBaseScale = function () {
    return baseScale;
  };

  /**
   * Get the zoom scale.
   *
   * @returns {object} The scale as {x,y}.
   */
  this.getZoomScale = function () {
    return zoomScale;
  };

  /**
   * Scale an input value using the base scale.
   *
   * @param {number} value The value to scale.
   * @returns {number} The scaled value.
   */
  this.scale = function (value) {
    // TODO: 2D?
    return value / baseScale.x;
  };

  /**
   * Apply zoom scale on an input value.
   *
   * @param {number} value The value to scale.
   * @returns {object} The scaled value as {x,y}.
   */
  this.applyZoomScale = function (value) {
    // times 2 so that the font size 10 looks like a 10...
    // (same logic as in the DrawController::updateLabelScale)
    return {
      x: 2 * value / zoomScale.x,
      y: 2 * value / zoomScale.y
    };
  };

  /**
   * Get the shadow offset.
   *
   * @returns {object} The offset as {x,y}.
   */
  this.getShadowOffset = function () {
    return shadowOffset;
  };

  /**
   * Get the tag opacity.
   *
   * @returns {number} The opacity.
   */
  this.getTagOpacity = function () {
    return tagOpacity;
  };

  /**
   * Get the text padding.
   *
   * @returns {number} The padding.
   */
  this.getTextPadding = function () {
    return textPadding;
  };

};

/**
 * Get the font definition string.
 *
 * @returns {string} The font definition string.
 */
dwv.gui.Style.prototype.getFontStr = function () {
  return ('normal ' + this.getFontSize() + 'px sans-serif');
};

/**
 * Get the line height.
 *
 * @returns {number} The line height.
 */
dwv.gui.Style.prototype.getLineHeight = function () {
  return (this.getFontSize() + this.getFontSize() / 5);
};

/**
 * Get the font size scaled to the display.
 *
 * @returns {number} The scaled font size.
 */
dwv.gui.Style.prototype.getScaledFontSize = function () {
  return this.scale(this.getFontSize());
};

/**
 * Get the stroke width scaled to the display.
 *
 * @returns {number} The scaled stroke width.
 */
dwv.gui.Style.prototype.getScaledStrokeWidth = function () {
  return this.scale(this.getStrokeWidth());
};

/**
 * Get the shadow line colour.
 *
 * @returns {string} The shadow line colour.
 */
dwv.gui.Style.prototype.getShadowLineColour = function () {
  return dwv.utils.getShadowColour(this.getLineColour());
};

// namespaces
var dwv = dwv || {};
dwv.gui = dwv.gui || {};

/**
 * View layer.
 *
 * @param {object} containerDiv The layer div, its id will be used
 *   as this layer id.
 * @class
 */
dwv.gui.ViewLayer = function (containerDiv) {

  // specific css class name
  containerDiv.className += ' viewLayer';

  // closure to self
  var self = this;

  /**
   * The view controller.
   *
   * @private
   * @type {object}
   */
  var viewController = null;

  /**
   * The main display canvas.
   *
   * @private
   * @type {object}
   */
  var canvas = null;
  /**
   * The offscreen canvas: used to store the raw, unscaled pixel data.
   *
   * @private
   * @type {object}
   */
  var offscreenCanvas = null;
  /**
   * The associated CanvasRenderingContext2D.
   *
   * @private
   * @type {object}
   */
  var context = null;

  /**
   * Flag to know if the current position is valid.
   *
   * @private
   * @type {boolean}
   */
  var isValidPosition = true;

  /**
   * The image data array.
   *
   * @private
   * @type {Array}
   */
  var imageData = null;

  /**
   * The layer base size as {x,y}.
   *
   * @private
   * @type {object}
   */
  var baseSize;

  /**
   * The layer base spacing as {x,y}.
   *
   * @private
   * @type {object}
   */
  var baseSpacing;

  /**
   * The layer opacity.
   *
   * @private
   * @type {number}
   */
  var opacity = 1;

  /**
   * The layer scale.
   *
   * @private
   * @type {object}
   */
  var scale = {x: 1, y: 1};

  /**
   * The layer fit scale.
   *
   * @private
   * @type {object}
   */
  var fitScale = {x: 1, y: 1};

  /**
   * The layer offset.
   *
   * @private
   * @type {object}
   */
  var offset = {x: 0, y: 0};

  /**
   * The base layer offset.
   *
   * @private
   * @type {object}
   */
  var baseOffset = {x: 0, y: 0};

  /**
   * The view offset.
   *
   * @private
   * @type {object}
   */
  var viewOffset = {x: 0, y: 0};

  /**
   * The zoom offset.
   *
   * @private
   * @type {object}
   */
  var zoomOffset = {x: 0, y: 0};

  /**
   * The flip offset.
   *
   * @private
   * @type {object}
   */
  var flipOffset = {x: 0, y: 0};

  /**
   * Data update flag.
   *
   * @private
   * @type {boolean}
   */
  var needsDataUpdate = null;

  /**
   * The associated data index.
   *
   * @private
   * @type {number}
   */
  var dataIndex = null;

  /**
   * Get the associated data index.
   *
   * @returns {number} The index.
   */
  this.getDataIndex = function () {
    return dataIndex;
  };

  /**
   * Listener handler.
   *
   * @private
   * @type {object}
   */
  var listenerHandler = new dwv.utils.ListenerHandler();

  /**
   * Image smoothing flag.
   * see: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/imageSmoothingEnabled
   *
   * @private
   * @type {boolean}
   */
  var imageSmoothingEnabled = false;

  /**
   * Set the imageSmoothingEnabled flag value.
   *
   * @param {boolean} flag True to enable smoothing.
   */
  this.enableImageSmoothing = function (flag) {
    imageSmoothingEnabled = flag;
  };

  /**
   * Set the associated view.
   *
   * @param {object} view The view.
   * @param {number} index The associated data index.
   */
  this.setView = function (view, index) {
    dataIndex = index;
    // local listeners
    view.addEventListener('wlchange', onWLChange);
    view.addEventListener('colourchange', onColourChange);
    view.addEventListener('positionchange', onPositionChange);
    view.addEventListener('alphafuncchange', onAlphaFuncChange);
    // view events
    for (var j = 0; j < dwv.image.viewEventNames.length; ++j) {
      view.addEventListener(dwv.image.viewEventNames[j], fireEvent);
    }
    // create view controller
    viewController = new dwv.ctrl.ViewController(view, index);
  };

  /**
   * Get the view controller.
   *
   * @returns {object} The controller.
   */
  this.getViewController = function () {
    return viewController;
  };

  /**
   * Get the canvas image data.
   *
   * @returns {object} The image data.
   */
  this.getImageData = function () {
    return imageData;
  };

  /**
   * Handle an image set event.
   *
   * @param {object} event The event.
   */
  this.onimageset = function (event) {
    // event.value = [index, image]
    if (dataIndex === event.dataid) {
      viewController.setImage(event.value[0], dataIndex);
      setBaseSize(viewController.getImageSize().get2D());
      needsDataUpdate = true;
    }
  };

  /**
   * Handle an image change event.
   *
   * @param {object} event The event.
   */
  this.onimagechange = function (event) {
    // event.value = [index]
    if (dataIndex === event.dataid) {
      needsDataUpdate = true;
    }
  };

  // common layer methods [start] ---------------

  /**
   * Get the id of the layer.
   *
   * @returns {string} The string id.
   */
  this.getId = function () {
    return containerDiv.id;
  };

  /**
   * Get the layer base size (without scale).
   *
   * @returns {object} The size as {x,y}.
   */
  this.getBaseSize = function () {
    return baseSize;
  };

  /**
   * Get the image world (mm) 2D size.
   *
   * @returns {object} The 2D size as {x,y}.
   */
  this.getImageWorldSize = function () {
    return viewController.getImageWorldSize();
  };

  /**
   * Get the layer opacity.
   *
   * @returns {number} The opacity ([0:1] range).
   */
  this.getOpacity = function () {
    return opacity;
  };

  /**
   * Set the layer opacity.
   *
   * @param {number} alpha The opacity ([0:1] range).
   */
  this.setOpacity = function (alpha) {
    if (alpha === opacity) {
      return;
    }

    opacity = Math.min(Math.max(alpha, 0), 1);

    /**
     * Opacity change event.
     *
     * @event dwv.App#opacitychange
     * @type {object}
     * @property {string} type The event type.
     */
    var event = {
      type: 'opacitychange',
      value: [opacity]
    };
    fireEvent(event);
  };

  /**
   * Add a flip offset along the layer X axis.
   */
  this.addFlipOffsetX = function () {
    // flip scale is handled by layer group
    // flip offset
    flipOffset.x += canvas.width / scale.x;
    offset.x += flipOffset.x;
  };

  /**
   * Add a flip offset along the layer Y axis.
   */
  this.addFlipOffsetY = function () {
    // flip scale is handled by layer group
    // flip offset
    flipOffset.y += canvas.height / scale.y;
    offset.y += flipOffset.y;
  };

  /**
   * Set the layer scale.
   *
   * @param {object} newScale The scale as {x,y}.
   * @param {dwv.math.Point3D} center The scale center.
   */
  this.setScale = function (newScale, center) {
    var helper = viewController.getPlaneHelper();
    var orientedNewScale = helper.getTargetOrientedPositiveXYZ(newScale);
    var finalNewScale = {
      x: fitScale.x * orientedNewScale.x,
      y: fitScale.y * orientedNewScale.y
    };

    if (Math.abs(newScale.x) === 1 &&
      Math.abs(newScale.y) === 1 &&
      Math.abs(newScale.z) === 1) {
      // reset zoom offset for scale=1
      var resetOffset = {
        x: offset.x - zoomOffset.x,
        y: offset.y - zoomOffset.y
      };
      // store new offset
      zoomOffset = {x: 0, y: 0};
      offset = resetOffset;
    } else {
      if (typeof center !== 'undefined') {
        var worldCenter = helper.getPlaneOffsetFromOffset3D({
          x: center.getX(),
          y: center.getY(),
          z: center.getZ()
        });
        // center was obtained with viewLayer.displayToMainPlanePos
        // compensated for baseOffset
        // TODO: justify...
        worldCenter = {
          x: worldCenter.x + baseOffset.x,
          y: worldCenter.y + baseOffset.y
        };

        var newOffset = dwv.gui.getScaledOffset(
          offset, scale, finalNewScale, worldCenter);

        var newZoomOffset = {
          x: zoomOffset.x + newOffset.x - offset.x,
          y: zoomOffset.y + newOffset.y - offset.y
        };
        // store new offset
        zoomOffset = newZoomOffset;
        offset = newOffset;
      }
    }

    // store new scale
    scale = finalNewScale;
  };

  /**
   * Set the base layer offset. Updates the layer offset.
   *
   * @param {dwv.math.Vector3D} scrollOffset The scroll offset vector.
   * @param {dwv.math.Vector3D} planeOffset The plane offset vector.
   * @returns {boolean} True if the offset was updated.
   */
  this.setBaseOffset = function (scrollOffset, planeOffset) {
    var helper = viewController.getPlaneHelper();
    var scrollIndex = helper.getNativeScrollIndex();
    var newOffset = helper.getPlaneOffsetFromOffset3D({
      x: scrollIndex === 0 ? scrollOffset.getX() : planeOffset.getX(),
      y: scrollIndex === 1 ? scrollOffset.getY() : planeOffset.getY(),
      z: scrollIndex === 2 ? scrollOffset.getZ() : planeOffset.getZ(),
    });
    var needsUpdate = baseOffset.x !== newOffset.x ||
      baseOffset.y !== newOffset.y;
    // reset offset if needed
    if (needsUpdate) {
      offset = {
        x: offset.x - baseOffset.x + newOffset.x,
        y: offset.y - baseOffset.y + newOffset.y
      };
      baseOffset = newOffset;
    }
    return needsUpdate;
  };

  /**
   * Set the layer offset.
   *
   * @param {object} newOffset The offset as {x,y}.
   */
  this.setOffset = function (newOffset) {
    var helper = viewController.getPlaneHelper();
    var planeNewOffset = helper.getPlaneOffsetFromOffset3D(newOffset);
    offset = {
      x: planeNewOffset.x +
        viewOffset.x + baseOffset.x + zoomOffset.x + flipOffset.x,
      y: planeNewOffset.y +
        viewOffset.y + baseOffset.y + zoomOffset.y + flipOffset.y
    };
  };

  /**
   * Transform a display position to an index.
   *
   * @param {number} x The X position.
   * @param {number} y The Y position.
   * @returns {dwv.math.Index} The equivalent index.
   */
  this.displayToPlaneIndex = function (x, y) {
    var planePos = this.displayToPlanePos(x, y);
    return new dwv.math.Index([
      Math.floor(planePos.x),
      Math.floor(planePos.y)
    ]);
  };

  /**
   * Remove scale from a display position.
   *
   * @param {number} x The X position.
   * @param {number} y The Y position.
   * @returns {object} The de-scaled position as {x,y}.
   */
  this.displayToPlaneScale = function (x, y) {
    return {
      x: x / scale.x,
      y: y / scale.y
    };
  };

  /**
   * Get a plane position from a display position.
   *
   * @param {number} x The X position.
   * @param {number} y The Y position.
   * @returns {object} The plane position as {x,y}.
   */
  this.displayToPlanePos = function (x, y) {
    var deScaled = this.displayToPlaneScale(x, y);
    return {
      x: deScaled.x + offset.x,
      y: deScaled.y + offset.y
    };
  };

  this.planePosToDisplay = function (x, y) {
    return {
      x: (x - offset.x + baseOffset.x) * scale.x,
      y: (y - offset.y + baseOffset.y) * scale.y
    };
  };

  /**
   * Get a main plane position from a display position.
   *
   * @param {number} x The X position.
   * @param {number} y The Y position.
   * @returns {object} The main plane position as {x,y}.
   */
  this.displayToMainPlanePos = function (x, y) {
    var planePos = this.displayToPlanePos(x, y);
    return {
      x: planePos.x - baseOffset.x,
      y: planePos.y - baseOffset.y
    };
  };

  /**
   * Display the layer.
   *
   * @param {boolean} flag Whether to display the layer or not.
   */
  this.display = function (flag) {
    containerDiv.style.display = flag ? '' : 'none';
  };

  /**
   * Check if the layer is visible.
   *
   * @returns {boolean} True if the layer is visible.
   */
  this.isVisible = function () {
    return containerDiv.style.display === '';
  };

  /**
   * Draw the content (imageData) of the layer.
   * The imageData variable needs to be set
   *
   * @fires dwv.App#renderstart
   * @fires dwv.App#renderend
   */
  this.draw = function () {
    // skip for non valid position
    if (!isValidPosition) {
      return;
    }

    /**
     * Render start event.
     *
     * @event dwv.App#renderstart
     * @type {object}
     * @property {string} type The event type.
     */
    var event = {
      type: 'renderstart',
      layerid: this.getId(),
      dataid: this.getDataIndex()
    };
    fireEvent(event);

    // update data if needed
    if (needsDataUpdate) {
      updateImageData();
    }

    // context opacity
    context.globalAlpha = opacity;

    // clear context
    this.clear();

    // draw the cached canvas on the context
    // transform takes as input a, b, c, d, e, f to create
    // the transform matrix (column-major order):
    // [ a c e ]
    // [ b d f ]
    // [ 0 0 1 ]
    context.setTransform(
      scale.x,
      0,
      0,
      scale.y,
      -1 * offset.x * scale.x,
      -1 * offset.y * scale.y
    );

    // disable smoothing (set just before draw, could be reset by resize)
    context.imageSmoothingEnabled = imageSmoothingEnabled;
    // draw image
    context.drawImage(offscreenCanvas, 0, 0);

    /**
     * Render end event.
     *
     * @event dwv.App#renderend
     * @type {object}
     * @property {string} type The event type.
     */
    event = {
      type: 'renderend',
      layerid: this.getId(),
      dataid: this.getDataIndex()
    };
    fireEvent(event);
  };

  /**
   * Initialise the layer: set the canvas and context
   *
   * @param {object} size The image size as {x,y}.
   * @param {object} spacing The image spacing as {x,y}.
   * @param {number} alpha The initial data opacity.
   */
  this.initialise = function (size, spacing, alpha) {
    // set locals
    baseSpacing = spacing;
    opacity = Math.min(Math.max(alpha, 0), 1);

    // create canvas
    // (canvas size is set in fitToContainer)
    canvas = document.createElement('canvas');
    containerDiv.appendChild(canvas);

    // check that the getContext method exists
    if (!canvas.getContext) {
      alert('Error: no canvas.getContext method.');
      return;
    }
    // get the 2D context
    context = canvas.getContext('2d');
    if (!context) {
      alert('Error: failed to get the 2D context.');
      return;
    }

    // off screen canvas
    offscreenCanvas = document.createElement('canvas');

    // set base size: needs an existing context and off screen canvas
    setBaseSize(size);

    // update data on first draw
    needsDataUpdate = true;
  };

  /**
   * Set the base size of the layer.
   *
   * @param {object} size The size as {x,y}.
   */
  function setBaseSize(size) {
    // check canvas creation
    if (!dwv.gui.canCreateCanvas(size.x, size.y)) {
      throw new Error('Cannot create canvas with size ' +
        size.x + ', ' + size.y);
    }

    // set local
    baseSize = size;

    // off screen canvas
    offscreenCanvas.width = baseSize.x;
    offscreenCanvas.height = baseSize.y;
    // original empty image data array
    context.clearRect(0, 0, baseSize.x, baseSize.y);
    imageData = context.createImageData(baseSize.x, baseSize.y);
  }

  /**
   * Fit the layer to its parent container.
   *
   * @param {number} fitScale1D The 1D fit scale.
   * @param {object} fitSize The fit size as {x,y}.
   * @param {object} fitOffset The fit offset as {x,y}.
   */
  this.fitToContainer = function (fitScale1D, fitSize, fitOffset) {
    var needsDraw = false;

    // update canvas size if needed (triggers canvas reset)
    if (canvas.width !== fitSize.x || canvas.height !== fitSize.y) {
      if (!dwv.gui.canCreateCanvas(fitSize.x, fitSize.y)) {
        throw new Error('Cannot resize canvas ' + fitSize.x + ', ' + fitSize.y);
      }
      // canvas size  change triggers canvas reset
      canvas.width = fitSize.x;
      canvas.height = fitSize.y;
      // update draw flag
      needsDraw = true;
    }

    // previous fit scale
    var previousFitScale = fitScale;
    // previous scale without fit
    var previousScale = {
      x: scale.x / fitScale.x,
      y: scale.y / fitScale.y
    };
    // fit scale
    var newFitScale = {
      x: fitScale1D * baseSpacing.x,
      y: fitScale1D * baseSpacing.y
    };
    // scale
    var newScale = {
      x: previousScale.x * newFitScale.x,
      y: previousScale.y * newFitScale.y
    };
    // check if different
    if (previousScale.x !== newScale.x || previousScale.y !== newScale.y) {
      fitScale = newFitScale;
      scale = newScale;
      // update draw flag
      needsDraw = true;
    }

    // view offset
    var newViewOffset = {
      x: fitOffset.x / newFitScale.x,
      y: fitOffset.y / newFitScale.y
    };
    var newFlipOffset = {
      x: flipOffset.x * previousFitScale.x / newFitScale.x,
      y: flipOffset.y * previousFitScale.y / newFitScale.y
    };
    // check if different
    if (viewOffset.x !== newViewOffset.x ||
      viewOffset.y !== newViewOffset.y ||
      flipOffset.x !== newFlipOffset.x ||
      flipOffset.y !== newFlipOffset.y) {
      // update private local offsets
      flipOffset = newFlipOffset;
      viewOffset = newViewOffset;
      // update global offset
      offset = {
        x: viewOffset.x + baseOffset.x + zoomOffset.x + flipOffset.x,
        y: viewOffset.y + baseOffset.y + zoomOffset.y + flipOffset.y
      };
      // update draw flag
      needsDraw = true;
    }

    // draw if needed
    if (needsDraw) {
      this.draw();
    }
  };

  /**
   * Enable and listen to container interaction events.
   */
  this.bindInteraction = function () {
    // allow pointer events
    containerDiv.style.pointerEvents = 'auto';
    // interaction events
    var names = dwv.gui.interactionEventNames;
    for (var i = 0; i < names.length; ++i) {
      containerDiv.addEventListener(names[i], fireEvent, {passive: true});
    }
  };

  /**
   * Disable and stop listening to container interaction events.
   */
  this.unbindInteraction = function () {
    // disable pointer events
    containerDiv.style.pointerEvents = 'none';
    // interaction events
    var names = dwv.gui.interactionEventNames;
    for (var i = 0; i < names.length; ++i) {
      containerDiv.removeEventListener(names[i], fireEvent);
    }
  };

  /**
   * Add an event listener to this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type, will be called with the fired event.
   */
  this.addEventListener = function (type, callback) {
    listenerHandler.add(type, callback);
  };

  /**
   * Remove an event listener from this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type.
   */
  this.removeEventListener = function (type, callback) {
    listenerHandler.remove(type, callback);
  };

  /**
   * Fire an event: call all associated listeners with the input event object.
   *
   * @param {object} event The event to fire.
   * @private
   */
  function fireEvent(event) {
    event.srclayerid = self.getId();
    event.dataid = dataIndex;
    listenerHandler.fireEvent(event);
  }

  // common layer methods [end] ---------------

  /**
   * Update the canvas image data.
   */
  function updateImageData() {
    // generate image data
    viewController.generateImageData(imageData);
    // pass the data to the off screen canvas
    offscreenCanvas.getContext('2d').putImageData(imageData, 0, 0);
    // update data flag
    needsDataUpdate = false;
  }

  /**
   * Handle window/level change.
   *
   * @param {object} event The event fired when changing the window/level.
   * @private
   */
  function onWLChange(event) {
    // generate and draw if no skip flag
    var skip = typeof event.skipGenerate !== 'undefined' &&
      event.skipGenerate === true;
    if (!skip) {
      needsDataUpdate = true;
      self.draw();
    }
  }

  /**
   * Handle colour map change.
   *
   * @param {object} _event The event fired when changing the colour map.
   * @private
   */
  function onColourChange(_event) {
    var skip = typeof event.skipGenerate !== 'undefined' &&
      event.skipGenerate === true;
    if (!skip) {
      needsDataUpdate = true;
      self.draw();
    }
  }

  /**
   * Handle position change.
   *
   * @param {object} event The event fired when changing the position.
   * @private
   */
  function onPositionChange(event) {
    var skip = typeof event.skipGenerate !== 'undefined' &&
      event.skipGenerate === true;
    if (!skip) {
      var valid = true;
      if (typeof event.valid !== 'undefined') {
        valid = event.valid;
      }
      // clear for non valid events
      if (!valid) {
        // clear only once
        if (isValidPosition) {
          isValidPosition = false;
          self.clear();
        }
      } else {
        // 3D dimensions
        var dims3D = [0, 1, 2];
        // remove scroll index
        var indexScrollIndex = dims3D.indexOf(viewController.getScrollIndex());
        dims3D.splice(indexScrollIndex, 1);
        // remove non scroll index from diff dims
        var diffDims = event.diffDims.filter(function (item) {
          return dims3D.indexOf(item) === -1;
        });
        // update if we have something left
        if (diffDims.length !== 0 || !isValidPosition) {
          // reset valid flag
          isValidPosition = true;
          // reset update flag
          needsDataUpdate = true;
          self.draw();
        }
      }
    }
  }

  /**
   * Handle alpha function change.
   *
   * @param {object} event The event fired when changing the function.
   * @private
   */
  function onAlphaFuncChange(event) {
    var skip = typeof event.skipGenerate !== 'undefined' &&
      event.skipGenerate === true;
    if (!skip) {
      needsDataUpdate = true;
      self.draw();
    }
  }

  /**
   * Set the current position.
   *
   * @param {dwv.math.Point} position The new position.
   * @param {dwv.math.Index} _index The new index.
   * @returns {boolean} True if the position was updated.
   */
  this.setCurrentPosition = function (position, _index) {
    return viewController.setCurrentPosition(position);
  };

  /**
   * Clear the context.
   */
  this.clear = function () {
    // clear the context: reset the transform first
    // store the current transformation matrix
    context.save();
    // use the identity matrix while clearing the canvas
    context.setTransform(1, 0, 0, 1, 0, 0);
    context.clearRect(0, 0, canvas.width, canvas.height);
    // restore the transform
    context.restore();
  };

  /**
   * Align on another layer.
   *
   * @param {dwv.gui.ViewLayer} rhs The layer to align on.
   */
  this.align = function (rhs) {
    canvas.style.top = rhs.getCanvas().offsetTop;
    canvas.style.left = rhs.getCanvas().offsetLeft;
  };

}; // ViewLayer class

// namespaces
var dwv = dwv || {};
dwv.image = dwv.image || {};

/**
 * The JPEG baseline decoder.
 *
 * @external JpegImage
 * @see https://github.com/mozilla/pdf.js/blob/master/src/core/jpg.js
 */
/* global JpegImage */
var hasJpegBaselineDecoder = (typeof JpegImage !== 'undefined');

/**
 * The JPEG decoder namespace.
 *
 * @external jpeg
 * @see https://github.com/rii-mango/JPEGLosslessDecoderJS
 */
/* global jpeg */
var hasJpegLosslessDecoder = (typeof jpeg !== 'undefined') &&
    (typeof jpeg.lossless !== 'undefined');

/**
 * The JPEG 2000 decoder.
 *
 * @external JpxImage
 * @see https://github.com/jpambrun/jpx-medical/blob/master/jpx.js
 */
/* global JpxImage */
var hasJpeg2000Decoder = (typeof JpxImage !== 'undefined');

/**
 * Asynchronous pixel buffer decoder.
 *
 * @class
 * @param {string} script The path to the decoder script to be used
 *   by the web worker.
 * @param {number} _numberOfData The anticipated number of data to decode.
 */
dwv.image.AsynchPixelBufferDecoder = function (script, _numberOfData) {
  // initialise the thread pool
  var pool = new dwv.utils.ThreadPool(10);
  // flag to know if callbacks are set
  var areCallbacksSet = false;
  // closure to self
  var self = this;

  /**
   * Decode a pixel buffer.
   *
   * @param {Array} pixelBuffer The pixel buffer.
   * @param {object} pixelMeta The input meta data.
   * @param {object} info Information object about the input data.
   */
  this.decode = function (pixelBuffer, pixelMeta, info) {
    if (!areCallbacksSet) {
      areCallbacksSet = true;
      // set event handlers
      pool.onworkstart = self.ondecodestart;
      pool.onworkitem = self.ondecodeditem;
      pool.onwork = self.ondecoded;
      pool.onworkend = self.ondecodeend;
      pool.onerror = self.onerror;
      pool.onabort = self.onabort;
    }
    // create worker task
    var workerTask = new dwv.utils.WorkerTask(
      script,
      {
        buffer: pixelBuffer,
        meta: pixelMeta
      },
      info
    );
    // add it the queue and run it
    pool.addWorkerTask(workerTask);
  };

  /**
   * Abort decoding.
   */
  this.abort = function () {
    // abort the thread pool, will trigger pool.onabort
    pool.abort();
  };
};

/**
 * Handle a decode start event.
 * Default does nothing.
 *
 * @param {object} _event The decode start event.
 */
dwv.image.AsynchPixelBufferDecoder.prototype.ondecodestart = function (
  _event) {};
/**
 * Handle a decode item event.
 * Default does nothing.
 *
 * @param {object} _event The decode item event fired
 *   when a decode item ended successfully.
 */
dwv.image.AsynchPixelBufferDecoder.prototype.ondecodeditem = function (
  _event) {};
/**
 * Handle a decode event.
 * Default does nothing.
 *
 * @param {object} _event The decode event fired
 *   when a file has been decoded successfully.
 */
dwv.image.AsynchPixelBufferDecoder.prototype.ondecoded = function (
  _event) {};
/**
 * Handle a decode end event.
 * Default does nothing.
 *
 * @param {object} _event The decode end event fired
 *  when a file decoding has completed, successfully or not.
 */
dwv.image.AsynchPixelBufferDecoder.prototype.ondecodeend = function (
  _event) {};
/**
 * Handle an error event.
 * Default does nothing.
 *
 * @param {object} _event The error event.
 */
dwv.image.AsynchPixelBufferDecoder.prototype.onerror = function (_event) {};
/**
 * Handle an abort event.
 * Default does nothing.
 *
 * @param {object} _event The abort event.
 */
dwv.image.AsynchPixelBufferDecoder.prototype.onabort = function (_event) {};

/**
 * Synchronous pixel buffer decoder.
 *
 * @class
 * @param {string} algoName The decompression algorithm name.
 * @param {number} numberOfData The anticipated number of data to decode.
 */
dwv.image.SynchPixelBufferDecoder = function (algoName, numberOfData) {
  // decode count
  var decodeCount = 0;

  /**
   * Decode a pixel buffer.
   *
   * @param {Array} pixelBuffer The pixel buffer.
   * @param {object} pixelMeta The input meta data.
   * @param {object} info Information object about the input data.
   * @external jpeg
   * @external JpegImage
   * @external JpxImage
   */
  this.decode = function (pixelBuffer, pixelMeta, info) {
    ++decodeCount;

    var decoder = null;
    var decodedBuffer = null;
    if (algoName === 'jpeg-lossless') {
      if (!hasJpegLosslessDecoder) {
        throw new Error('No JPEG Lossless decoder provided');
      }
      // bytes per element
      var bpe = pixelMeta.bitsAllocated / 8;
      var buf = new Uint8Array(pixelBuffer);
      decoder = new jpeg.lossless.Decoder();
      var decoded = decoder.decode(buf.buffer, 0, buf.buffer.byteLength, bpe);
      if (pixelMeta.bitsAllocated === 8) {
        if (pixelMeta.isSigned) {
          decodedBuffer = new Int8Array(decoded.buffer);
        } else {
          decodedBuffer = new Uint8Array(decoded.buffer);
        }
      } else if (pixelMeta.bitsAllocated === 16) {
        if (pixelMeta.isSigned) {
          decodedBuffer = new Int16Array(decoded.buffer);
        } else {
          decodedBuffer = new Uint16Array(decoded.buffer);
        }
      }
    } else if (algoName === 'jpeg-baseline') {
      if (!hasJpegBaselineDecoder) {
        throw new Error('No JPEG Baseline decoder provided');
      }
      decoder = new JpegImage();
      decoder.parse(pixelBuffer);
      decodedBuffer = decoder.getData(decoder.width, decoder.height);
    } else if (algoName === 'jpeg2000') {
      if (!hasJpeg2000Decoder) {
        throw new Error('No JPEG 2000 decoder provided');
      }
      // decompress pixel buffer into Int16 image
      decoder = new JpxImage();
      decoder.parse(pixelBuffer);
      // set the pixel buffer
      decodedBuffer = decoder.tiles[0].items;
    } else if (algoName === 'rle') {
      // decode DICOM buffer
      decoder = new dwv.decoder.RleDecoder();
      // set the pixel buffer
      decodedBuffer = decoder.decode(
        pixelBuffer,
        pixelMeta.bitsAllocated,
        pixelMeta.isSigned,
        pixelMeta.sliceSize,
        pixelMeta.samplesPerPixel,
        pixelMeta.planarConfiguration);
    }
    // send decode events
    this.ondecodeditem({
      data: [decodedBuffer],
      index: info.itemNumber
    });
    // decode end?
    if (decodeCount === numberOfData) {
      this.ondecoded({});
      this.ondecodeend({});
    }
  };

  /**
   * Abort decoding.
   */
  this.abort = function () {
    // nothing to do in the synchronous case.
    // callback
    this.onabort({});
    this.ondecodeend({});
  };
};

/**
 * Handle a decode start event.
 * Default does nothing.
 *
 * @param {object} _event The decode start event.
 */
dwv.image.SynchPixelBufferDecoder.prototype.ondecodestart = function (
  _event) {};
/**
 * Handle a decode item event.
 * Default does nothing.
 *
 * @param {object} _event The decode item event fired
 *   when a decode item ended successfully.
 */
dwv.image.SynchPixelBufferDecoder.prototype.ondecodeditem = function (
  _event) {};
/**
 * Handle a decode event.
 * Default does nothing.
 *
 * @param {object} _event The decode event fired
 *   when a file has been decoded successfully.
 */
dwv.image.SynchPixelBufferDecoder.prototype.ondecoded = function (
  _event) {};
/**
 * Handle a decode end event.
 * Default does nothing.
 *
 * @param {object} _event The decode end event fired
 *  when a file decoding has completed, successfully or not.
 */
dwv.image.SynchPixelBufferDecoder.prototype.ondecodeend = function (
  _event) {};
/**
 * Handle an error event.
 * Default does nothing.
 *
 * @param {object} _event The error event.
 */
dwv.image.SynchPixelBufferDecoder.prototype.onerror = function (_event) {};
/**
 * Handle an abort event.
 * Default does nothing.
 *
 * @param {object} _event The abort event.
 */
dwv.image.SynchPixelBufferDecoder.prototype.onabort = function (_event) {};

/**
 * Decode a pixel buffer.
 *
 * @class
 * @param {string} algoName The decompression algorithm name.
 * @param {number} numberOfData The anticipated number of data to decode.
 * If the 'dwv.image.decoderScripts' variable does not contain the desired,
 * algorythm the decoder will switch to the synchronous mode.
 */
dwv.image.PixelBufferDecoder = function (algoName, numberOfData) {
  /**
   * Pixel decoder.
   * Defined only once.
   *
   * @private
   * @type {object}
   */
  var pixelDecoder = null;

  // initialise the asynch decoder (if possible)
  if (typeof dwv.image.decoderScripts !== 'undefined' &&
    typeof dwv.image.decoderScripts[algoName] !== 'undefined') {
    pixelDecoder = new dwv.image.AsynchPixelBufferDecoder(
      dwv.image.decoderScripts[algoName], numberOfData);
  } else {
    pixelDecoder = new dwv.image.SynchPixelBufferDecoder(
      algoName, numberOfData);
  }

  // flag to know if callbacks are set
  var areCallbacksSet = false;

  /**
   * Get data from an input buffer using a DICOM parser.
   *
   * @param {Array} pixelBuffer The input data buffer.
   * @param {object} pixelMeta The input meta data.
   * @param {object} info Information object about the input data.
   */
  this.decode = function (pixelBuffer, pixelMeta, info) {
    if (!areCallbacksSet) {
      areCallbacksSet = true;
      // set callbacks
      pixelDecoder.ondecodestart = this.ondecodestart;
      pixelDecoder.ondecodeditem = this.ondecodeditem;
      pixelDecoder.ondecoded = this.ondecoded;
      pixelDecoder.ondecodeend = this.ondecodeend;
      pixelDecoder.onerror = this.onerror;
      pixelDecoder.onabort = this.onabort;
    }
    // decode and call the callback
    pixelDecoder.decode(pixelBuffer, pixelMeta, info);
  };

  /**
   * Abort decoding.
   */
  this.abort = function () {
    // decoder classes should define an abort
    pixelDecoder.abort();
  };
};

/**
 * Handle a decode start event.
 * Default does nothing.
 *
 * @param {object} _event The decode start event.
 */
dwv.image.PixelBufferDecoder.prototype.ondecodestart = function (_event) {};
/**
 * Handle a decode item event.
 * Default does nothing.
 *
 * @param {object} _event The decode item event fired
 *   when a decode item ended successfully.
 */
dwv.image.PixelBufferDecoder.prototype.ondecodeditem = function (_event) {};
/**
 * Handle a decode event.
 * Default does nothing.
 *
 * @param {object} _event The decode event fired
 *   when a file has been decoded successfully.
 */
dwv.image.PixelBufferDecoder.prototype.ondecoded = function (_event) {};
/**
 * Handle a decode end event.
 * Default does nothing.
 *
 * @param {object} _event The decode end event fired
 *  when a file decoding has completed, successfully or not.
 */
dwv.image.PixelBufferDecoder.prototype.ondecodeend = function (_event) {};
/**
 * Handle an error event.
 * Default does nothing.
 *
 * @param {object} _event The error event.
 */
dwv.image.PixelBufferDecoder.prototype.onerror = function (_event) {};
/**
 * Handle an abort event.
 * Default does nothing.
 *
 * @param {object} _event The abort event.
 */
dwv.image.PixelBufferDecoder.prototype.onabort = function (_event) {};

// namespaces
var dwv = dwv || {};
dwv.image = dwv.image || {};

/**
 * Create a dwv.image.View from a DICOM buffer.
 *
 * @class
 */
dwv.image.DicomBufferToView = function () {
  // closure to self
  var self = this;

  /**
   * Converter options.
   *
   * @private
   * @type {object}
   */
  var options;

  /**
   * Set the converter options.
   *
   * @param {object} opt The input options.
   */
  this.setOptions = function (opt) {
    options = opt;
  };

  /**
   * Pixel buffer decoder.
   * Define only once to allow optional asynchronous mode.
   *
   * @private
   * @type {object}
   */
  var pixelDecoder = null;

  // local tmp storage
  var dicomParserStore = [];
  var finalBufferStore = [];
  var decompressedSizes = [];

  /**
   * Generate the image object.
   *
   * @param {number} index The data index.
   * @param {string} origin The data origin.
   */
  function generateImage(index, origin) {
    var dicomElements = dicomParserStore[index].getDicomElements();

    var modality = dwv.dicom.cleanString(dicomElements.getFromKey('x00080060'));
    var factory;
    if (modality && modality === 'SEG') {
      factory = new dwv.image.MaskFactory();
    } else {
      factory = new dwv.image.ImageFactory();
    }

    // create the image
    try {
      var image = factory.create(
        dicomElements,
        finalBufferStore[index],
        options.numberOfFiles);
      // call onloaditem
      self.onloaditem({
        data: {
          image: image,
          info: dicomParserStore[index].getRawDicomElements()
        },
        source: origin
      });
    } catch (error) {
      self.onerror({
        error: error,
        source: origin
      });
      self.onloadend({
        source: origin
      });
    }
  }

  /**
   * Handle a decoded item event.
   *
   * @param {object} event The decoded item event.
   */
  function onDecodedItem(event) {
    // send progress
    self.onprogress({
      lengthComputable: true,
      loaded: event.itemNumber + 1,
      total: event.numberOfItems,
      index: event.dataIndex,
      source: origin
    });

    var dataIndex = event.dataIndex;

    // store decoded data
    var decodedData = event.data[0];
    if (event.numberOfItems !== 1) {
      // allocate buffer if not done yet
      if (typeof decompressedSizes[dataIndex] === 'undefined') {
        decompressedSizes[dataIndex] = decodedData.length;
        var fullSize = event.numberOfItems * decompressedSizes[dataIndex];
        try {
          finalBufferStore[dataIndex] = new decodedData.constructor(fullSize);
        } catch (error) {
          if (error instanceof RangeError) {
            var powerOf2 = Math.floor(Math.log(fullSize) / Math.log(2));
            dwv.logger.error('Cannot allocate ' +
              decodedData.constructor.name +
              ' of size: ' +
              fullSize + ' (>2^' + powerOf2 + ') for decompressed data.');
          }
          // abort
          pixelDecoder.abort();
          // send events
          self.onerror({
            error: error,
            source: origin
          });
          self.onloadend({
            source: origin
          });
          // exit
          return;
        }
      }
      // hoping for all items to have the same size...
      if (decodedData.length !== decompressedSizes[dataIndex]) {
        dwv.logger.warn('Unsupported varying decompressed data size: ' +
          decodedData.length + ' != ' + decompressedSizes[dataIndex]);
      }
      // set buffer item data
      finalBufferStore[dataIndex].set(
        decodedData, decompressedSizes[dataIndex] * event.itemNumber);
    } else {
      finalBufferStore[dataIndex] = decodedData;
    }

    // create image for the first item
    if (event.itemNumber === 0) {
      generateImage(dataIndex, origin);
    }
  }

  /**
   * Get data from an input buffer using a DICOM parser.
   *
   * @param {Array} buffer The input data buffer.
   * @param {string} origin The data origin.
   * @param {number} dataIndex The data index.
   */
  this.convert = function (buffer, origin, dataIndex) {
    self.onloadstart({
      source: origin,
      dataIndex: dataIndex
    });

    // DICOM parser
    var dicomParser = new dwv.dicom.DicomParser();
    var imageFactory = new dwv.ImageFactory();

    if (typeof options.defaultCharacterSet !== 'undefined') {
      dicomParser.setDefaultCharacterSet(options.defaultCharacterSet);
    }
    // parse the buffer
    try {
      dicomParser.parse(buffer);
      // check elements are good for image
      imageFactory.checkElements(dicomParser.getDicomElements());
    } catch (error) {
      self.onerror({
        error: error,
        source: origin
      });
      self.onloadend({
        source: origin
      });
      return;
    }

    var pixelBuffer = dicomParser.getRawDicomElements().x7FE00010.value;
    // help GC: discard pixel buffer from elements
    dicomParser.getRawDicomElements().x7FE00010.value = [];
    var syntax = dwv.dicom.cleanString(
      dicomParser.getRawDicomElements().x00020010.value[0]);
    var algoName = dwv.dicom.getSyntaxDecompressionName(syntax);
    var needDecompression = (algoName !== null);

    // store
    dicomParserStore[dataIndex] = dicomParser;
    finalBufferStore[dataIndex] = pixelBuffer[0];

    if (needDecompression) {
      // gather pixel buffer meta data
      var bitsAllocated = dicomParser.getRawDicomElements().x00280100.value[0];
      var pixelRepresentation =
        dicomParser.getRawDicomElements().x00280103.value[0];
      var pixelMeta = {
        bitsAllocated: bitsAllocated,
        isSigned: (pixelRepresentation === 1)
      };
      var columnsElement = dicomParser.getRawDicomElements().x00280011;
      var rowsElement = dicomParser.getRawDicomElements().x00280010;
      if (typeof columnsElement !== 'undefined' &&
        typeof rowsElement !== 'undefined') {
        pixelMeta.sliceSize = columnsElement.value[0] * rowsElement.value[0];
      }
      var samplesPerPixelElement = dicomParser.getRawDicomElements().x00280002;
      if (typeof samplesPerPixelElement !== 'undefined') {
        pixelMeta.samplesPerPixel = samplesPerPixelElement.value[0];
      }
      var planarConfigurationElement =
        dicomParser.getRawDicomElements().x00280006;
      if (typeof planarConfigurationElement !== 'undefined') {
        pixelMeta.planarConfiguration = planarConfigurationElement.value[0];
      }

      // number of items
      var numberOfItems = pixelBuffer.length;

      // setup the decoder (one decoder per all converts)
      if (pixelDecoder === null) {
        pixelDecoder = new dwv.image.PixelBufferDecoder(
          algoName, numberOfItems);
        // callbacks
        // pixelDecoder.ondecodestart: nothing to do
        pixelDecoder.ondecodeditem = function (event) {
          onDecodedItem(event);
          // send onload and onloadend when all items have been decoded
          if (event.itemNumber + 1 === event.numberOfItems) {
            self.onload(event);
            self.onloadend(event);
          }
        };
        // pixelDecoder.ondecoded: nothing to do
        // pixelDecoder.ondecodeend: nothing to do
        pixelDecoder.onerror = self.onerror;
        pixelDecoder.onabort = self.onabort;
      }

      // launch decode
      for (var i = 0; i < numberOfItems; ++i) {
        pixelDecoder.decode(pixelBuffer[i], pixelMeta,
          {
            itemNumber: i,
            numberOfItems: numberOfItems,
            dataIndex: dataIndex
          }
        );
      }
    } else {
      // no decompression
      // send progress
      self.onprogress({
        lengthComputable: true,
        loaded: 100,
        total: 100,
        index: dataIndex,
        source: origin
      });
      // generate image
      generateImage(dataIndex, origin);
      // send load events
      self.onload({
        source: origin
      });
      self.onloadend({
        source: origin
      });
    }
  };

  /**
   * Abort a conversion.
   */
  this.abort = function () {
    // abort decoding, will trigger pixelDecoder.onabort
    if (pixelDecoder) {
      pixelDecoder.abort();
    }
  };
};

/**
 * Handle a load start event.
 * Default does nothing.
 *
 * @param {object} _event The load start event.
 */
dwv.image.DicomBufferToView.prototype.onloadstart = function (_event) {};
/**
 * Handle a load item event.
 * Default does nothing.
 *
 * @param {object} _event The load item event.
 */
dwv.image.DicomBufferToView.prototype.onloaditem = function (_event) {};
/**
 * Handle a load progress event.
 * Default does nothing.
 *
 * @param {object} _event The progress event.
 */
dwv.image.DicomBufferToView.prototype.onprogress = function (_event) {};
/**
 * Handle a load event.
 * Default does nothing.
 *
 * @param {object} _event The load event fired
 *   when a file has been loaded successfully.
 */
dwv.image.DicomBufferToView.prototype.onload = function (_event) {};
/**
 * Handle a load end event.
 * Default does nothing.
 *
 * @param {object} _event The load end event fired
 *  when a file load has completed, successfully or not.
 */
dwv.image.DicomBufferToView.prototype.onloadend = function (_event) {};
/**
 * Handle an error event.
 * Default does nothing.
 *
 * @param {object} _event The error event.
 */
dwv.image.DicomBufferToView.prototype.onerror = function (_event) {};
/**
 * Handle an abort event.
 * Default does nothing.
 *
 * @param {object} _event The abort event.
 */
dwv.image.DicomBufferToView.prototype.onabort = function (_event) {};

// namespaces
var dwv = dwv || {};
dwv.image = dwv.image || {};

/**
 * Create a simple array buffer from an ImageData buffer.
 *
 * @param {object} imageData The ImageData taken from a context.
 * @returns {Array} The image buffer.
 */
dwv.image.imageDataToBuffer = function (imageData) {
  // remove alpha
  // TODO support passing the full image data
  var dataLen = imageData.data.length;
  var buffer = new Uint8Array((dataLen / 4) * 3);
  var j = 0;
  for (var i = 0; i < dataLen; i += 4) {
    buffer[j] = imageData.data[i];
    buffer[j + 1] = imageData.data[i + 1];
    buffer[j + 2] = imageData.data[i + 2];
    j += 3;
  }
  return buffer;
};

/**
 * Get an image from an input context imageData.
 *
 * @param {number} width The width of the coresponding image.
 * @param {number} height The height of the coresponding image.
 * @param {number} sliceIndex The slice index of the imageData.
 * @param {object} imageBuffer The image buffer.
 * @param {number} numberOfFrames The final number of frames.
 * @param {string} imageUid The image UID.
 * @returns {object} The corresponding view.
 */
dwv.image.getDefaultImage = function (
  width, height, sliceIndex,
  imageBuffer, numberOfFrames,
  imageUid) {
  // image size
  var imageSize = new dwv.image.Size([width, height, 1]);
  // default spacing
  // TODO: misleading...
  var imageSpacing = new dwv.image.Spacing([1, 1, 1]);
  // default origin
  var origin = new dwv.math.Point3D(0, 0, sliceIndex);
  // create image
  var geometry = new dwv.image.Geometry(origin, imageSize, imageSpacing);
  var image = new dwv.image.Image(geometry, imageBuffer, [imageUid]);
  image.setPhotometricInterpretation('RGB');
  // meta information
  var meta = {};
  meta.BitsStored = 8;
  if (typeof numberOfFrames !== 'undefined') {
    meta.numberOfFiles = numberOfFrames;
  }
  image.setMeta(meta);
  // return
  return image;
};

/**
 * Get data from an input image using a canvas.
 *
 * @param {object} domImage The DOM Image.
 * @param {object} origin The data origin.
 * @returns {object} A load data event.
 */
dwv.image.getViewFromDOMImage = function (domImage, origin) {
  // image size
  var width = domImage.width;
  var height = domImage.height;

  // draw the image in the canvas in order to get its data
  var canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  var ctx = canvas.getContext('2d');
  ctx.drawImage(domImage, 0, 0);
  // get the image data
  var imageData = ctx.getImageData(0, 0, width, height);

  // image properties
  var info = {};
  if (typeof domImage.origin === 'string') {
    info['origin'] = {value: domImage.origin};
  } else {
    info['fileName'] = {value: domImage.origin.name};
    info['fileType'] = {value: domImage.origin.type};
    info['fileLastModifiedDate'] = {value: domImage.origin.lastModifiedDate};
  }
  info['imageWidth'] = {value: width};
  info['imageHeight'] = {value: height};

  var sliceIndex = domImage.index ? domImage.index : 0;
  info['imageUid'] = {value: sliceIndex};

  // create view
  var imageBuffer = dwv.image.imageDataToBuffer(imageData);
  var image = dwv.image.getDefaultImage(
    width, height, sliceIndex, imageBuffer, 1, sliceIndex);

  // return
  return {
    data: {
      image: image,
      info: info
    },
    source: origin
  };
};

/**
 * Get data from an input image using a canvas.
 *
 * @param {object} video The DOM Video.
 * @param {Function} onloaditem On load callback.
 * @param {object} onload The function to call once the data is loaded.
 * @param {object} onprogress The function to call to report progress.
 * @param {object} onloadend The function to call to report load end.
 * @param {number} dataIndex The data index.
 * @param {object} origin The data origin.
 */
dwv.image.getViewFromDOMVideo = function (
  video, onloaditem, onload, onprogress, onloadend,
  dataIndex, origin) {
  // video size
  var width = video.videoWidth;
  var height = video.videoHeight;

  // default frame rate...
  var frameRate = 30;
  // number of frames
  var numberOfFrames = Math.ceil(video.duration * frameRate);

  // video properties
  var info = {};
  if (video.file) {
    info['fileName'] = {value: video.file.name};
    info['fileType'] = {value: video.file.type};
    info['fileLastModifiedDate'] = {value: video.file.lastModifiedDate};
  }
  info['imageWidth'] = {value: width};
  info['imageHeight'] = {value: height};
  info['numberOfFrames'] = {value: numberOfFrames};
  info['imageUid'] = {value: 0};

  // draw the image in the canvas in order to get its data
  var canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  var ctx = canvas.getContext('2d');

  // using seeked to loop through all video frames
  video.addEventListener('seeked', onseeked, false);

  // current frame index
  var frameIndex = 0;
  // video image
  var image = null;

  /**
   * Draw the context and store it as a frame
   */
  function storeFrame() {
    // send progress
    onprogress({
      lengthComputable: true,
      loaded: frameIndex,
      total: numberOfFrames,
      index: dataIndex,
      source: origin
    });
    // draw image
    ctx.drawImage(video, 0, 0);
    // context to image buffer
    var imgBuffer = dwv.image.imageDataToBuffer(
      ctx.getImageData(0, 0, width, height));
    if (frameIndex === 0) {
      // create view
      image = dwv.image.getDefaultImage(
        width, height, 1, imgBuffer, numberOfFrames, dataIndex);
      // call callback
      onloaditem({
        data: {
          image: image,
          info: info
        },
        source: origin
      });
    } else {
      image.appendFrameBuffer(imgBuffer, frameIndex);
    }
    // increment index
    ++frameIndex;
  }

  var nextTime = 0;

  /**
   * Handle seeked event
   */
  function onseeked(/*event*/) {
    // store
    storeFrame();
    // set the next time
    // (not using currentTime, it seems to get offseted)
    nextTime += 1 / frameRate;
    if (nextTime <= this.duration) {
      this.currentTime = nextTime;
    } else {
      onload({
        source: origin
      });
      onloadend({
        source: origin
      });
      // stop listening
      video.removeEventListener('seeked', onseeked);
    }
  }

  // trigger the first seek
  video.currentTime = nextTime;
};

// namespaces
var dwv = dwv || {};
dwv.image = dwv.image || {};
/** @namespace */
dwv.image.filter = dwv.image.filter || {};

/**
 * Threshold an image between an input minimum and maximum.
 *
 * @class
 */
dwv.image.filter.Threshold = function () {
  /**
   * Threshold minimum.
   *
   * @private
   * @type {number}
   */
  var min = 0;
  /**
   * Threshold maximum.
   *
   * @private
   * @type {number}
   */
  var max = 0;

  /**
   * Get the threshold minimum.
   *
   * @returns {number} The threshold minimum.
   */
  this.getMin = function () {
    return min;
  };
  /**
   * Set the threshold minimum.
   *
   * @param {number} val The threshold minimum.
   */
  this.setMin = function (val) {
    min = val;
  };
  /**
   * Get the threshold maximum.
   *
   * @returns {number} The threshold maximum.
   */
  this.getMax = function () {
    return max;
  };
  /**
   * Set the threshold maximum.
   *
   * @param {number} val The threshold maximum.
   */
  this.setMax = function (val) {
    max = val;
  };
  /**
   * Get the name of the filter.
   *
   * @returns {string} The name of the filter.
   */
  this.getName = function () {
    return 'Threshold';
  };

  /**
   * Original image.
   *
   * @private
   * @type {dwv.image.Image}
   */
  var originalImage = null;
  /**
   * Set the original image.
   *
   * @param {dwv.image.Image} image The original image.
   */
  this.setOriginalImage = function (image) {
    originalImage = image;
  };
  /**
   * Get the original image.
   *
   * @returns {dwv.image.Image} image The original image.
   */
  this.getOriginalImage = function () {
    return originalImage;
  };
};

/**
 * Transform the main image using this filter.
 *
 * @returns {dwv.image.Image} The transformed image.
 */
dwv.image.filter.Threshold.prototype.update = function () {
  var image = this.getOriginalImage();
  var imageMin = image.getDataRange().min;
  var self = this;
  var threshFunction = function (value) {
    if (value < self.getMin() || value > self.getMax()) {
      return imageMin;
    } else {
      return value;
    }
  };
  return image.transform(threshFunction);
};

/**
 * Sharpen an image using a sharpen convolution matrix.
 *
 * @class
 */
dwv.image.filter.Sharpen = function () {
  /**
   * Get the name of the filter.
   *
   * @returns {string} The name of the filter.
   */
  this.getName = function () {
    return 'Sharpen';
  };
  /**
   * Original image.
   *
   * @private
   * @type {dwv.image.Image}
   */
  var originalImage = null;
  /**
   * Set the original image.
   *
   * @param {dwv.image.Image} image The original image.
   */
  this.setOriginalImage = function (image) {
    originalImage = image;
  };
  /**
   * Get the original image.
   *
   * @returns {dwv.image.Image} image The original image.
   */
  this.getOriginalImage = function () {
    return originalImage;
  };
};

/**
 * Transform the main image using this filter.
 *
 * @returns {dwv.image.Image} The transformed image.
 */
dwv.image.filter.Sharpen.prototype.update = function () {
  var image = this.getOriginalImage();

  return image.convolute2D(
    [0,
      -1,
      0,
      -1,
      5,
      -1,
      0,
      -1,
      0]);
};

/**
 * Apply a Sobel filter to an image.
 *
 * @class
 */
dwv.image.filter.Sobel = function () {
  /**
   * Get the name of the filter.
   *
   * @returns {string} The name of the filter.
   */
  this.getName = function () {
    return 'Sobel';
  };
  /**
   * Original image.
   *
   * @private
   * @type {dwv.image.Image}
   */
  var originalImage = null;
  /**
   * Set the original image.
   *
   * @param {dwv.image.Image} image The original image.
   */
  this.setOriginalImage = function (image) {
    originalImage = image;
  };
  /**
   * Get the original image.
   *
   * @returns {dwv.image.Image} image The original image.
   */
  this.getOriginalImage = function () {
    return originalImage;
  };
};

/**
 * Transform the main image using this filter.
 *
 * @returns {dwv.image.Image} The transformed image.
 */
dwv.image.filter.Sobel.prototype.update = function () {
  var image = this.getOriginalImage();

  var gradX = image.convolute2D(
    [1,
      0,
      -1,
      2,
      0,
      -2,
      1,
      0,
      -1]);

  var gradY = image.convolute2D(
    [1,
      2,
      1,
      0,
      0,
      0,
      -1,
      -2,
      -1]);

  return gradX.compose(gradY, function (x, y) {
    return Math.sqrt(x * x + y * y);
  });
};

// namespaces
var dwv = dwv || {};
dwv.image = dwv.image || {};

/**
 * 2D/3D Geometry class.
 *
 * @class
 * @param {dwv.math.Point3D} origin The object origin (a 3D point).
 * @param {dwv.image.Size} size The object size.
 * @param {dwv.image.Spacing} spacing The object spacing.
 * @param {dwv.math.Matrix33} orientation The object orientation (3*3 matrix,
 *   default to 3*3 identity).
 * @param {number} time Optional time index.
 */
dwv.image.Geometry = function (origin, size, spacing, orientation, time) {
  var origins = [origin];
  // local helper object for time points
  var timeOrigins = {};
  var initialTime;
  if (typeof time !== 'undefined') {
    initialTime = time;
    timeOrigins[time] = [origin];
  }
  // check input orientation
  if (typeof orientation === 'undefined') {
    orientation = new dwv.math.getIdentityMat33();
  }
  // flag to know if new origins were added
  var newOrigins = false;

  /**
   * Get the time value that was passed at construction.
   *
   * @returns {number} The time value.
   */
  this.getInitialTime = function () {
    return initialTime;
  };

  /**
   * Get the total number of slices.
   * Can be different from what is stored in the size object
   *  during a volume with time points creation process.
   *
   * @returns {number} The total count.
   */
  this.getCurrentTotalNumberOfSlices = function () {
    var keys = Object.keys(timeOrigins);
    if (keys.length === 0) {
      return origins.length;
    }
    var count = 0;
    for (var i = 0; i < keys.length; ++i) {
      count += timeOrigins[keys[i]].length;
    }
    return count;
  };

  /**
   * Check if a time point has associated slices.
   *
   * @param {number} time The time point to check.
   * @returns {boolean} True if slices are present.
   */
  this.hasSlicesAtTime = function (time) {
    return typeof timeOrigins[time] !== 'undefined';
  };

  /**
   * Get the number of slices stored for time points preceding
   * the input one.
   *
   * @param {number} time The time point to check.
   * @returns {number|undefined} The count.
   */
  this.getCurrentNumberOfSlicesBeforeTime = function (time) {
    var keys = Object.keys(timeOrigins);
    if (keys.length === 0) {
      return undefined;
    }
    var count = 0;
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];
      if (parseInt(key, 10) === time) {
        break;
      }
      count += timeOrigins[key].length;
    }
    return count;
  };

  /**
   * Get the object origin.
   * This should be the lowest origin to ease calculations (?).
   *
   * @returns {dwv.math.Point3D} The object origin.
   */
  this.getOrigin = function () {
    return origins[0];
  };
  /**
   * Get the object origins.
   *
   * @returns {Array} The object origins.
   */
  this.getOrigins = function () {
    return origins;
  };

  /**
   * Check if a point is in the origin list.
   *
   * @param {dwv.math.Point3D} point3D The point to check.
   * @param {number} tol The comparison tolerance
   *   default to Number.EPSILON.
   * @returns {boolean} True if in list.
   */
  this.includesOrigin = function (point3D, tol) {
    for (var i = 0; i < origins.length; ++i) {
      if (origins[i].isSimilar(point3D, tol)) {
        return true;
      }
    }
    return false;
  };

  /**
   * Get the object size.
   * Warning: the size comes as stored in DICOM, meaning that it could
   * be oriented.
   *
   * @param {dwv.math.Matrix33} viewOrientation The view orientation (optional)
   * @returns {dwv.image.Size} The object size.
   */
  this.getSize = function (viewOrientation) {
    var res = size;
    if (viewOrientation && typeof viewOrientation !== 'undefined') {
      var values = dwv.image.getOrientedArray3D(
        [
          size.get(0),
          size.get(1),
          size.get(2)
        ],
        viewOrientation);
      values = values.map(Math.abs);
      res = new dwv.image.Size(values.concat(size.getValues().slice(3)));
    }
    return res;
  };

  /**
   * Calculate slice spacing from origins and replace current
   *   if needed.
   */
  function updateSliceSpacing() {
    var geoSliceSpacing = dwv.image.getSliceGeometrySpacing(
      origins, orientation);
    // update local if needed
    if (typeof geoSliceSpacing !== 'undefined' &&
      spacing.get(2) !== geoSliceSpacing) {
      dwv.logger.trace('Updating slice spacing.');
      var values = spacing.getValues();
      values[2] = geoSliceSpacing;
      spacing = new dwv.image.Spacing(values);
    }
  }

  /**
   * Get the object spacing.
   * Warning: the spacing comes as stored in DICOM, meaning that it could
   * be oriented.
   *
   * @param {dwv.math.Matrix33} viewOrientation The view orientation (optional)
   * @returns {dwv.image.Spacing} The object spacing.
   */
  this.getSpacing = function (viewOrientation) {
    // update slice spacing after appendSlice
    if (newOrigins) {
      updateSliceSpacing();
      newOrigins = false;
    }
    var res = spacing;
    if (viewOrientation && typeof viewOrientation !== 'undefined') {
      var orientedValues = dwv.image.getOrientedArray3D(
        [
          spacing.get(0),
          spacing.get(1),
          spacing.get(2)
        ],
        viewOrientation);
      orientedValues = orientedValues.map(Math.abs);
      res = new dwv.image.Spacing(orientedValues);
    }
    return res;
  };

  /**
   * Get the image spacing in real world.
   *
   * @returns {dwv.image.Spacing} The object spacing.
   */
  this.getRealSpacing = function () {
    // asOneAndZeros to not change spacing values...
    return this.getSpacing(orientation.getInverse().asOneAndZeros());
  };

  /**
   * Get the object orientation.
   *
   * @returns {dwv.math.Matrix33} The object orientation.
   */
  this.getOrientation = function () {
    return orientation;
  };

  /**
   * Get the slice position of a point in the current slice layout.
   * Slice indices increase with decreasing origins (high index -> low origin),
   * this simplified the handling of reconstruction since it means
   * the displayed data is in the same 'direction' as the extracted data.
   * As seen in the getOrigin method, the main origin is the lowest one.
   * This implies that the index to world and reverse method do some flipping
   * magic...
   *
   * @param {dwv.math.Point3D} point The point to evaluate.
   * @param {number} time Optional time index.
   * @returns {number} The slice index.
   */
  this.getSliceIndex = function (point, time) {
    // cannot use this.worldToIndex(point).getK() since
    // we cannot guaranty consecutive slices...

    var localOrigins = origins;
    if (typeof time !== 'undefined') {
      localOrigins = timeOrigins[time];
    }

    // find the closest index
    var closestSliceIndex = 0;
    var minDist = point.getDistance(localOrigins[0]);
    var dist = 0;
    for (var i = 0; i < localOrigins.length; ++i) {
      dist = point.getDistance(localOrigins[i]);
      if (dist < minDist) {
        minDist = dist;
        closestSliceIndex = i;
      }
    }
    var closestOrigin = localOrigins[closestSliceIndex];
    // direction between the input point and the closest origin
    var pointDir = point.minus(closestOrigin);
    // use third orientation matrix column as base plane vector
    var normal = new dwv.math.Vector3D(
      orientation.get(0, 2), orientation.get(1, 2), orientation.get(2, 2));
    // a.dot(b) = ||a|| * ||b|| * cos(theta)
    // (https://en.wikipedia.org/wiki/Dot_product#Geometric_definition)
    // -> the sign of the dot product depends on the cosinus of
    //    the angle between the vectors
    //   -> >0 => vectors are codirectional
    //   -> <0 => vectors are opposite
    var dotProd = normal.dotProduct(pointDir);
    // oposite vectors get higher index
    var sliceIndex = dotProd > 0 ? closestSliceIndex + 1 : closestSliceIndex;
    return sliceIndex;
  };

  /**
   * Append an origin to the geometry.
   *
   * @param {dwv.math.Point3D} origin The origin to append.
   * @param {number} index The index at which to append.
   * @param {number} time Optional time index.
   */
  this.appendOrigin = function (origin, index, time) {
    if (typeof time !== 'undefined') {
      timeOrigins[time].splice(index, 0, origin);
    }
    if (typeof time === 'undefined' || time === initialTime) {
      newOrigins = true;
      // add in origin array
      origins.splice(index, 0, origin);
      // increment second dimension
      var values = size.getValues();
      values[2] += 1;
      size = new dwv.image.Size(values);
    }
  };

  /**
   * Append a frame to the geometry.
   *
   * @param {dwv.math.Point3D} origin The origin to append.
   * @param {number} time Optional time index.
   */
  this.appendFrame = function (origin, time) {
    // add origin to list
    timeOrigins[time] = [origin];
    // increment third dimension
    var sizeValues = size.getValues();
    var spacingValues = spacing.getValues();
    if (sizeValues.length === 4) {
      sizeValues[3] += 1;
    } else {
      sizeValues.push(2);
      spacingValues.push(1);
    }
    size = new dwv.image.Size(sizeValues);
    spacing = new dwv.image.Spacing(spacingValues);
  };

};

/**
 * Get a string representation of the geometry.
 *
 * @returns {string} The geometry as a string.
 */
dwv.image.Geometry.prototype.toString = function () {
  return 'Origin: ' + this.getOrigin() +
    ', Size: ' + this.getSize() +
    ', Spacing: ' + this.getSpacing() +
    ', Orientation: ' + this.getOrientation();
};

/**
 * Check for equality.
 *
 * @param {dwv.image.Geometry} rhs The object to compare to.
 * @returns {boolean} True if both objects are equal.
 */
dwv.image.Geometry.prototype.equals = function (rhs) {
  return rhs !== null &&
    this.getOrigin().equals(rhs.getOrigin()) &&
    this.getSize().equals(rhs.getSize()) &&
    this.getSpacing().equals(rhs.getSpacing());
};

/**
 * Check that a point is within bounds.
 *
 * @param {dwv.math.Point} point The point to check.
 * @returns {boolean} True if the given coordinates are within bounds.
 */
dwv.image.Geometry.prototype.isInBounds = function (point) {
  return this.isIndexInBounds(this.worldToIndex(point));
};

/**
 * Check that a index is within bounds.
 *
 * @param {dwv.math.Index} index The index to check.
 * @param {Array} dirs Optional list of directions to check.
 * @returns {boolean} True if the given coordinates are within bounds.
 */
dwv.image.Geometry.prototype.isIndexInBounds = function (index, dirs) {
  return this.getSize().isInBounds(index, dirs);
};

/**
 * Convert an index into world coordinates.
 *
 * @param {dwv.math.Index} index The index to convert.
 * @returns {dwv.math.Point} The corresponding point.
 */
dwv.image.Geometry.prototype.indexToWorld = function (index) {
  // apply spacing
  // (spacing is oriented, apply before orientation)
  var spacing = this.getSpacing();
  var orientedPoint3D = new dwv.math.Point3D(
    index.get(0) * spacing.get(0),
    index.get(1) * spacing.get(1),
    index.get(2) * spacing.get(2)
  );
  // de-orient
  var point3D = this.getOrientation().multiplyPoint3D(orientedPoint3D);
  // keep >3d values
  var values = index.getValues();
  var origin = this.getOrigin();
  values[0] = origin.getX() + point3D.getX();
  values[1] = origin.getY() + point3D.getY();
  values[2] = origin.getZ() + point3D.getZ();
  // return point
  return new dwv.math.Point(values);
};

/**
 * Convert a 3D point into world coordinates.
 *
 * @param {dwv.math.Point3D} point The 3D point to convert.
 * @returns {dwv.math.Point3D} The corresponding world 3D point.
 */
dwv.image.Geometry.prototype.pointToWorld = function (point) {
  // apply spacing
  // (spacing is oriented, apply before orientation)
  var spacing = this.getSpacing();
  var orientedPoint3D = new dwv.math.Point3D(
    point.getX() * spacing.get(0),
    point.getY() * spacing.get(1),
    point.getZ() * spacing.get(2)
  );
  // de-orient
  var point3D = this.getOrientation().multiplyPoint3D(orientedPoint3D);
  // return point3D
  var origin = this.getOrigin();
  return new dwv.math.Point3D(
    origin.getX() + point3D.getX(),
    origin.getY() + point3D.getY(),
    origin.getZ() + point3D.getZ()
  );
};

/**
 * Convert world coordinates into an index.
 *
 * @param {dwv.math.Point} point The point to convert.
 * @returns {dwv.math.Index} The corresponding index.
 */
dwv.image.Geometry.prototype.worldToIndex = function (point) {
  // compensate for origin
  // (origin is not oriented, compensate before orientation)
  // TODO: use slice origin...
  var origin = this.getOrigin();
  var point3D = new dwv.math.Point3D(
    point.get(0) - origin.getX(),
    point.get(1) - origin.getY(),
    point.get(2) - origin.getZ()
  );
  // orient
  var orientedPoint3D =
    this.getOrientation().getInverse().multiplyPoint3D(point3D);
  // keep >3d values
  var values = point.getValues();
  // apply spacing and round
  var spacing = this.getSpacing();
  values[0] = Math.round(orientedPoint3D.getX() / spacing.get(0));
  values[1] = Math.round(orientedPoint3D.getY() / spacing.get(1));
  values[2] = Math.round(orientedPoint3D.getZ() / spacing.get(2));

  // return index
  return new dwv.math.Index(values);
};

/**
 * Convert world coordinates into an point.
 *
 * @param {dwv.math.Point} point The world point to convert.
 * @returns {dwv.math.Point3D} The corresponding point.
 */
dwv.image.Geometry.prototype.worldToPoint = function (point) {
  // compensate for origin
  // (origin is not oriented, compensate before orientation)
  var origin = this.getOrigin();
  var point3D = new dwv.math.Point3D(
    point.get(0) - origin.getX(),
    point.get(1) - origin.getY(),
    point.get(2) - origin.getZ()
  );
  // orient
  var orientedPoint3D =
    this.getOrientation().getInverse().multiplyPoint3D(point3D);
  // keep >3d values
  var values = point.getValues();
  // apply spacing and round
  var spacing = this.getSpacing();
  values[0] = orientedPoint3D.getX() / spacing.get(0);
  values[1] = orientedPoint3D.getY() / spacing.get(1);
  values[2] = orientedPoint3D.getZ() / spacing.get(2);

  // return index
  return new dwv.math.Point3D(values[0], values[1], values[2]);
};

/**
 * Get the oriented values of an input 3D array.
 *
 * @param {Array} array3D The 3D array.
 * @param {dwv.math.Matrix33} orientation The orientation 3D matrix.
 * @returns {Array} The values reordered according to the orientation.
 */
dwv.image.getOrientedArray3D = function (array3D, orientation) {
  // values = orientation * orientedValues
  // -> inv(orientation) * values = orientedValues
  return orientation.getInverse().multiplyArray3D(array3D);
};

/**
 * Get the raw values of an oriented input 3D array.
 *
 * @param {Array} array3D The 3D array.
 * @param {dwv.math.Matrix33} orientation The orientation 3D matrix.
 * @returns {Array} The values reordered to compensate the orientation.
 */
dwv.image.getDeOrientedArray3D = function (array3D, orientation) {
  // values = orientation * orientedValues
  return orientation.multiplyArray3D(array3D);
};

/**
 * Get the slice spacing from the difference in the Z directions
 * of input origins.
 *
 * @param {Array} origins An array of dwv.math.Point3D.
 * @param {dwv.math.Matrix} orientation The oritentation matrix.
 * @param {boolean} withCheck Flag to activate spacing variation check,
 *   default to true.
 * @returns {number|undefined} The spacing.
 */
dwv.image.getSliceGeometrySpacing = function (origins, orientation, withCheck) {
  if (typeof withCheck === 'undefined') {
    withCheck = true;
  }
  // check origins
  if (origins.length <= 1) {
    return;
  }
  // (x, y, z) = orientationMatrix * (i, j, k)
  // -> inv(orientationMatrix) * (x, y, z) = (i, j, k)
  // applied on the patient position, reorders indices
  // so that Z is the slice direction
  var invOrientation = orientation.getInverse();
  var origin1 = invOrientation.multiplyVector3D(origins[0]);
  var origin2 = invOrientation.multiplyVector3D(origins[1]);
  var sliceSpacing = Math.abs(origin1.getZ() - origin2.getZ());
  var deltas = [];
  for (var i = 0; i < origins.length - 1; ++i) {
    origin1 = invOrientation.multiplyVector3D(origins[i]);
    origin2 = invOrientation.multiplyVector3D(origins[i + 1]);
    var diff = Math.abs(origin1.getZ() - origin2.getZ());
    if (diff === 0) {
      throw new Error('Zero slice spacing.' +
        origin1.toString() + ' ' + origin2.toString());
    }
    // keep smallest
    if (diff < sliceSpacing) {
      sliceSpacing = diff;
    }
    if (withCheck) {
      if (!dwv.math.isSimilar(sliceSpacing, diff, dwv.math.BIG_EPSILON)) {
        deltas.push(Math.abs(sliceSpacing - diff));
      }
    }
  }
  // warn if non constant
  if (withCheck && deltas.length !== 0) {
    var sumReducer = function (sum, value) {
      return sum + value;
    };
    var mean = deltas.reduce(sumReducer) / deltas.length;
    if (mean > 1e-4) {
      dwv.logger.warn('Varying slice spacing, mean delta: ' +
        mean.toFixed(3) + ' (' + deltas.length + ' case(s))');
    }
  }

  return sliceSpacing;
};

// namespaces
var dwv = dwv || {};
/** @namespace */
dwv.image = dwv.image || {};

/**
 * Get the slice index of an input slice into a volume geometry.
 *
 * @param {dwv.image.Geometry} volumeGeometry The volume geometry.
 * @param {dwv.image.Geometry} sliceGeometry The slice geometry.
 * @returns {dwv.math.Index} The index of the slice in the volume geomtry.
 */
dwv.image.getSliceIndex = function (volumeGeometry, sliceGeometry) {
  // possible time
  var timeId = sliceGeometry.getInitialTime();
  // index values
  var values = [];
  // x, y
  values.push(0);
  values.push(0);
  // z
  values.push(volumeGeometry.getSliceIndex(sliceGeometry.getOrigin(), timeId));
  // time
  if (typeof timeId !== 'undefined') {
    values.push(timeId);
  }
  // return index
  return new dwv.math.Index(values);
};

/**
 * Image class.
 * Usable once created, optional are:
 * - rescale slope and intercept (default 1:0),
 * - photometric interpretation (default MONOCHROME2),
 * - planar configuration (default RGBRGB...).
 *
 * @class
 * @param {dwv.image.Geometry} geometry The geometry of the image.
 * @param {Array} buffer The image data as a one dimensional buffer.
 * @param {Array} imageUids An array of Uids indexed to slice number.
 * @example
 * // XMLHttpRequest onload callback
 * var onload = function (event) {
 *   // setup the dicom parser
 *   var dicomParser = new dwv.dicom.DicomParser();
 *   // parse the buffer
 *   dicomParser.parse(event.target.response);
 *   // create the image
 *   var imageFactory = new dwv.image.ImageFactory();
 *   // inputs are dicom tags and buffer
 *   var image = imageFactory.create(
 *     dicomParser.getDicomElements(),
 *     dicomParser.getRawDicomElements().x7FE00010.value[0]
 *   );
 *   // result div
 *   var div = document.getElementById('dwv');
 *   // display the image size
 *   var size = image.getGeometry().getSize();
 *   div.appendChild(document.createTextNode(
 *     'Size: ' + size.toString() +
 *     ' (should be 256,256,1)'));
 *   // break line
 *   div.appendChild(document.createElement('br'));
 *   // display a pixel value
 *   div.appendChild(document.createTextNode(
 *     'Pixel @ [128,40,0]: ' +
 *     image.getRescaledValue(128,40,0) +
 *     ' (should be 101)'));
 * };
 * // DICOM file request
 * var request = new XMLHttpRequest();
 * var url = 'https://raw.githubusercontent.com/ivmartel/dwv/master/tests/data/bbmri-53323851.dcm';
 * request.open('GET', url);
 * request.responseType = 'arraybuffer';
 * request.onload = onload;
 * request.send();
 */
dwv.image.Image = function (geometry, buffer, imageUids) {

  /**
   * Constant rescale slope and intercept (default).
   *
   * @private
   * @type {object}
   */
  var rsi = new dwv.image.RescaleSlopeAndIntercept(1, 0);
  /**
   * Varying rescale slope and intercept.
   *
   * @private
   * @type {Array}
   */
  var rsis = null;
  /**
   * Flag to know if the RSIs are all identity (1,0).
   *
   * @private
   * @type {boolean}
   */
  var isIdentityRSI = true;
  /**
   * Flag to know if the RSIs are all equals.
   *
   * @private
   * @type {boolean}
   */
  var isConstantRSI = true;
  /**
   * Photometric interpretation (MONOCHROME, RGB...).
   *
   * @private
   * @type {string}
   */
  var photometricInterpretation = 'MONOCHROME2';
  /**
   * Planar configuration for RGB data (0:RGBRGBRGBRGB... or
   *   1:RRR...GGG...BBB...).
   *
   * @private
   * @type {number}
   */
  var planarConfiguration = 0;
  /**
   * Number of components.
   *
   * @private
   * @type {number}
   */
  var numberOfComponents = buffer.length / (
    geometry.getSize().getTotalSize());
  /**
   * Meta information.
   *
   * @private
   * @type {object}
   */
  var meta = {};

  /**
   * Data range.
   *
   * @private
   * @type {object}
   */
  var dataRange = null;
  /**
   * Rescaled data range.
   *
   * @private
   * @type {object}
   */
  var rescaledDataRange = null;
  /**
   * Histogram.
   *
   * @private
   * @type {Array}
   */
  var histogram = null;

  /**
   * Listener handler.
   *
   * @private
   * @type {object}
   */
  var listenerHandler = new dwv.utils.ListenerHandler();

  /**
   * Get the image UID at a given index.
   *
   * @param {dwv.math.Index} index The index at which to get the id.
   * @returns {string} The UID.
   */
  this.getImageUid = function (index) {
    var uid = imageUids[0];
    if (imageUids.length !== 1 && typeof index !== 'undefined') {
      uid = imageUids[this.getSecondaryOffset(index)];
    }
    return uid;
  };

  /**
   * Get the geometry of the image.
   *
   * @returns {dwv.image.Geometry} The geometry.
   */
  this.getGeometry = function () {
    return geometry;
  };

  /**
   * Get the data buffer of the image.
   *
   * @todo dangerous...
   * @returns {Array} The data buffer of the image.
   */
  this.getBuffer = function () {
    return buffer;
  };

  /**
   * Can the image values be quantified?
   *
   * @returns {boolean} True if only one component.
   */
  this.canQuantify = function () {
    return this.getNumberOfComponents() === 1;
  };

  /**
   * Can window and level be applied to the data?
   *
   * @returns {boolean} True if the data is monochrome.
   */
  this.canWindowLevel = function () {
    return this.getPhotometricInterpretation()
      .match(/MONOCHROME/) !== null;
  };

  /**
   * Can the data be scrolled?
   *
   * @param {dwv.math.Matrix33} viewOrientation The view orientation.
   * @returns {boolean} True if the data has a third dimension greater than one
   *   after applying the view orientation.
   */
  this.canScroll = function (viewOrientation) {
    var size = this.getGeometry().getSize();
    // also check the numberOfFiles in case we are in the middle of a load
    var nFiles = 1;
    if (typeof meta.numberOfFiles !== 'undefined') {
      nFiles = meta.numberOfFiles;
    }
    return size.canScroll(viewOrientation) || nFiles !== 1;
  };

  /**
   * Get the secondary offset max.
   *
   * @returns {number} The maximum offset.
   */
  function getSecondaryOffsetMax() {
    return geometry.getSize().getTotalSize(2);
  }

  /**
   * Get the secondary offset: an offset that takes into account
   *   the slice and above dimension numbers.
   *
   * @param {dwv.math.Index} index The index.
   * @returns {number} The offset.
   */
  this.getSecondaryOffset = function (index) {
    return geometry.getSize().indexToOffset(index, 2);
  };

  /**
   * Get the rescale slope and intercept.
   *
   * @param {dwv.math.Index} index The index (only needed for non constant rsi).
   * @returns {object} The rescale slope and intercept.
   */
  this.getRescaleSlopeAndIntercept = function (index) {
    var res = rsi;
    if (!this.isConstantRSI()) {
      if (typeof index === 'undefined') {
        throw new Error('Cannot get non constant RSI with empty slice index.');
      }
      var offset = this.getSecondaryOffset(index);
      if (typeof rsis[offset] !== 'undefined') {
        res = rsis[offset];
      } else {
        dwv.logger.warn('undefined non constant rsi at ' + offset);
      }
    }
    return res;
  };

  /**
   * Get the rsi at a specified (secondary) offset.
   *
   * @param {number} offset The desired (secondary) offset.
   * @returns {object} The coresponding rsi.
   */
  function getRescaleSlopeAndInterceptAtOffset(offset) {
    return rsis[offset];
  }

  /**
   * Set the rescale slope and intercept.
   *
   * @param {object} inRsi The input rescale slope and intercept.
   * @param {number} offset The rsi offset (only needed for non constant rsi).
   */
  this.setRescaleSlopeAndIntercept = function (inRsi, offset) {
    // update identity flag
    isIdentityRSI = isIdentityRSI && inRsi.isID();
    // update constant flag
    if (!isConstantRSI) {
      if (typeof index === 'undefined') {
        throw new Error(
          'Cannot store non constant RSI with empty slice index.');
      }
      rsis.splice(offset, 0, inRsi);
    } else {
      if (!rsi.equals(inRsi)) {
        if (typeof index === 'undefined') {
          // no slice index, replace existing
          rsi = inRsi;
        } else {
          // first non constant rsi
          isConstantRSI = false;
          // switch to non constant mode
          rsis = [];
          // initialise RSIs
          for (var i = 0, leni = getSecondaryOffsetMax(); i < leni; ++i) {
            rsis.push(i);
          }
          // store
          rsi = null;
          rsis.splice(offset, 0, inRsi);
        }
      }
    }
  };
  /**
   * Are all the RSIs identity (1,0).
   *
   * @returns {boolean} True if they are.
   */
  this.isIdentityRSI = function () {
    return isIdentityRSI;
  };
  /**
   * Are all the RSIs equal.
   *
   * @returns {boolean} True if they are.
   */
  this.isConstantRSI = function () {
    return isConstantRSI;
  };
  /**
   * Get the photometricInterpretation of the image.
   *
   * @returns {string} The photometricInterpretation of the image.
   */
  this.getPhotometricInterpretation = function () {
    return photometricInterpretation;
  };
  /**
   * Set the photometricInterpretation of the image.
   *
   * @param {string} interp The photometricInterpretation of the image.
   */
  this.setPhotometricInterpretation = function (interp) {
    photometricInterpretation = interp;
  };
  /**
   * Get the planarConfiguration of the image.
   *
   * @returns {number} The planarConfiguration of the image.
   */
  this.getPlanarConfiguration = function () {
    return planarConfiguration;
  };
  /**
   * Set the planarConfiguration of the image.
   *
   * @param {number} config The planarConfiguration of the image.
   */
  this.setPlanarConfiguration = function (config) {
    planarConfiguration = config;
  };
  /**
   * Get the numberOfComponents of the image.
   *
   * @returns {number} The numberOfComponents of the image.
   */
  this.getNumberOfComponents = function () {
    return numberOfComponents;
  };

  /**
   * Get the meta information of the image.
   *
   * @returns {object} The meta information of the image.
   */
  this.getMeta = function () {
    return meta;
  };
  /**
   * Set the meta information of the image.
   *
   * @param {object} rhs The meta information of the image.
   */
  this.setMeta = function (rhs) {
    meta = rhs;
  };

  /**
   * Get value at offset. Warning: No size check...
   *
   * @param {number} offset The desired offset.
   * @returns {number} The value at offset.
   */
  this.getValueAtOffset = function (offset) {
    return buffer[offset];
  };

  /**
   * Get the offsets where the buffer equals the input value.
   * Loops through the whole volume, can get long for big data...
   *
   * @param {number|object} value The value to check.
   * @returns {Array} The list of offsets.
   */
  this.getOffsets = function (value) {
    // value to array
    if (numberOfComponents === 1) {
      value = [value];
    } else if (numberOfComponents === 3 &&
      typeof value.r !== 'undefined') {
      value = [value.r, value.g, value.b];
    }
    // main loop
    var offsets = [];
    var equal;
    for (var i = 0; i < buffer.length; i = i + numberOfComponents) {
      equal = true;
      for (var j = 0; j < numberOfComponents; ++j) {
        if (buffer[i + j] !== value[j]) {
          equal = false;
          break;
        }
      }
      if (equal) {
        offsets.push(i);
      }
    }
    return offsets;
  };

  /**
   * Check if the input values are in the buffer.
   * Could loop through the whole volume, can get long for big data...
   *
   * @param {Array} values The values to check.
   * @returns {Array} A list of booleans for each input value,
   *   set to true if the value is present in the buffer.
   */
  this.hasValues = function (values) {
    // check input
    if (typeof values === 'undefined' ||
      values.length === 0) {
      return [];
    }
    // final array value
    var finalValues = [];
    for (var v1 = 0; v1 < values.length; ++v1) {
      if (numberOfComponents === 1) {
        finalValues.push([values[v1]]);
      } else if (numberOfComponents === 3) {
        finalValues.push([
          values[v1].r,
          values[v1].g,
          values[v1].b
        ]);
      }
    }
    // find callback
    var equalFunc;
    if (numberOfComponents === 1) {
      equalFunc = function (a, b) {
        return a[0] === b[0];
      };
    } else if (numberOfComponents === 3) {
      equalFunc = function (a, b) {
        return a[0] === b[0] &&
          a[1] === b[1] &&
          a[2] === b[2];
      };
    }
    var getEqualCallback = function (value) {
      return function (item) {
        return equalFunc(item, value);
      };
    };
    // main loop
    var res = new Array(values.length);
    res.fill(false);
    var valuesToFind = finalValues.slice();
    var equal;
    var indicesToRemove;
    for (var i = 0, leni = buffer.length;
      i < leni; i = i + numberOfComponents) {
      indicesToRemove = [];
      for (var v = 0; v < valuesToFind.length; ++v) {
        equal = true;
        // check value(s)
        for (var j = 0; j < numberOfComponents; ++j) {
          if (buffer[i + j] !== valuesToFind[v][j]) {
            equal = false;
            break;
          }
        }
        // if found, store answer and add to indices to remove
        if (equal) {
          var valIndex = finalValues.findIndex(
            getEqualCallback(valuesToFind[v]));
          res[valIndex] = true;
          indicesToRemove.push(v);
        }
      }
      // remove found values
      for (var r = 0; r < indicesToRemove.length; ++r) {
        valuesToFind.splice(indicesToRemove[r], 1);
      }
      // exit if no values to find
      if (valuesToFind.length === 0) {
        break;
      }
    }
    // return
    return res;
  };

  /**
   * Clone the image.
   *
   * @returns {Image} A clone of this image.
   */
  this.clone = function () {
    // clone the image buffer
    var clonedBuffer = buffer.slice(0);
    // create the image copy
    var copy = new dwv.image.Image(this.getGeometry(), clonedBuffer, imageUids);
    // copy the RSI(s)
    if (this.isConstantRSI()) {
      copy.setRescaleSlopeAndIntercept(this.getRescaleSlopeAndIntercept());
    } else {
      for (var i = 0; i < getSecondaryOffsetMax(); ++i) {
        copy.setRescaleSlopeAndIntercept(
          getRescaleSlopeAndInterceptAtOffset(i), i);
      }
    }
    // copy extras
    copy.setPhotometricInterpretation(this.getPhotometricInterpretation());
    copy.setPlanarConfiguration(this.getPlanarConfiguration());
    copy.setMeta(this.getMeta());
    // return
    return copy;
  };

  /**
   * Re-allocate buffer memory to an input size.
   *
   * @param {number} size The new size.
   */
  function realloc(size) {
    // save buffer
    var tmpBuffer = buffer;
    // create new
    buffer = dwv.dicom.getTypedArray(
      buffer.BYTES_PER_ELEMENT * 8,
      meta.IsSigned ? 1 : 0,
      size);
    if (buffer === null) {
      throw new Error('Cannot reallocate data for image.');
    }
    // put old in new
    buffer.set(tmpBuffer);
    // clean
    tmpBuffer = null;
  }

  /**
   * Append a slice to the image.
   *
   * @param {Image} rhs The slice to append.
   */
  this.appendSlice = function (rhs) {
    // check input
    if (rhs === null) {
      throw new Error('Cannot append null slice');
    }
    var rhsSize = rhs.getGeometry().getSize();
    var size = geometry.getSize();
    if (rhsSize.get(2) !== 1) {
      throw new Error('Cannot append more than one slice');
    }
    if (size.get(0) !== rhsSize.get(0)) {
      throw new Error('Cannot append a slice with different number of columns');
    }
    if (size.get(1) !== rhsSize.get(1)) {
      throw new Error('Cannot append a slice with different number of rows');
    }
    if (!geometry.getOrientation().equals(
      rhs.getGeometry().getOrientation(), 0.0001)) {
      throw new Error('Cannot append a slice with different orientation');
    }
    if (photometricInterpretation !== rhs.getPhotometricInterpretation()) {
      throw new Error(
        'Cannot append a slice with different photometric interpretation');
    }
    // all meta should be equal
    for (var key in meta) {
      if (key === 'windowPresets' || key === 'numberOfFiles' ||
        key === 'custom') {
        continue;
      }
      if (meta[key] !== rhs.getMeta()[key]) {
        throw new Error('Cannot append a slice with different ' + key);
      }
    }

    // possible time
    var timeId = rhs.getGeometry().getInitialTime();

    // append frame if needed
    var isNewFrame = false;
    if (typeof timeId !== 'undefined' && !geometry.hasSlicesAtTime(timeId)) {
      // update grometry
      this.appendFrame(rhs.getGeometry().getOrigin(), timeId);
      // update size
      size = geometry.getSize();
      // update flag
      isNewFrame = true;
    }

    // get slice index
    var index = dwv.image.getSliceIndex(geometry, rhs.getGeometry());

    // calculate slice size
    var sliceSize = numberOfComponents * size.getDimSize(2);

    // create full buffer if not done yet
    if (typeof meta.numberOfFiles === 'undefined') {
      throw new Error('Missing number of files for buffer manipulation.');
    }
    var fullBufferSize = sliceSize * meta.numberOfFiles;
    if (buffer.length !== fullBufferSize) {
      realloc(fullBufferSize);
    }

    // slice index
    var sliceIndex = index.get(2);

    // slice index including possible 4D
    var fullSliceIndex = sliceIndex;
    if (typeof timeId !== 'undefined') {
      fullSliceIndex += geometry.getCurrentNumberOfSlicesBeforeTime(timeId);
    }
    // offset of the input slice
    var indexOffset = fullSliceIndex * sliceSize;
    var maxOffset = geometry.getCurrentTotalNumberOfSlices() * sliceSize;
    // move content if needed
    if (indexOffset < maxOffset) {
      buffer.set(
        buffer.subarray(indexOffset, maxOffset),
        indexOffset + sliceSize
      );
    }
    // add new slice content
    buffer.set(rhs.getBuffer(), indexOffset);

    // update geometry
    if (!isNewFrame) {
      geometry.appendOrigin(
        rhs.getGeometry().getOrigin(), sliceIndex, timeId);
    }
    // update rsi
    // (rhs should just have one rsi)
    this.setRescaleSlopeAndIntercept(
      rhs.getRescaleSlopeAndIntercept(), fullSliceIndex);

    // current number of images
    var numberOfImages = imageUids.length;

    // insert sop instance UIDs
    imageUids.splice(fullSliceIndex, 0, rhs.getImageUid());

    // update window presets
    if (typeof meta.windowPresets !== 'undefined') {
      var windowPresets = meta.windowPresets;
      var rhsPresets = rhs.getMeta().windowPresets;
      var keys = Object.keys(rhsPresets);
      var pkey = null;
      for (var i = 0; i < keys.length; ++i) {
        pkey = keys[i];
        var rhsPreset = rhsPresets[pkey];
        var windowPreset = windowPresets[pkey];
        if (typeof windowPreset !== 'undefined') {
          // if not set or false, check perslice
          if (typeof windowPreset.perslice === 'undefined' ||
            windowPreset.perslice === false) {
            // if different preset.wl, mark it as perslice
            if (!windowPreset.wl[0].equals(rhsPreset.wl[0])) {
              windowPreset.perslice = true;
              // fill wl array with copy of wl[0]
              // (loop on number of images minus the existing one)
              for (var j = 0; j < numberOfImages - 1; ++j) {
                windowPreset.wl.push(windowPreset.wl[0]);
              }
            }
          }
          // store (first) rhs preset.wl if needed
          if (typeof windowPreset.perslice !== 'undefined' &&
            windowPreset.perslice === true) {
            windowPresets[pkey].wl.splice(
              fullSliceIndex, 0, rhsPreset.wl[0]);
          }
        } else {
          // if not defined (it should be), store all
          windowPresets[pkey] = rhsPresets[pkey];
        }
      }
    }
  };

  /**
   * Append a frame buffer to the image.
   *
   * @param {object} frameBuffer The frame buffer to append.
   * @param {number} frameIndex The frame index.
   */
  this.appendFrameBuffer = function (frameBuffer, frameIndex) {
    // create full buffer if not done yet
    var size = geometry.getSize();
    var frameSize = numberOfComponents * size.getDimSize(2);
    if (typeof meta.numberOfFiles === 'undefined') {
      throw new Error('Missing number of files for frame buffer manipulation.');
    }
    var fullBufferSize = frameSize * meta.numberOfFiles;
    if (buffer.length !== fullBufferSize) {
      realloc(fullBufferSize);
    }
    // append
    if (frameIndex >= meta.numberOfFiles) {
      throw new Error(
        'Cannot append a frame at an index above the number of frames');
    }
    buffer.set(frameBuffer, frameSize * frameIndex);
    // update geometry
    this.appendFrame();
  };

  /**
   * Append a frame to the image.
   *
   * @param {number} time The frame time value.
   * @param {dwv.math.Point3D} origin The origin of the frame.
   */
  this.appendFrame = function (time, origin) {
    geometry.appendFrame(time, origin);
    fireEvent({type: 'appendframe'});
    // memory will be updated at the first appendSlice or appendFrameBuffer
  };

  /**
   * Get the data range.
   *
   * @returns {object} The data range.
   */
  this.getDataRange = function () {
    if (!dataRange) {
      dataRange = this.calculateDataRange();
    }
    return dataRange;
  };

  /**
   * Get the rescaled data range.
   *
   * @returns {object} The rescaled data range.
   */
  this.getRescaledDataRange = function () {
    if (!rescaledDataRange) {
      rescaledDataRange = this.calculateRescaledDataRange();
    }
    return rescaledDataRange;
  };

  /**
   * Get the histogram.
   *
   * @returns {Array} The histogram.
   */
  this.getHistogram = function () {
    if (!histogram) {
      var res = this.calculateHistogram();
      dataRange = res.dataRange;
      rescaledDataRange = res.rescaledDataRange;
      histogram = res.histogram;
    }
    return histogram;
  };

  /**
   * Add an event listener to this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type, will be called with the fired event.
   */
  this.addEventListener = function (type, callback) {
    listenerHandler.add(type, callback);
  };

  /**
   * Remove an event listener from this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type.
   */
  this.removeEventListener = function (type, callback) {
    listenerHandler.remove(type, callback);
  };

  /**
   * Fire an event: call all associated listeners with the input event object.
   *
   * @param {object} event The event to fire.
   * @private
   */
  function fireEvent(event) {
    listenerHandler.fireEvent(event);
  }

  // ****************************************
  // image data modifiers... carefull...
  // ****************************************

  /**
   * Set the inner buffer values at given offsets.
   *
   * @param {Array} offsets List of offsets where to set the data.
   * @param {object} value The value to set at the given offsets.
   * @fires dwv.image.Image#imagechange
   */
  this.setAtOffsets = function (offsets, value) {
    var offset;
    for (var i = 0, leni = offsets.length; i < leni; ++i) {
      offset = offsets[i];
      buffer[offset] = value.r;
      buffer[offset + 1] = value.g;
      buffer[offset + 2] = value.b;
    }
    // fire imagechange
    fireEvent({type: 'imagechange'});
  };

  /**
   * Set the inner buffer values at given offsets.
   *
   * @param {Array} offsetsLists List of offset lists where to set the data.
   * @param {object} value The value to set at the given offsets.
   * @returns {Array} A list of objects representing the original values before
   *  replacing them.
   * @fires dwv.image.Image#imagechange
   */
  this.setAtOffsetsAndGetOriginals = function (offsetsLists, value) {
    var originalColoursLists = [];

    // update and store
    for (var j = 0; j < offsetsLists.length; ++j) {
      var offsets = offsetsLists[j];
      // first colour
      var offset = offsets[0] * 3;
      var previousColour = {
        r: buffer[offset],
        g: buffer[offset + 1],
        b: buffer[offset + 2]
      };
      // original value storage
      var originalColours = [];
      originalColours.push({
        index: 0,
        colour: previousColour
      });
      for (var i = 0; i < offsets.length; ++i) {
        offset = offsets[i] * 3;
        var currentColour = {
          r: buffer[offset],
          g: buffer[offset + 1],
          b: buffer[offset + 2]
        };
        // check if new colour
        if (previousColour.r !== currentColour.r ||
          previousColour.g !== currentColour.g ||
          previousColour.b !== currentColour.b) {
          // store new colour
          originalColours.push({
            index: i,
            colour: currentColour
          });
          previousColour = currentColour;
        }
        // write update colour
        buffer[offset] = value.r;
        buffer[offset + 1] = value.g;
        buffer[offset + 2] = value.b;
      }
      originalColoursLists.push(originalColours);
    }
    // fire imagechange
    fireEvent({type: 'imagechange'});
    return originalColoursLists;
  };

  /**
   * Set the inner buffer values at given offsets.
   *
   * @param {Array} offsetsLists List of offset lists where to set the data.
   * @param {object|Array} value The value to set at the given offsets.
   * @fires dwv.image.Image#imagechange
   */
  this.setAtOffsetsWithIterator = function (offsetsLists, value) {
    for (var j = 0; j < offsetsLists.length; ++j) {
      var offsets = offsetsLists[j];
      var iterator;
      if (typeof value !== 'undefined' &&
        typeof value.r !== 'undefined') {
        // input value is a simple color
        iterator = new dwv.image.colourRange(
          [{index: 0, colour: value}], offsets.length);
      } else {
        // input value is a list of iterators
        // created by setAtOffsetsAndGetOriginals
        iterator = new dwv.image.colourRange(
          value[j], offsets.length);
      }

      // set values
      var ival = iterator.next();
      while (!ival.done) {
        var offset = offsets[ival.index] * 3;
        buffer[offset] = ival.value.r;
        buffer[offset + 1] = ival.value.g;
        buffer[offset + 2] = ival.value.b;
        ival = iterator.next();
      }
    }
    /**
     * Image change event.
     *
     * @event dwv.image.Image#imagechange
     * @type {object}
     */
    fireEvent({type: 'imagechange'});
  };
};

/**
 * Get the value of the image at a specific coordinate.
 *
 * @param {number} i The X index.
 * @param {number} j The Y index.
 * @param {number} k The Z index.
 * @param {number} f The frame number.
 * @returns {number} The value at the desired position.
 * Warning: No size check...
 */
dwv.image.Image.prototype.getValue = function (i, j, k, f) {
  var frame = (f || 0);
  var index = new dwv.math.Index([i, j, k, frame]);
  return this.getValueAtOffset(
    this.getGeometry().getSize().indexToOffset(index));
};

/**
 * Get the value of the image at a specific index.
 *
 * @param {dwv.math.Index} index The index.
 * @returns {number} The value at the desired position.
 * Warning: No size check...
 */
dwv.image.Image.prototype.getValueAtIndex = function (index) {
  return this.getValueAtOffset(
    this.getGeometry().getSize().indexToOffset(index));
};

/**
 * Get the rescaled value of the image at a specific position.
 *
 * @param {number} i The X index.
 * @param {number} j The Y index.
 * @param {number} k The Z index.
 * @param {number} f The frame number.
 * @returns {number} The rescaled value at the desired position.
 * Warning: No size check...
 */
dwv.image.Image.prototype.getRescaledValue = function (i, j, k, f) {
  if (typeof f === 'undefined') {
    f = 0;
  }
  var val = this.getValue(i, j, k, f);
  if (!this.isIdentityRSI()) {
    if (this.isConstantRSI()) {
      val = this.getRescaleSlopeAndIntercept().apply(val);
    } else {
      var values = [i, j, k, f];
      var index = new dwv.math.Index(values);
      val = this.getRescaleSlopeAndIntercept(index).apply(val);
    }
  }
  return val;
};

/**
 * Get the rescaled value of the image at a specific index.
 *
 * @param {dwv.math.Index} index The index.
 * @returns {number} The rescaled value at the desired position.
 * Warning: No size check...
 */
dwv.image.Image.prototype.getRescaledValueAtIndex = function (index) {
  return this.getRescaledValueAtOffset(
    this.getGeometry().getSize().indexToOffset(index)
  );
};

/**
 * Get the rescaled value of the image at a specific offset.
 *
 * @param {number} offset The desired offset.
 * @returns {number} The rescaled value at the desired offset.
 * Warning: No size check...
 */
dwv.image.Image.prototype.getRescaledValueAtOffset = function (offset) {
  var val = this.getValueAtOffset(offset);
  if (!this.isIdentityRSI()) {
    if (this.isConstantRSI()) {
      val = this.getRescaleSlopeAndIntercept().apply(val);
    } else {
      var index = this.getGeometry().getSize().offsetToIndex(offset);
      val = this.getRescaleSlopeAndIntercept(index).apply(val);
    }
  }
  return val;
};

/**
 * Calculate the data range of the image.
 * WARNING: for speed reasons, only calculated on the first frame...
 *
 * @returns {object} The range {min, max}.
 */
dwv.image.Image.prototype.calculateDataRange = function () {
  var min = this.getValueAtOffset(0);
  var max = min;
  var value = 0;
  var size = this.getGeometry().getSize();
  var leni = size.getTotalSize();
  // max to 3D
  if (size.length() >= 3) {
    leni = size.getDimSize(3);
  }
  for (var i = 0; i < leni; ++i) {
    value = this.getValueAtOffset(i);
    if (value > max) {
      max = value;
    }
    if (value < min) {
      min = value;
    }
  }
  // return
  return {min: min, max: max};
};

/**
 * Calculate the rescaled data range of the image.
 * WARNING: for speed reasons, only calculated on the first frame...
 *
 * @returns {object} The range {min, max}.
 */
dwv.image.Image.prototype.calculateRescaledDataRange = function () {
  if (this.isIdentityRSI()) {
    return this.getDataRange();
  } else if (this.isConstantRSI()) {
    var range = this.getDataRange();
    var resmin = this.getRescaleSlopeAndIntercept().apply(range.min);
    var resmax = this.getRescaleSlopeAndIntercept().apply(range.max);
    return {
      min: ((resmin < resmax) ? resmin : resmax),
      max: ((resmin > resmax) ? resmin : resmax)
    };
  } else {
    var rmin = this.getRescaledValueAtOffset(0);
    var rmax = rmin;
    var rvalue = 0;
    var size = this.getGeometry().getSize();
    var leni = size.getTotalSize();
    // max to 3D
    if (size.length() === 3) {
      leni = size.getDimSize(3);
    }
    for (var i = 0; i < leni; ++i) {
      rvalue = this.getRescaledValueAtOffset(i);
      if (rvalue > rmax) {
        rmax = rvalue;
      }
      if (rvalue < rmin) {
        rmin = rvalue;
      }
    }
    // return
    return {min: rmin, max: rmax};
  }
};

/**
 * Calculate the histogram of the image.
 *
 * @returns {object} The histogram, data range and rescaled data range.
 */
dwv.image.Image.prototype.calculateHistogram = function () {
  var size = this.getGeometry().getSize();
  var histo = [];
  var min = this.getValueAtOffset(0);
  var max = min;
  var value = 0;
  var rmin = this.getRescaledValueAtOffset(0);
  var rmax = rmin;
  var rvalue = 0;
  for (var i = 0, leni = size.getTotalSize(); i < leni; ++i) {
    value = this.getValueAtOffset(i);
    if (value > max) {
      max = value;
    }
    if (value < min) {
      min = value;
    }
    rvalue = this.getRescaledValueAtOffset(i);
    if (rvalue > rmax) {
      rmax = rvalue;
    }
    if (rvalue < rmin) {
      rmin = rvalue;
    }
    histo[rvalue] = (histo[rvalue] || 0) + 1;
  }
  // set data range
  var dataRange = {min: min, max: max};
  var rescaledDataRange = {min: rmin, max: rmax};
  // generate data for plotting
  var histogram = [];
  for (var b = rmin; b <= rmax; ++b) {
    histogram.push([b, (histo[b] || 0)]);
  }
  // return
  return {
    dataRange: dataRange,
    rescaledDataRange: rescaledDataRange,
    histogram: histogram
  };
};

/**
 * Convolute the image with a given 2D kernel.
 *
 * Note: Uses raw buffer values.
 *
 * @param {Array} weights The weights of the 2D kernel as a 3x3 matrix.
 * @returns {Image} The convoluted image.
 */
dwv.image.Image.prototype.convolute2D = function (weights) {
  if (weights.length !== 9) {
    throw new Error(
      'The convolution matrix does not have a length of 9; it has ' +
      weights.length);
  }

  var newImage = this.clone();
  var newBuffer = newImage.getBuffer();

  var imgSize = this.getGeometry().getSize();
  var dimOffset = imgSize.getDimSize(2) * this.getNumberOfComponents();
  for (var k = 0; k < imgSize.get(2); ++k) {
    this.convoluteBuffer(weights, newBuffer, k * dimOffset);
  }

  return newImage;
};

/**
 * Convolute an image buffer with a given 2D kernel.
 *
 * Note: Uses raw buffer values.
 *
 * @param {Array} weights The weights of the 2D kernel as a 3x3 matrix.
 * @param {Array} buffer The buffer to convolute.
 * @param {number} startOffset The index to start at.
 */
dwv.image.Image.prototype.convoluteBuffer = function (
  weights, buffer, startOffset) {
  var imgSize = this.getGeometry().getSize();
  var ncols = imgSize.get(0);
  var nrows = imgSize.get(1);
  var ncomp = this.getNumberOfComponents();

  // number of component and planar configuration vars
  var factor = 1;
  var componentOffset = 1;
  if (ncomp === 3) {
    if (this.getPlanarConfiguration() === 0) {
      factor = 3;
    } else {
      componentOffset = imgSize.getDimSize(2);
    }
  }

  // allow special indent for matrices
  /*jshint indent:false */

  // default weight offset matrix
  var wOff = [];
  wOff[0] = (-ncols - 1) * factor;
  wOff[1] = (-ncols) * factor;
  wOff[2] = (-ncols + 1) * factor;
  wOff[3] = -factor;
  wOff[4] = 0;
  wOff[5] = 1 * factor;
  wOff[6] = (ncols - 1) * factor;
  wOff[7] = (ncols) * factor;
  wOff[8] = (ncols + 1) * factor;

  // border weight offset matrices
  // borders are extended (see http://en.wikipedia.org/wiki/Kernel_%28image_processing%29)

  // i=0, j=0
  var wOff00 = [];
  wOff00[0] = wOff[4]; wOff00[1] = wOff[4]; wOff00[2] = wOff[5];
  wOff00[3] = wOff[4]; wOff00[4] = wOff[4]; wOff00[5] = wOff[5];
  wOff00[6] = wOff[7]; wOff00[7] = wOff[7]; wOff00[8] = wOff[8];
  // i=0, j=*
  var wOff0x = [];
  wOff0x[0] = wOff[1]; wOff0x[1] = wOff[1]; wOff0x[2] = wOff[2];
  wOff0x[3] = wOff[4]; wOff0x[4] = wOff[4]; wOff0x[5] = wOff[5];
  wOff0x[6] = wOff[7]; wOff0x[7] = wOff[7]; wOff0x[8] = wOff[8];
  // i=0, j=nrows
  var wOff0n = [];
  wOff0n[0] = wOff[1]; wOff0n[1] = wOff[1]; wOff0n[2] = wOff[2];
  wOff0n[3] = wOff[4]; wOff0n[4] = wOff[4]; wOff0n[5] = wOff[5];
  wOff0n[6] = wOff[4]; wOff0n[7] = wOff[4]; wOff0n[8] = wOff[5];

  // i=*, j=0
  var wOffx0 = [];
  wOffx0[0] = wOff[3]; wOffx0[1] = wOff[4]; wOffx0[2] = wOff[5];
  wOffx0[3] = wOff[3]; wOffx0[4] = wOff[4]; wOffx0[5] = wOff[5];
  wOffx0[6] = wOff[6]; wOffx0[7] = wOff[7]; wOffx0[8] = wOff[8];
  // i=*, j=* -> wOff
  // i=*, j=nrows
  var wOffxn = [];
  wOffxn[0] = wOff[0]; wOffxn[1] = wOff[1]; wOffxn[2] = wOff[2];
  wOffxn[3] = wOff[3]; wOffxn[4] = wOff[4]; wOffxn[5] = wOff[5];
  wOffxn[6] = wOff[3]; wOffxn[7] = wOff[4]; wOffxn[8] = wOff[5];

  // i=ncols, j=0
  var wOffn0 = [];
  wOffn0[0] = wOff[3]; wOffn0[1] = wOff[4]; wOffn0[2] = wOff[4];
  wOffn0[3] = wOff[3]; wOffn0[4] = wOff[4]; wOffn0[5] = wOff[4];
  wOffn0[6] = wOff[6]; wOffn0[7] = wOff[7]; wOffn0[8] = wOff[7];
  // i=ncols, j=*
  var wOffnx = [];
  wOffnx[0] = wOff[0]; wOffnx[1] = wOff[1]; wOffnx[2] = wOff[1];
  wOffnx[3] = wOff[3]; wOffnx[4] = wOff[4]; wOffnx[5] = wOff[4];
  wOffnx[6] = wOff[6]; wOffnx[7] = wOff[7]; wOffnx[8] = wOff[7];
  // i=ncols, j=nrows
  var wOffnn = [];
  wOffnn[0] = wOff[0]; wOffnn[1] = wOff[1]; wOffnn[2] = wOff[1];
  wOffnn[3] = wOff[3]; wOffnn[4] = wOff[4]; wOffnn[5] = wOff[4];
  wOffnn[6] = wOff[3]; wOffnn[7] = wOff[4]; wOffnn[8] = wOff[4];

  // restore indent for rest of method
  /*jshint indent:4 */

  // loop vars
  var pixelOffset = startOffset;
  var newValue = 0;
  var wOffFinal = [];
  for (var c = 0; c < ncomp; ++c) {
    // component offset
    pixelOffset += c * componentOffset;
    for (var j = 0; j < nrows; ++j) {
      for (var i = 0; i < ncols; ++i) {
        wOffFinal = wOff;
        // special border cases
        if (i === 0 && j === 0) {
          wOffFinal = wOff00;
        } else if (i === 0 && j === (nrows - 1)) {
          wOffFinal = wOff0n;
        } else if (i === (ncols - 1) && j === 0) {
          wOffFinal = wOffn0;
        } else if (i === (ncols - 1) && j === (nrows - 1)) {
          wOffFinal = wOffnn;
        } else if (i === 0 && j !== (nrows - 1) && j !== 0) {
          wOffFinal = wOff0x;
        } else if (i === (ncols - 1) && j !== (nrows - 1) && j !== 0) {
          wOffFinal = wOffnx;
        } else if (i !== 0 && i !== (ncols - 1) && j === 0) {
          wOffFinal = wOffx0;
        } else if (i !== 0 && i !== (ncols - 1) && j === (nrows - 1)) {
          wOffFinal = wOffxn;
        }
        // calculate the weighed sum of the source image pixels that
        // fall under the convolution matrix
        newValue = 0;
        for (var wi = 0; wi < 9; ++wi) {
          newValue += this.getValueAtOffset(
            pixelOffset + wOffFinal[wi]) * weights[wi];
        }
        buffer[pixelOffset] = newValue;
        // increment pixel offset
        pixelOffset += factor;
      }
    }
  }
};

/**
 * Transform an image using a specific operator.
 * WARNING: no size check!
 *
 * @param {Function} operator The operator to use when transforming.
 * @returns {Image} The transformed image.
 * Note: Uses the raw buffer values.
 */
dwv.image.Image.prototype.transform = function (operator) {
  var newImage = this.clone();
  var newBuffer = newImage.getBuffer();
  for (var i = 0, leni = newBuffer.length; i < leni; ++i) {
    newBuffer[i] = operator(newImage.getValueAtOffset(i));
  }
  return newImage;
};

/**
 * Compose this image with another one and using a specific operator.
 * WARNING: no size check!
 *
 * @param {Image} rhs The image to compose with.
 * @param {Function} operator The operator to use when composing.
 * @returns {Image} The composed image.
 * Note: Uses the raw buffer values.
 */
dwv.image.Image.prototype.compose = function (rhs, operator) {
  var newImage = this.clone();
  var newBuffer = newImage.getBuffer();
  for (var i = 0, leni = newBuffer.length; i < leni; ++i) {
    // using the operator on the local buffer, i.e. the
    // latest (not original) data
    newBuffer[i] = Math.floor(
      operator(this.getValueAtOffset(i), rhs.getValueAtOffset(i))
    );
  }
  return newImage;
};

// namespaces
var dwv = dwv || {};
dwv.image = dwv.image || {};

/**
 * {@link dwv.image.Image} factory.
 *
 * @class
 */
dwv.image.ImageFactory = function () {};

/**
 * {@link dwv.image.Image} factory. Defaults to local one.
 *
 * @see dwv.image.ImageFactory
 */
dwv.ImageFactory = dwv.image.ImageFactory;

/**
 * Check dicom elements. Throws an error if not suitable.
 *
 * @param {object} dicomElements The DICOM tags.
 */
dwv.image.ImageFactory.prototype.checkElements = function (dicomElements) {
  // columns
  var columns = dicomElements.getFromKey('x00280011');
  if (!columns) {
    throw new Error('Missing or empty DICOM image number of columns');
  }
  // rows
  var rows = dicomElements.getFromKey('x00280010');
  if (!rows) {
    throw new Error('Missing or empty DICOM image number of rows');
  }
};

/**
 * Get an {@link dwv.image.Image} object from the read DICOM file.
 *
 * @param {object} dicomElements The DICOM tags.
 * @param {Array} pixelBuffer The pixel buffer.
 * @param {number} numberOfFiles The input number of files.
 * @returns {dwv.image.Image} A new Image.
 */
dwv.image.ImageFactory.prototype.create = function (
  dicomElements, pixelBuffer, numberOfFiles) {
  // columns
  var columns = dicomElements.getFromKey('x00280011');
  if (!columns) {
    throw new Error('Missing or empty DICOM image number of columns');
  }
  // rows
  var rows = dicomElements.getFromKey('x00280010');
  if (!rows) {
    throw new Error('Missing or empty DICOM image number of rows');
  }

  var sizeValues = [columns, rows, 1];

  // frames
  var frames = dicomElements.getFromKey('x00280008');
  if (frames) {
    sizeValues.push(frames);
  }

  // image size
  var size = new dwv.image.Size(sizeValues);

  // image spacing
  var spacing = dicomElements.getPixelSpacing();

  // TransferSyntaxUID
  var transferSyntaxUID = dicomElements.getFromKey('x00020010');
  var syntax = dwv.dicom.cleanString(transferSyntaxUID);
  var jpeg2000 = dwv.dicom.isJpeg2000TransferSyntax(syntax);
  var jpegBase = dwv.dicom.isJpegBaselineTransferSyntax(syntax);
  var jpegLoss = dwv.dicom.isJpegLosslessTransferSyntax(syntax);

  // ImagePositionPatient
  var imagePositionPatient = dicomElements.getFromKey('x00200032');
  // slice position
  var slicePosition = new Array(0, 0, 0);
  if (imagePositionPatient) {
    slicePosition = [parseFloat(imagePositionPatient[0]),
      parseFloat(imagePositionPatient[1]),
      parseFloat(imagePositionPatient[2])];
  }

  // slice orientation (cosines are matrices' columns)
  // http://dicom.nema.org/medical/dicom/current/output/chtml/part03/sect_C.7.6.2.html#sect_C.7.6.2.1.1
  var imageOrientationPatient = dicomElements.getFromKey('x00200037');
  var orientationMatrix;
  if (imageOrientationPatient) {
    var rowCosines = new dwv.math.Vector3D(
      parseFloat(imageOrientationPatient[0]),
      parseFloat(imageOrientationPatient[1]),
      parseFloat(imageOrientationPatient[2]));
    var colCosines = new dwv.math.Vector3D(
      parseFloat(imageOrientationPatient[3]),
      parseFloat(imageOrientationPatient[4]),
      parseFloat(imageOrientationPatient[5]));
    var normal = rowCosines.crossProduct(colCosines);
    /* eslint-disable array-element-newline */
    orientationMatrix = new dwv.math.Matrix33([
      rowCosines.getX(), colCosines.getX(), normal.getX(),
      rowCosines.getY(), colCosines.getY(), normal.getY(),
      rowCosines.getZ(), colCosines.getZ(), normal.getZ()
    ]);
    /* eslint-enable array-element-newline */
  }

  // geometry
  var origin = new dwv.math.Point3D(
    slicePosition[0], slicePosition[1], slicePosition[2]);
  var time = dicomElements.getTime();
  var geometry = new dwv.image.Geometry(
    origin, size, spacing, orientationMatrix, time);

  // sop instance UID
  var sopInstanceUid = dwv.dicom.cleanString(
    dicomElements.getFromKey('x00080018'));

  // Sample per pixels
  var samplesPerPixel = dicomElements.getFromKey('x00280002');
  if (!samplesPerPixel) {
    samplesPerPixel = 1;
  }

  // check buffer size
  var bufferSize = size.getTotalSize() * samplesPerPixel;
  if (bufferSize !== pixelBuffer.length) {
    dwv.logger.warn('Badly sized pixel buffer: ' +
      pixelBuffer.length + ' != ' + bufferSize);
    if (bufferSize < pixelBuffer.length) {
      pixelBuffer = pixelBuffer.slice(0, size.getTotalSize());
    } else {
      throw new Error('Underestimated buffer size, can\'t fix it...');
    }
  }

  // image
  var image = new dwv.image.Image(geometry, pixelBuffer, [sopInstanceUid]);
  // PhotometricInterpretation
  var photometricInterpretation = dicomElements.getFromKey('x00280004');
  if (photometricInterpretation) {
    var photo = dwv.dicom.cleanString(photometricInterpretation).toUpperCase();
    // jpeg decoders output RGB data
    if ((jpeg2000 || jpegBase || jpegLoss) &&
      (photo !== 'MONOCHROME1' && photo !== 'MONOCHROME2')) {
      photo = 'RGB';
    }
    // check samples per pixels
    if (photo === 'RGB' && samplesPerPixel === 1) {
      photo = 'PALETTE COLOR';
    }
    image.setPhotometricInterpretation(photo);
  }
  // PlanarConfiguration
  var planarConfiguration = dicomElements.getFromKey('x00280006');
  if (planarConfiguration) {
    image.setPlanarConfiguration(planarConfiguration);
  }

  // rescale slope and intercept
  var slope = 1;
  // RescaleSlope
  var rescaleSlope = dicomElements.getFromKey('x00281053');
  if (rescaleSlope) {
    slope = parseFloat(rescaleSlope);
  }
  var intercept = 0;
  // RescaleIntercept
  var rescaleIntercept = dicomElements.getFromKey('x00281052');
  if (rescaleIntercept) {
    intercept = parseFloat(rescaleIntercept);
  }
  var rsi = new dwv.image.RescaleSlopeAndIntercept(slope, intercept);
  image.setRescaleSlopeAndIntercept(rsi);

  // meta information
  var meta = {
    numberOfFiles: numberOfFiles,
    Modality: dicomElements.getFromKey('x00080060'),
    SOPClassUID: dicomElements.getFromKey('x00080016'),
    StudyInstanceUID: dicomElements.getFromKey('x0020000D'),
    SeriesInstanceUID: dicomElements.getFromKey('x0020000E'),
    BitsStored: dicomElements.getFromKey('x00280101'),
    PixelRepresentation: dicomElements.getFromKey('x00280103')
  };
  // PixelRepresentation -> is signed
  meta.IsSigned = meta.PixelRepresentation === 1;
  // local pixel unit
  var pixelUnit = dicomElements.getPixelUnit();
  if (pixelUnit) {
    meta.pixelUnit = pixelUnit;
  }
  // FrameOfReferenceUID (optional)
  var frameOfReferenceUID = dicomElements.getFromKey('x00200052');
  if (frameOfReferenceUID) {
    meta.FrameOfReferenceUID = frameOfReferenceUID;
  }
  // window level presets
  var windowPresets = {};
  var windowCenter = dicomElements.getFromKey('x00281050', true);
  var windowWidth = dicomElements.getFromKey('x00281051', true);
  var windowCWExplanation = dicomElements.getFromKey('x00281055', true);
  if (windowCenter && windowWidth) {
    var name;
    for (var j = 0; j < windowCenter.length; ++j) {
      var center = parseFloat(windowCenter[j], 10);
      var width = parseFloat(windowWidth[j], 10);
      if (center && width && width !== 0) {
        name = '';
        if (windowCWExplanation) {
          name = dwv.dicom.cleanString(windowCWExplanation[j]);
        }
        if (name === '') {
          name = 'Default' + j;
        }
        windowPresets[name] = {
          wl: [new dwv.image.WindowLevel(center, width)],
          name: name
        };
      }
      if (width === 0) {
        dwv.logger.warn('Zero window width found in DICOM.');
      }
    }
  }
  meta.windowPresets = windowPresets;

  // PALETTE COLOR luts
  if (image.getPhotometricInterpretation() === 'PALETTE COLOR') {
    var redLut = dicomElements.getFromKey('x00281201');
    var greenLut = dicomElements.getFromKey('x00281202');
    var blueLut = dicomElements.getFromKey('x00281203');
    // check red palette descriptor (should all be equal)
    var descriptor = dicomElements.getFromKey('x00281101');
    if (typeof descriptor !== 'undefined' &&
            descriptor.length === 3) {
      if (descriptor[2] === 16) {
        var doScale = false;
        // (C.7.6.3.1.5 Palette Color Lookup Table Descriptor)
        // Some implementations have encoded 8 bit entries with 16 bits
        // allocated, padding the high bits;
        var descSize = descriptor[0];
        // (C.7.6.3.1.5 Palette Color Lookup Table Descriptor)
        // The first Palette Color Lookup Table Descriptor value is the
        // number of entries in the lookup table. When the number of table
        // entries is equal to 216 then this value shall be 0.
        if (descSize === 0) {
          descSize = 65536;
        }
        // red palette VL
        var redLutDE = dicomElements.getDEFromKey('x00281201');
        var vlSize = redLutDE.vl;
        // check double size
        if (vlSize !== 2 * descSize) {
          doScale = true;
          dwv.logger.info('16bits lut but size is not double. desc: ' +
            descSize + ' vl: ' + vlSize);
        }
        // (C.7.6.3.1.6 Palette Color Lookup Table Data)
        // Palette color values must always be scaled across the full
        // range of available intensities
        var bitsAllocated = parseInt(dicomElements.getFromKey('x00280100'), 10);
        if (bitsAllocated === 8) {
          doScale = true;
          dwv.logger.info(
            'Scaling 16bits color lut since bits allocated is 8.');
        }

        if (doScale) {
          var scaleTo8 = function (value) {
            return value >> 8;
          };

          redLut = redLut.map(scaleTo8);
          greenLut = greenLut.map(scaleTo8);
          blueLut = blueLut.map(scaleTo8);
        }
      } else if (descriptor[2] === 8) {
        // lut with vr=OW was read as Uint16, convert it to Uint8
        dwv.logger.info(
          'Scaling 16bits color lut since the lut descriptor is 8.');
        var clone = redLut.slice(0);
        redLut = new Uint8Array(clone.buffer);
        clone = greenLut.slice(0);
        greenLut = new Uint8Array(clone.buffer);
        clone = blueLut.slice(0);
        blueLut = new Uint8Array(clone.buffer);
      }
    }
    // set the palette
    meta.paletteLut = {
      red: redLut,
      green: greenLut,
      blue: blueLut
    };
  }

  // RecommendedDisplayFrameRate
  var recommendedDisplayFrameRate = dicomElements.getFromKey('x00082144');
  if (recommendedDisplayFrameRate) {
    meta.RecommendedDisplayFrameRate = parseInt(
      recommendedDisplayFrameRate, 10);
  }

  // store the meta data
  image.setMeta(meta);

  return image;
};

// namespaces
var dwv = dwv || {};
dwv.image = dwv.image || {};

/**
 * Get an simple iterator for a given range for a one component data.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols
 * @param {Function} dataAccessor Function to access data.
 * @param {number} start The start of the range (included).
 * @param {number} end The end of the range (excluded).
 * @param {number} increment The increment between indicies (default=1).
 * @returns {object} An iterator folowing the iterator and iterable protocol.
 */
dwv.image.simpleRange = function (dataAccessor, start, end, increment) {
  if (typeof increment === 'undefined') {
    increment = 1;
  }
  var nextIndex = start;
  // result
  return {
    next: function () {
      if (nextIndex < end) {
        var result = {
          value: dataAccessor(nextIndex),
          done: false,
          index: nextIndex
        };
        nextIndex += increment;
        return result;
      }
      return {
        done: true,
        index: end
      };
    }
  };
};

/**
 * Get an iterator for a given range for a one component data.
 *
 * Using 'maxIter' and not an 'end' index since it fails in some edge cases
 * (for ex coronal2, ie zxy)
 *
 * @param {Function} dataAccessor Function to access data.
 * @param {number} start Zero-based index at which to start the iteration.
 * @param {number} maxIter The maximum number of iterations.
 * @param {number} increment Increment between indicies.
 * @param {number} blockMaxIter Number of applied increment after which
 *   blockIncrement is applied.
 * @param {number} blockIncrement Increment after blockMaxIter is reached,
 *   the value is from block start to the next block start.
 * @param {boolean} reverse1 If true, loop from end to start.
 *   WARN: don't forget to set the value of start as the last index!
 * @param {boolean} reverse2 If true, loop from block end to block start.
 * @returns {object} An iterator folowing the iterator and iterable protocol.
 */
dwv.image.range = function (dataAccessor, start, maxIter, increment,
  blockMaxIter, blockIncrement, reverse1, reverse2) {
  if (typeof reverse1 === 'undefined') {
    reverse1 = false;
  }
  if (typeof reverse2 === 'undefined') {
    reverse2 = false;
  }

  // first index of the iteration
  var nextIndex = start;
  // adapt first index and increments to reverse values
  if (reverse1) {
    blockIncrement *= -1;
    if (reverse2) {
      // start at end of line
      nextIndex -= (blockMaxIter - 1) * increment;
    } else {
      increment *= -1;
    }
  } else {
    if (reverse2) {
      // start at end of line
      nextIndex += (blockMaxIter - 1) * increment;
      increment *= -1;
    }
  }
  var finalBlockIncrement = blockIncrement - blockMaxIter * increment;

  // counters
  var mainCount = 0;
  var blockCount = 0;
  // result
  return {
    next: function () {
      if (mainCount < maxIter) {
        var result = {
          value: dataAccessor(nextIndex),
          done: false,
          index: nextIndex
        };
        nextIndex += increment;
        ++mainCount;
        ++blockCount;
        if (blockCount === blockMaxIter) {
          blockCount = 0;
          nextIndex += finalBlockIncrement;
        }
        return result;
      }
      return {
        done: true,
        index: nextIndex
      };
    }
  };
};

/**
 * Get an iterator for a given range with bounds (for a one component data).
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols
 * @param {Function} dataAccessor Function to access data.
 * @param {number} start The start of the range (included).
 * @param {number} end The end of the range (excluded).
 * @param {number} increment The increment between indicies.
 * @param {number} regionSize The size of the region to iterate through.
 * @param {number} regionOffset The offset between regions.
 * @returns {object} An iterator folowing the iterator and iterable protocol.
 */
dwv.image.rangeRegion = function (
  dataAccessor, start, end, increment, regionSize, regionOffset) {
  var nextIndex = start;
  var regionElementCount = 0;
  // result
  return {
    next: function () {
      if (nextIndex < end) {
        var result = {
          value: dataAccessor(nextIndex),
          done: false,
          index: nextIndex
        };
        regionElementCount += 1;
        nextIndex += increment;
        if (regionElementCount === regionSize) {
          regionElementCount = 0;
          nextIndex += regionOffset;
        }
        return result;
      }
      return {
        done: true,
        index: end
      };
    }
  };
};

/**
 * Get an iterator for a given range with bounds (for a one component data).
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols
 * @param {Function} dataAccessor Function to access data.
 * @param {number} start The start of the range (included).
 * @param {number} end The end of the range (excluded).
 * @param {number} increment The increment between indicies.
 * @param {Array} regions An array of regions: [off0, size, off1].
 * @returns {object} An iterator folowing the iterator and iterable protocol.
 */
dwv.image.rangeRegions = function (
  dataAccessor, start, end, increment, regions) {
  var nextIndex = start;
  var regionCount = 0;
  var regionElementCount = 0;
  // result
  return {
    next: function () {
      if (nextIndex < end) {
        var result = {
          value: dataAccessor(nextIndex),
          done: false,
          index: nextIndex
        };
        regionElementCount += 1;
        nextIndex += increment;
        if (regionElementCount === regions[regionCount][1]) {
          regionElementCount = 0;
          // off1 of current group
          nextIndex += regions[regionCount][2];
          regionCount += 1;
          // off0 of next group
          if (regionCount < regions.length) {
            nextIndex += regions[regionCount][0];
          }
        }
        return result;
      }
      return {
        done: true,
        index: end
      };
    }
  };
};

/**
 * Get an iterator for a given range for a 3 components data.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols
 * @param {Function} dataAccessor Function to access data.
 * @param {number} start The start of the range (included).
 * @param {number} end The end of the range (excluded).
 *   (end - start) needs to be a multiple of 3...
 * @param {number} increment The increment between indicies (default=1).
 * @param {boolean} isPlanar A flag to know if the data is planar
 *   (RRRR...GGGG...BBBB...) or not (RGBRGBRGBRGB...), defaults to false.
 * @returns {object} A 3 components iterator folowing the iterator and iterable
 *   protocol, the value is an array of size 3 with each component.
 */
dwv.image.simpleRange3d = function (
  dataAccessor, start, end, increment, isPlanar) {
  if (typeof increment === 'undefined') {
    increment = 1;
  }
  if (typeof isPlanar === 'undefined') {
    isPlanar = false;
  }
  var nextIndex = start;
  var componentIncrement = 1;
  if (isPlanar) {
    componentIncrement = (end - start) / 3;
  } else {
    increment *= 3;
  }
  var nextIndex1 = nextIndex + componentIncrement;
  var nextIndex2 = nextIndex + 2 * componentIncrement;

  // result
  return {
    next: function () {
      if (nextIndex < end) {
        var result = {
          value: [
            dataAccessor(nextIndex),
            dataAccessor(nextIndex1),
            dataAccessor(nextIndex2)
          ],
          done: false,
          index: [nextIndex, nextIndex1, nextIndex2]
        };
        nextIndex += increment;
        nextIndex1 += increment;
        nextIndex2 += increment;
        return result;
      }
      return {
        done: true,
        index: [end]
      };
    }
  };
};

/**
 * Get an iterator for a given range for a 3 components data.
 *
 * Using 'maxIter' and not an 'end' index since it fails in some edge cases
 * (for ex coronal2, ie zxy)
 *
 * @param {Function} dataAccessor Function to access data.
 * @param {number} start Zero-based index at which to start the iteration.
 * @param {number} maxIter The maximum number of iterations.
 * @param {number} increment Increment between indicies.
 * @param {number} blockMaxIter Number of applied increment after which
 *   blockIncrement is applied.
 * @param {number} blockIncrement Increment after blockMaxIter is reached,
 *   the value is from block start to the next block start.
 * @param {boolean} reverse1 If true, loop from end to start.
 *   WARN: don't forget to set the value of start as the last index!
 * @param {boolean} reverse2 If true, loop from block end to block start.
 * @param {boolean} isPlanar A flag to know if the data is planar
 *   (RRRR...GGGG...BBBB...) or not (RGBRGBRGBRGB...), defaults to false.
 * @returns {object} An iterator folowing the iterator and iterable protocol.
 */
dwv.image.range3d = function (dataAccessor, start, maxIter, increment,
  blockMaxIter, blockIncrement, reverse1, reverse2, isPlanar) {
  var iters = [];
  if (isPlanar) {
    iters.push(dwv.image.range(
      dataAccessor, start, maxIter, increment,
      blockMaxIter, blockIncrement, reverse1, reverse2
    ));
    iters.push(dwv.image.range(
      dataAccessor, start + maxIter * increment, maxIter, increment,
      blockMaxIter, blockIncrement, reverse1, reverse2
    ));
    iters.push(dwv.image.range(
      dataAccessor, start + 2 * maxIter * increment, maxIter, increment,
      blockMaxIter, blockIncrement, reverse1, reverse2
    ));
  } else {
    increment *= 3;
    blockIncrement *= 3;
    iters.push(dwv.image.range(
      dataAccessor, start, maxIter, increment,
      blockMaxIter, blockIncrement, reverse1, reverse2
    ));
    iters.push(dwv.image.range(
      dataAccessor, start + 1, maxIter, increment,
      blockMaxIter, blockIncrement, reverse1, reverse2
    ));
    iters.push(dwv.image.range(
      dataAccessor, start + 2, maxIter, increment,
      blockMaxIter, blockIncrement, reverse1, reverse2
    ));
  }

  // result
  return {
    next: function () {
      var r0 = iters[0].next();
      var r1 = iters[1].next();
      var r2 = iters[2].next();
      if (!r0.done) {
        return {
          value: [
            r0.value,
            r1.value,
            r2.value
          ],
          done: false,
          index: [
            r0.index,
            r1.index,
            r2.index
          ]
        };
      }
      return {
        done: true,
        index: r2.index
      };
    }
  };
};

/**
 * Get a list of values for a given iterator.
 *
 * @param {object} iterator The iterator to use to loop through data.
 * @returns {Array} The list of values.
 */
dwv.image.getIteratorValues = function (iterator) {
  var values = [];
  var ival = iterator.next();
  while (!ival.done) {
    values.push(ival.value);
    ival = iterator.next();
  }
  return values;
};

/**
 * Get a slice index iterator.
 *
 * @param {dwv.image.Image} image The image to parse.
 * @param {dwv.math.Point} position The current position.
 * @param {boolean} isRescaled Flag for rescaled values (default false).
 * @param {dwv.math.Matrix33} viewOrientation The view orientation.
 * @returns {object} The slice iterator.
 */
dwv.image.getSliceIterator = function (
  image, position, isRescaled, viewOrientation) {
  var size = image.getGeometry().getSize();
  // zero-ify non direction index
  var dirMax2Index = 2;
  if (viewOrientation && typeof viewOrientation !== 'undefined') {
    dirMax2Index = viewOrientation.getColAbsMax(2).index;
  }
  var posValues = position.getValues();
  // keep the main direction and any other than 3D
  var indexFilter = function (element, index) {
    return (index === dirMax2Index || index > 2) ? element : 0;
  };
  var posStart = new dwv.math.Index(posValues.map(indexFilter));
  var start = size.indexToOffset(posStart);

  // default to non rescaled data
  if (typeof isRescaled === 'undefined') {
    isRescaled = false;
  }
  var dataAccessor = null;
  if (isRescaled) {
    dataAccessor = function (offset) {
      return image.getRescaledValueAtOffset(offset);
    };
  } else {
    dataAccessor = function (offset) {
      return image.getValueAtOffset(offset);
    };
  }

  var ncols = size.get(0);
  var nrows = size.get(1);
  var nslices = size.get(2);
  var sliceSize = size.getDimSize(2);

  var ncomp = image.getNumberOfComponents();
  var isPlanar = image.getPlanarConfiguration() === 1;
  var getRange = function (
    dataAccessor, start, maxIter, increment,
    blockMaxIter, blockIncrement, reverse1, reverse2) {
    if (ncomp === 1) {
      return dwv.image.range(dataAccessor, start, maxIter, increment,
        blockMaxIter, blockIncrement, reverse1, reverse2);
    } else if (ncomp === 3) {
      return dwv.image.range3d(dataAccessor, 3 * start, maxIter, increment,
        blockMaxIter, blockIncrement, reverse1, reverse2, isPlanar);
    }
  };

  var range = null;
  if (viewOrientation && typeof viewOrientation !== 'undefined') {
    var dirMax0 = viewOrientation.getColAbsMax(0);
    var dirMax2 = viewOrientation.getColAbsMax(2);

    // default reverse
    var reverse1 = false;
    var reverse2 = false;

    var maxIter = null;
    if (dirMax2.index === 2) {
      // axial
      maxIter = ncols * nrows;
      if (dirMax0.index === 0) {
        // xyz
        range = getRange(dataAccessor,
          start, maxIter, 1, ncols, ncols, reverse1, reverse2);
      } else {
        // yxz
        range = getRange(dataAccessor,
          start, maxIter, ncols, nrows, 1, reverse1, reverse2);
      }
    } else if (dirMax2.index === 0) {
      // sagittal
      maxIter = nslices * nrows;
      if (dirMax0.index === 1) {
        // yzx
        range = getRange(dataAccessor,
          start, maxIter, ncols, nrows, sliceSize, reverse1, reverse2);
      } else {
        // zyx
        range = getRange(dataAccessor,
          start, maxIter, sliceSize, nslices, ncols, reverse1, reverse2);
      }
    } else if (dirMax2.index === 1) {
      // coronal
      maxIter = nslices * ncols;
      if (dirMax0.index === 0) {
        // xzy
        range = getRange(dataAccessor,
          start, maxIter, 1, ncols, sliceSize, reverse1, reverse2);
      } else {
        // zxy
        range = getRange(dataAccessor,
          start, maxIter, sliceSize, nslices, 1, reverse1, reverse2);
      }
    } else {
      throw new Error('Unknown direction: ' + dirMax2.index);
    }
  } else {
    if (image.getNumberOfComponents() === 1) {
      range = dwv.image.simpleRange(dataAccessor, start, start + sliceSize);
    } else if (image.getNumberOfComponents() === 3) {
      // 3 times bigger...
      start *= 3;
      sliceSize *= 3;
      range = dwv.image.simpleRange3d(
        dataAccessor, start, start + sliceSize, 1, isPlanar);
    } else {
      throw new Error('Unsupported number of components: ' +
        image.getNumberOfComponents());
    }
  }

  return range;
};

/**
 * Get a slice index iterator for a rectangular region.
 *
 * @param {dwv.image.Image} image The image to parse.
 * @param {dwv.math.Point} position The current position.
 * @param {boolean} isRescaled Flag for rescaled values (default false).
 * @param {dwv.math.Point2D} min The minimum position (optional).
 * @param {dwv.math.Point2D} max The maximum position (optional).
 * @returns {object} The slice iterator.
 */
dwv.image.getRegionSliceIterator = function (
  image, position, isRescaled, min, max) {
  if (image.getNumberOfComponents() !== 1) {
    throw new Error('Unsupported number of components for region iterator: ' +
      image.getNumberOfComponents());
  }

  // default to non rescaled data
  if (typeof isRescaled === 'undefined') {
    isRescaled = false;
  }
  var dataAccessor = null;
  if (isRescaled) {
    dataAccessor = function (offset) {
      return image.getRescaledValueAtOffset(offset);
    };
  } else {
    dataAccessor = function (offset) {
      return image.getValueAtOffset(offset);
    };
  }

  var size = image.getGeometry().getSize();
  if (typeof min === 'undefined') {
    min = new dwv.math.Point2D(0, 0);
  }
  if (typeof max === 'undefined') {
    max = new dwv.math.Point2D(
      size.get(0) - 1,
      size.get(1)
    );
  }
  // position to pixel for max: extra X is ok, remove extra Y
  var startOffset = size.indexToOffset(position.getWithNew2D(
    min.getX(), min.getY()
  ));
  var endOffset = size.indexToOffset(position.getWithNew2D(
    max.getX(), max.getY() - 1
  ));

  // minimum 1 column
  var rangeNumberOfColumns = Math.max(1, max.getX() - min.getX());
  var rowIncrement = size.get(0) - rangeNumberOfColumns;

  return dwv.image.rangeRegion(
    dataAccessor, startOffset, endOffset + 1,
    1, rangeNumberOfColumns, rowIncrement);
};

/**
 * Get a slice index iterator for a rectangular region.
 *
 * @param {dwv.image.Image} image The image to parse.
 * @param {dwv.math.Point} position The current position.
 * @param {boolean} isRescaled Flag for rescaled values (default false).
 * @param {Array} regions An array of regions.
 * @returns {object|undefined} The slice iterator.
 */
dwv.image.getVariableRegionSliceIterator = function (
  image, position, isRescaled, regions) {
  if (image.getNumberOfComponents() !== 1) {
    throw new Error('Unsupported number of components for region iterator: ' +
      image.getNumberOfComponents());
  }

  // default to non rescaled data
  if (typeof isRescaled === 'undefined') {
    isRescaled = false;
  }
  var dataAccessor = null;
  if (isRescaled) {
    dataAccessor = function (offset) {
      return image.getRescaledValueAtOffset(offset);
    };
  } else {
    dataAccessor = function (offset) {
      return image.getValueAtOffset(offset);
    };
  }

  var size = image.getGeometry().getSize();

  var offsetRegions = [];
  var region;
  var min = null;
  var max = null;
  var index = null;
  for (var i = 0; i < regions.length; ++i) {
    region = regions[i];
    var width = region[1][0] - region[0][0];
    if (width !== 0) {
      index = i;
      if (!min) {
        min = region[0];
      }
      offsetRegions.push([
        region[0][0],
        width,
        size.get(0) - region[1][0]
      ]);
    }
  }
  if (index !== null) {
    max = regions[index][1];
  }

  // exit if no offsets
  if (offsetRegions.length === 0) {
    return undefined;
  }

  var startOffset = size.indexToOffset(position.getWithNew2D(
    min[0], min[1]
  ));
  var endOffset = size.indexToOffset(position.getWithNew2D(
    max[0], max[1]
  ));

  return dwv.image.rangeRegions(
    dataAccessor, startOffset, endOffset + 1,
    1, offsetRegions);
};

/**
 * Get a colour iterator. The input array defines the colours and
 * their start index.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols
 * @param {Array} colours An array of {index, colour} pairs.
 * @param {number} end The end of the range (excluded).
 * @returns {object} An iterator folowing the iterator and iterable protocol.
 */
dwv.image.colourRange = function (colours, end) {
  var nextIndex = 0;
  var nextColourIndex = 0;
  // result
  return {
    next: function () {
      if (nextIndex < end) {
        if (nextColourIndex + 1 < colours.length &&
          nextIndex >= colours[nextColourIndex + 1].index) {
          ++nextColourIndex;
        }
        var result = {
          value: colours[nextColourIndex].colour,
          done: false,
          index: nextIndex
        };
        ++nextIndex;
        return result;
      }
      return {
        done: true,
        index: end
      };
    }
  };
};

// namespaces
var dwv = dwv || {};
dwv.image = dwv.image || {};
/** @namespace */
dwv.image.lut = dwv.image.lut || {};

/**
 * Lookup tables for image colour display.
 */

dwv.image.lut.range_max = 256;

/**
 * Build a LUT of size range_max.
 *
 * @param {Function} func The i to lut function.
 * @returns {Array} THe LUT.
 */
dwv.image.lut.buildLut = function (func) {
  var lut = [];
  for (var i = 0; i < dwv.image.lut.range_max; ++i) {
    lut.push(func(i));
  }
  return lut;
};

/**
 * Max function: returns range_max minus one.
 *
 * @param {number} _i The input index.
 * @returns {number} The lut value.
 */
dwv.image.lut.max = function (_i) {
  return dwv.image.lut.range_max - 1;
};

/**
 * Returns range_max minus one for the first third of i, otherwise 0.
 *
 * @param {number} i The input index.
 * @returns {number} The lut value.
 */
dwv.image.lut.maxFirstThird = function (i) {
  if (i < dwv.image.lut.range_max / 3) {
    return dwv.image.lut.range_max - 1;
  }
  return 0;
};

/**
 * Returns range_max minus one from one third to two thirds of i, otherwise 0.
 *
 * @param {number} i The input index.
 * @returns {number} The lut value.
 */
dwv.image.lut.maxSecondThird = function (i) {
  var third = dwv.image.lut.range_max / 3;
  if (i >= third && i < 2 * third) {
    return dwv.image.lut.range_max - 1;
  }
  return 0;
};

/**
 * Returns range_max minus one from one third to two thirds of i, otherwise 0.
 *
 * @param {number} i The input index.
 * @returns {number} The lut value.
 */
dwv.image.lut.maxThirdThird = function (i) {
  if (i >= 2 * dwv.image.lut.range_max / 3) {
    return dwv.image.lut.range_max - 1;
  }
  return 0;
};

/**
 * Ramp to range_max minus one on the first third values.
 *
 * @param {number} i The input index.
 * @returns {number} The lut value.
 */
dwv.image.lut.toMaxFirstThird = function (i) {
  var val = i * 3;
  if (val > dwv.image.lut.range_max - 1) {
    return dwv.image.lut.range_max - 1;
  }
  return val;
};

/**
 * Ramp to range_max minus one on the second third values.
 *  otherwise return 0 for the first third and
 *  range_max minus one for the last third.
 *
 * @param {number} i The input index.
 * @returns {number} The lut value.
 */
dwv.image.lut.toMaxSecondThird = function (i) {
  var third = dwv.image.lut.range_max / 3;
  var val = 0;
  if (i >= third) {
    val = (i - third) * 3;
    if (val > dwv.image.lut.range_max - 1) {
      return dwv.image.lut.range_max - 1;
    }
  }
  return val;
};

/**
 * Ramp to range_max minus one on the last third values.
 *  otherwise return 0.
 *
 * @param {number} i The input index.
 * @returns {number} The lut value.
 */
dwv.image.lut.toMaxThirdThird = function (i) {
  var third = dwv.image.lut.range_max / 3;
  var val = 0;
  if (i >= 2 * third) {
    val = (i - 2 * third) * 3;
    if (val > dwv.image.lut.range_max - 1) {
      return dwv.image.lut.range_max - 1;
    }
  }
  return val;
};

/**
 * Returns zero.
 *
 * @param {number} _i The input index.
 * @returns {number} The lut value.
 */
dwv.image.lut.zero = function (_i) {
  return 0;
};

/**
 * Identity, returns i.
 *
 * @param {number} i The input index.
 * @returns {number} The lut value.
 */
dwv.image.lut.id = function (i) {
  return i;
};

/**
 * Returns range_max minus one minus i.
 *
 * @param {number} i The input index.
 * @returns {number} The lut value.
 */
dwv.image.lut.invId = function (i) {
  return (dwv.image.lut.range_max - 1) - i;
};

// plain
dwv.image.lut.plain = {
  red: dwv.image.lut.buildLut(dwv.image.lut.id),
  green: dwv.image.lut.buildLut(dwv.image.lut.id),
  blue: dwv.image.lut.buildLut(dwv.image.lut.id)
};

// inverse plain
dwv.image.lut.invPlain = {
  red: dwv.image.lut.buildLut(dwv.image.lut.invId),
  green: dwv.image.lut.buildLut(dwv.image.lut.invId),
  blue: dwv.image.lut.buildLut(dwv.image.lut.invId)
};

// rainbow
/* eslint-disable max-len */
dwv.image.lut.rainbow = {
  blue: [0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 148, 152, 156, 160, 164, 168, 172, 176, 180, 184, 188, 192, 196, 200, 204, 208, 212, 216, 220, 224, 228, 232, 236, 240, 244, 248, 252, 255, 247, 239, 231, 223, 215, 207, 199, 191, 183, 175, 167, 159, 151, 143, 135, 127, 119, 111, 103, 95, 87, 79, 71, 63, 55, 47, 39, 31, 23, 15, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  green: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112, 120, 128, 136, 144, 152, 160, 168, 176, 184, 192, 200, 208, 216, 224, 232, 240, 248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 253, 251, 249, 247, 245, 243, 241, 239, 237, 235, 233, 231, 229, 227, 225, 223, 221, 219, 217, 215, 213, 211, 209, 207, 205, 203, 201, 199, 197, 195, 193, 192, 189, 186, 183, 180, 177, 174, 171, 168, 165, 162, 159, 156, 153, 150, 147, 144, 141, 138, 135, 132, 129, 126, 123, 120, 117, 114, 111, 108, 105, 102, 99, 96, 93, 90, 87, 84, 81, 78, 75, 72, 69, 66, 63, 60, 57, 54, 51, 48, 45, 42, 39, 36, 33, 30, 27, 24, 21, 18, 15, 12, 9, 6, 3],
  red: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 62, 60, 58, 56, 54, 52, 50, 48, 46, 44, 42, 40, 38, 36, 34, 32, 30, 28, 26, 24, 22, 20, 18, 16, 14, 12, 10, 8, 6, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 148, 152, 156, 160, 164, 168, 172, 176, 180, 184, 188, 192, 196, 200, 204, 208, 212, 216, 220, 224, 228, 232, 236, 240, 244, 248, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]
};
/* eslint-enable max-len */

// hot
dwv.image.lut.hot = {
  red: dwv.image.lut.buildLut(dwv.image.lut.toMaxFirstThird),
  green: dwv.image.lut.buildLut(dwv.image.lut.toMaxSecondThird),
  blue: dwv.image.lut.buildLut(dwv.image.lut.toMaxThirdThird)
};

// hot iron
/* eslint-disable max-len */
dwv.image.lut.hot_iron = {
  red: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],
  green: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 255],
  blue: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 148, 152, 156, 160, 164, 168, 172, 176, 180, 184, 188, 192, 196, 200, 204, 208, 212, 216, 220, 224, 228, 232, 236, 240, 244, 248, 252, 255]
};
/* eslint-enable max-len */

// pet
/* eslint-disable max-len */
dwv.image.lut.pet = {
  red: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 171, 173, 175, 177, 179, 181, 183, 185, 187, 189, 191, 193, 195, 197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 217, 219, 221, 223, 225, 227, 229, 231, 233, 235, 237, 239, 241, 243, 245, 247, 249, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],
  green: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99, 101, 103, 105, 107, 109, 111, 113, 115, 117, 119, 121, 123, 125, 128, 126, 124, 122, 120, 118, 116, 114, 112, 110, 108, 106, 104, 102, 100, 98, 96, 94, 92, 90, 88, 86, 84, 82, 80, 78, 76, 74, 72, 70, 68, 66, 64, 63, 61, 59, 57, 55, 53, 51, 49, 47, 45, 43, 41, 39, 37, 35, 33, 31, 29, 27, 25, 23, 21, 19, 17, 15, 13, 11, 9, 7, 5, 3, 1, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 255],
  blue: [0, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99, 101, 103, 105, 107, 109, 111, 113, 115, 117, 119, 121, 123, 125, 127, 129, 131, 133, 135, 137, 139, 141, 143, 145, 147, 149, 151, 153, 155, 157, 159, 161, 163, 165, 167, 169, 171, 173, 175, 177, 179, 181, 183, 185, 187, 189, 191, 193, 195, 197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 217, 219, 221, 223, 225, 227, 229, 231, 233, 235, 237, 239, 241, 243, 245, 247, 249, 251, 253, 255, 252, 248, 244, 240, 236, 232, 228, 224, 220, 216, 212, 208, 204, 200, 196, 192, 188, 184, 180, 176, 172, 168, 164, 160, 156, 152, 148, 144, 140, 136, 132, 128, 124, 120, 116, 112, 108, 104, 100, 96, 92, 88, 84, 80, 76, 72, 68, 64, 60, 56, 52, 48, 44, 40, 36, 32, 28, 24, 20, 16, 12, 8, 4, 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 85, 89, 93, 97, 101, 105, 109, 113, 117, 121, 125, 129, 133, 137, 141, 145, 149, 153, 157, 161, 165, 170, 174, 178, 182, 186, 190, 194, 198, 202, 206, 210, 214, 218, 222, 226, 230, 234, 238, 242, 246, 250, 255]
};
/* eslint-enable max-len */

// hot metal blue
/* eslint-disable max-len */
dwv.image.lut.hot_metal_blue = {
  red: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 6, 9, 12, 15, 18, 21, 24, 26, 29, 32, 35, 38, 41, 44, 47, 50, 52, 55, 57, 59, 62, 64, 66, 69, 71, 74, 76, 78, 81, 83, 85, 88, 90, 93, 96, 99, 102, 105, 108, 111, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 166, 169, 172, 175, 178, 181, 184, 187, 190, 194, 198, 201, 205, 209, 213, 217, 221, 224, 228, 232, 236, 240, 244, 247, 251, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],
  green: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4, 6, 8, 9, 11, 13, 15, 17, 19, 21, 23, 24, 26, 28, 30, 32, 34, 36, 38, 40, 41, 43, 45, 47, 49, 51, 53, 55, 56, 58, 60, 62, 64, 66, 68, 70, 72, 73, 75, 77, 79, 81, 83, 85, 87, 88, 90, 92, 94, 96, 98, 100, 102, 104, 105, 107, 109, 111, 113, 115, 117, 119, 120, 122, 124, 126, 128, 130, 132, 134, 136, 137, 139, 141, 143, 145, 147, 149, 151, 152, 154, 156, 158, 160, 162, 164, 166, 168, 169, 171, 173, 175, 177, 179, 181, 183, 184, 186, 188, 190, 192, 194, 196, 198, 200, 201, 203, 205, 207, 209, 211, 213, 215, 216, 218, 220, 222, 224, 226, 228, 229, 231, 233, 235, 237, 239, 240, 242, 244, 246, 248, 250, 251, 253, 255],
  blue: [0, 2, 4, 6, 8, 10, 12, 14, 16, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 117, 119, 121, 123, 125, 127, 129, 131, 133, 135, 137, 139, 141, 143, 145, 147, 149, 151, 153, 155, 157, 159, 161, 163, 165, 167, 169, 171, 173, 175, 177, 179, 181, 183, 184, 186, 188, 190, 192, 194, 196, 198, 200, 197, 194, 191, 188, 185, 182, 179, 176, 174, 171, 168, 165, 162, 159, 156, 153, 150, 144, 138, 132, 126, 121, 115, 109, 103, 97, 91, 85, 79, 74, 68, 62, 56, 50, 47, 44, 41, 38, 35, 32, 29, 26, 24, 21, 18, 15, 12, 9, 6, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 6, 9, 12, 15, 18, 21, 24, 26, 29, 32, 35, 38, 41, 44, 47, 50, 53, 56, 59, 62, 65, 68, 71, 74, 76, 79, 82, 85, 88, 91, 94, 97, 100, 103, 106, 109, 112, 115, 118, 121, 124, 126, 129, 132, 135, 138, 141, 144, 147, 150, 153, 156, 159, 162, 165, 168, 171, 174, 176, 179, 182, 185, 188, 191, 194, 197, 200, 203, 206, 210, 213, 216, 219, 223, 226, 229, 232, 236, 239, 242, 245, 249, 252, 255]
};
/* eslint-enable max-len */

// pet 20 step
/* eslint-disable max-len */
dwv.image.lut.pet_20step = {
  red: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],
  green: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],
  blue: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 224, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]
};
/* eslint-enable max-len */

// test
dwv.image.lut.test = {
  red: dwv.image.lut.buildLut(dwv.image.lut.id),
  green: dwv.image.lut.buildLut(dwv.image.lut.zero),
  blue: dwv.image.lut.buildLut(dwv.image.lut.zero)
};

//red
/*dwv.image.lut.red = {
   "red":   dwv.image.lut.buildLut(dwv.image.lut.max),
   "green": dwv.image.lut.buildLut(dwv.image.lut.id),
   "blue":  dwv.image.lut.buildLut(dwv.image.lut.id)
};*/

// namespaces
var dwv = dwv || {};
dwv.image = dwv.image || {};

/**
 * Check two position patients for equality.
 *
 * @param {*} pos1 The first position patient.
 * @param {*} pos2 The second position patient.
 * @returns {boolean} True is equal.
 */
dwv.dicom.equalPosPat = function (pos1, pos2) {
  return JSON.stringify(pos1) === JSON.stringify(pos2);
};

/**
 * Get a position patient compare function accroding to an
 * input orientation.
 *
 * @param {dwv.math.Matrix33} orientation The orientation matrix.
 * @returns {Function} The position compare function.
 */
dwv.dicom.getComparePosPat = function (orientation) {
  var invOrientation = orientation.getInverse();
  return function (pos1, pos2) {
    var p1 = invOrientation.multiplyArray3D(pos1);
    var p2 = invOrientation.multiplyArray3D(pos2);
    return p1[2] - p2[2];
  };
};

/**
 * Check that a DICOM tag definition is present in a parsed element.
 *
 * @param {object} rootElement The root dicom element.
 * @param {object} tagDefinition The tag definition as {name, tag, type, enum}.
 */
dwv.dicom.checkTag = function (rootElement, tagDefinition) {
  var tagValue = rootElement.getFromKey(tagDefinition.tag);
  // check null and undefined
  if (tagDefinition.type === 1 || tagDefinition.type === 2) {
    if (tagValue === null || typeof tagValue === 'undefined') {
      throw new Error('Missing or empty ' + tagDefinition.name);
    }
  } else {
    if (tagValue === null || typeof tagValue === 'undefined') {
      // non mandatory value, exit
      return;
    }
  }
  var includes = false;
  if (Array.isArray(tagValue)) {
    // trim
    tagValue = tagValue.map(function (item) {
      return dwv.dicom.cleanString(item);
    });
    for (var i = 0; i < tagDefinition.enum.length; ++i) {
      if (!Array.isArray(tagDefinition.enum[i])) {
        throw new Error('Cannot compare array and non array tag value.');
      }
      if (dwv.utils.arraySortEquals(tagDefinition.enum[i], tagValue)) {
        includes = true;
        break;
      }
    }
  } else {
    // trim
    if (typeof tagValue === 'string') {
      tagValue = dwv.dicom.cleanString(tagValue);
    }

    includes = tagDefinition.enum.includes(tagValue);
  }
  if (!includes) {
    throw new Error(
      'Unsupported ' + tagDefinition.name + ' value: ' + tagValue);
  }
};

/**
 * List of DICOM Seg required tags.
 */
dwv.dicom.requiredDicomSegTags = [
  {
    name: 'TransferSyntaxUID',
    tag: 'x00020010',
    type: '1',
    enum: ['1.2.840.10008.1.2.1']
  },
  {
    name: 'MediaStorageSOPClassUID',
    tag: 'x00020002',
    type: '1',
    enum: ['1.2.840.10008.5.1.4.1.1.66.4']
  },
  {
    name: 'SOPClassUID',
    tag: 'x00020002',
    type: '1',
    enum: ['1.2.840.10008.5.1.4.1.1.66.4']
  },
  {
    name: 'Modality',
    tag: 'x00080060',
    type: '1',
    enum: ['SEG']
  },
  {
    name: 'SegmentationType',
    tag: 'x00620001',
    type: '1',
    enum: ['BINARY']
  },
  {
    name: 'DimensionOrganizationType',
    tag: 'x00209311',
    type: '3',
    enum: ['3D']
  },
  {
    name: 'ImageType',
    tag: 'x00080008',
    type: '1',
    enum: [['DERIVED', 'PRIMARY']]
  },
  {
    name: 'SamplesPerPixel',
    tag: 'x00280002',
    type: '1',
    enum: [1]
  },
  {
    name: 'PhotometricInterpretation',
    tag: 'x00280004',
    type: '1',
    enum: ['MONOCHROME2']
  },
  {
    name: 'PixelRepresentation',
    tag: 'x00280103',
    type: '1',
    enum: [0]
  },
  {
    name: 'BitsAllocated',
    tag: 'x00280100',
    type: '1',
    enum: [1]
  },
  {
    name: 'BitsStored',
    tag: 'x00280101',
    type: '1',
    enum: [1]
  },
  {
    name: 'HighBit',
    tag: 'x00280102',
    type: '1',
    enum: [0]
  },
];

/**
 * Get the default DICOM seg tags as an object.
 *
 * @returns {object} The default tags.
 */
dwv.dicom.getDefaultDicomSegJson = function () {
  var tags = {};
  for (var i = 0; i < dwv.dicom.requiredDicomSegTags.length; ++i) {
    var reqTag = dwv.dicom.requiredDicomSegTags[i];
    tags[reqTag.name] = reqTag.enum[0];
  }
  return tags;
};

/**
 * Check the dimension organization from a dicom element.
 *
 * @param {object} rootElement The root dicom element.
 * @returns {object} The dimension organizations and indices.
 */
dwv.dicom.getDimensionOrganization = function (rootElement) {
  // Dimension Organization Sequence (required)
  var orgSq = rootElement.getFromKey('x00209221', true);
  if (!orgSq || orgSq.length !== 1) {
    throw new Error('Unsupported dimension organization sequence length');
  }
  // Dimension Organization UID
  var orgUID = dwv.dicom.cleanString(orgSq[0].x00209164.value[0]);

  // Dimension Index Sequence (conditionally required)
  var indices = [];
  var indexSq = rootElement.getFromKey('x00209222', true);
  if (indexSq) {
    // expecting 2D index
    if (indexSq.length !== 2) {
      throw new Error('Unsupported dimension index sequence length');
    }
    var indexPointer;
    for (var i = 0; i < indexSq.length; ++i) {
      // Dimension Organization UID (required)
      var indexOrg = dwv.dicom.cleanString(indexSq[i].x00209164.value[0]);
      if (indexOrg !== orgUID) {
        throw new Error(
          'Dimension Index Sequence contains a unknown Dimension Organization');
      }
      // Dimension Index Pointer (required)
      indexPointer = dwv.dicom.cleanString(indexSq[i].x00209165.value[0]);

      var index = {
        DimensionOrganizationUID: indexOrg,
        DimensionIndexPointer: indexPointer
      };
      // Dimension Description Label (optional)
      if (typeof indexSq[i].x00209421 !== 'undefined') {
        index.DimensionDescriptionLabel =
          dwv.dicom.cleanString(indexSq[i].x00209421.value[0]);
      }
      // store
      indices.push(index);
    }
    // expecting Image Position at last position
    if (indexPointer !== '(0020,0032)') {
      throw new Error('Unsupported non image position as last index');
    }
  }

  return {
    organizations: {
      value: [
        {
          DimensionOrganizationUID: orgUID
        }
      ]
    },
    indices: {
      value: indices
    }
  };
};

/**
 * Get a code object from a dicom element.
 *
 * @param {object} element The dicom element.
 * @returns {object} A code object.
 */
dwv.dicom.getCode = function (element) {
  // meaning -> CodeMeaning (type1)
  var code = {
    meaning: dwv.dicom.cleanString(element.x00080104.value[0])
  };
  // value -> CodeValue (type1C)
  // longValue -> LongCodeValue (type1C)
  // urnValue -> URNCodeValue (type1C)
  if (element.x00080100) {
    code.value = element.x00080100.value[0];
  } else if (element.x00080119) {
    code.longValue = element.x00080119.value[0];
  } else if (element.x00080120) {
    code.urnValue = element.x00080120.value[0];
  } else {
    throw Error('Invalid code with no value, no long value and no urn value.');
  }
  // schemeDesignator -> CodingSchemeDesignator (type1C)
  if (typeof code.value !== 'undefined' ||
    typeof code.longValue !== 'undefined') {
    if (element.x00080102) {
      code.schemeDesignator = element.x00080102.value[0];
    } else {
      throw Error(
        'No coding sheme designator when code value or long value is present');
    }
  }
  return code;
};

/**
 * Get a segment object from a dicom element.
 *
 * @param {object} element The dicom element.
 * @returns {object} A segment object.
 */
dwv.dicom.getSegment = function (element) {
  // number -> SegmentNumber (type1)
  // label -> SegmentLabel (type1)
  // algorithmType -> SegmentAlgorithmType (type1)
  var segment = {
    number: element.x00620004.value[0],
    label: dwv.dicom.cleanString(element.x00620005.value[0]),
    algorithmType: dwv.dicom.cleanString(element.x00620008.value[0])
  };
  // algorithmName -> SegmentAlgorithmName (type1C)
  if (element.x00620009) {
    segment.algorithmName =
      dwv.dicom.cleanString(element.x00620009.value[0]);
  }
  // // required if type is not MANUAL
  // if (segment.algorithmType !== 'MANUAL' &&
  //   (typeof segment.algorithmName === 'undefined' ||
  //   segment.algorithmName.length === 0)) {
  //   throw new Error('Empty algorithm name for non MANUAL algorithm type.');
  // }
  // displayValue ->
  // - RecommendedDisplayGrayscaleValue
  // - RecommendedDisplayCIELabValue converted to RGB
  if (typeof element.x0062000C !== 'undefined') {
    segment.displayValue = element.x006200C.value;
  } else if (typeof element.x0062000D !== 'undefined') {
    var cielabElement = element.x0062000D.value;
    var rgb = dwv.utils.cielabToSrgb(dwv.utils.uintLabToLab({
      l: cielabElement[0],
      a: cielabElement[1],
      b: cielabElement[2]
    }));
    segment.displayValue = rgb;
  }
  // Segmented Property Category Code Sequence (type1, only one)
  if (typeof element.x00620003 !== 'undefined') {
    segment.propertyCategoryCode =
      dwv.dicom.getCode(element.x00620003.value[0]);
  } else {
    throw Error('Missing Segmented Property Category Code Sequence.');
  }
  // Segmented Property Type Code Sequence (type1)
  if (typeof element.x0062000F !== 'undefined') {
    segment.propertyTypeCode =
      dwv.dicom.getCode(element.x0062000F.value[0]);
  } else {
    throw Error('Missing Segmented Property Type Code Sequence.');
  }
  // tracking Id and UID (type1C)
  if (typeof element.x00620020 !== 'undefined') {
    segment.trackingId = element.x00620020.value[0];
    segment.trackingUid = element.x00620021.value[0];
  }

  return segment;
};

/**
 * Check if two segment objects are equal.
 *
 * @param {object} seg1 The first segment.
 * @param {object} seg2 The second segment.
 * @returns {boolean} True if both segment are equal.
 */
dwv.dicom.isEqualSegment = function (seg1, seg2) {
  // basics
  if (typeof seg1 === 'undefined' ||
    typeof seg2 === 'undefined' ||
    seg1 === null ||
    seg2 === null) {
    return false;
  }
  var isEqual = seg1.number === seg2.number &&
    seg1.label === seg2.label &&
    seg1.algorithmType === seg2.algorithmType;
  // rgb
  if (typeof seg1.displayValue.r !== 'undefined') {
    if (typeof seg2.displayValue.r === 'undefined') {
      isEqual = false;
    } else {
      isEqual = isEqual &&
        dwv.utils.isEqualRgb(seg1.displayValue, seg2.displayValue);
    }
  } else {
    isEqual = isEqual &&
      seg1.displayValue === seg2.displayValue;
  }
  // algorithmName
  if (typeof seg1.algorithmName !== 'undefined') {
    if (typeof seg2.algorithmName === 'undefined') {
      isEqual = false;
    } else {
      isEqual = isEqual &&
        seg1.algorithmName === seg2.algorithmName;
    }
  }

  return isEqual;
};

/**
 * Check if two segment objects are similar: either the
 * number or the displayValue are equal.
 *
 * @param {object} seg1 The first segment.
 * @param {object} seg2 The second segment.
 * @returns {boolean} True if both segment are similar.
 */
dwv.dicom.isSimilarSegment = function (seg1, seg2) {
  // basics
  if (typeof seg1 === 'undefined' ||
    typeof seg2 === 'undefined' ||
    seg1 === null ||
    seg2 === null) {
    return false;
  }
  var isSimilar = seg1.number === seg2.number;
  // rgb
  if (typeof seg1.displayValue.r !== 'undefined') {
    if (typeof seg2.displayValue.r === 'undefined') {
      isSimilar = false;
    } else {
      isSimilar = isSimilar ||
        dwv.utils.isEqualRgb(seg1.displayValue, seg2.displayValue);
    }
  } else {
    isSimilar = isSimilar ||
      seg1.displayValue === seg2.displayValue;
  }

  return isSimilar;
};

/**
 * Get a spacing object from a dicom measure element.
 *
 * @param {object} measure The dicom element.
 * @returns {dwv.image.Spacing} A spacing object.
 */
dwv.dicom.getSpacingFromMeasure = function (measure) {
  // Pixel Spacing
  if (typeof measure.x00280030 === 'undefined') {
    return null;
  }
  var pixelSpacing = measure.x00280030;
  var spacingValues = [
    parseFloat(pixelSpacing.value[0]),
    parseFloat(pixelSpacing.value[1])
  ];
  // Slice Thickness
  if (typeof measure.x00180050 !== 'undefined') {
    spacingValues.push(parseFloat(measure.x00180050.value[0]));
  } else if (typeof measure.x00180088 !== 'undefined') {
    // Spacing Between Slices
    spacingValues.push(parseFloat(measure.x00180088.value[0]));
  }
  return new dwv.image.Spacing(spacingValues);
};

/**
 * Get a frame information object from a dicom element.
 *
 * @param {object} groupItem The dicom element.
 * @returns {object} A frame information object.
 */
dwv.dicom.getSegmentFrameInfo = function (groupItem) {
  // Derivation Image Sequence
  var derivationImages = [];
  if (typeof groupItem.x00089124 !== 'undefined') {
    var derivationImageSq = groupItem.x00089124.value;
    // Source Image Sequence
    for (var i = 0; i < derivationImageSq.length; ++i) {
      var sourceImages = [];
      if (typeof derivationImageSq[i].x00082112 !== 'undefined') {
        var sourceImageSq = derivationImageSq[i].x00082112.value;
        for (var j = 0; j < sourceImageSq.length; ++j) {
          var sourceImage = {};
          // Referenced SOP Class UID
          if (typeof sourceImageSq[j].x00081150 !== 'undefined') {
            sourceImage.referencedSOPClassUID =
              sourceImageSq[j].x00081150.value[0];
          }
          // Referenced SOP Instance UID
          if (typeof sourceImageSq[j].x00081155 !== 'undefined') {
            sourceImage.referencedSOPInstanceUID =
              sourceImageSq[j].x00081155.value[0];
          }
          sourceImages.push(sourceImage);
        }
      }
      derivationImages.push(sourceImages);
    }
  }
  // Frame Content Sequence (required, only one)
  var frameContentSq = groupItem.x00209111.value;
  // Dimension Index Value
  var dimIndex = frameContentSq[0].x00209157.value;
  // Segment Identification Sequence (required, only one)
  var segmentIdSq = groupItem.x0062000A.value;
  // Referenced Segment Number
  var refSegmentNumber = segmentIdSq[0].x0062000B.value[0];
  // Plane Position Sequence (required, only one)
  var planePosSq = groupItem.x00209113.value;
  // Image Position (Patient) (conditionally required)
  var imagePosPat = planePosSq[0].x00200032.value;
  for (var p = 0; p < imagePosPat.length; ++p) {
    imagePosPat[p] = parseFloat(imagePosPat[p], 10);
  }
  var frameInfo = {
    dimIndex: dimIndex,
    imagePosPat: imagePosPat,
    derivationImages: derivationImages,
    refSegmentNumber: refSegmentNumber
  };
  // Plane Orientation Sequence
  if (typeof groupItem.x00209116 !== 'undefined') {
    var framePlaneOrientationSeq = groupItem.x00209116;
    if (framePlaneOrientationSeq.value.length !== 0) {
      // should only be one Image Orientation (Patient)
      var frameImageOrientation =
        framePlaneOrientationSeq.value[0].x00200037.value;
      if (typeof frameImageOrientation !== 'undefined') {
        frameInfo.imageOrientationPatient = frameImageOrientation;
      }
    }
  }
  // Pixel Measures Sequence
  if (typeof groupItem.x00289110 !== 'undefined') {
    var framePixelMeasuresSeq = groupItem.x00289110;
    if (framePixelMeasuresSeq.value.length !== 0) {
      // should only be one
      var frameSpacing =
        dwv.dicom.getSpacingFromMeasure(framePixelMeasuresSeq.value[0]);
      if (typeof frameSpacing !== 'undefined') {
        frameInfo.spacing = frameSpacing;
      }
    } else {
      dwv.logger.warn(
        'No shared functional group pixel measure sequence items.');
    }
  }

  return frameInfo;
};

/**
 * Mask {@link dwv.image.Image} factory.
 *
 * @class
 */
dwv.image.MaskFactory = function () {};

/**
 * Get an {@link dwv.image.Image} object from the read DICOM file.
 *
 * @param {object} dicomElements The DICOM tags.
 * @param {Array} pixelBuffer The pixel buffer.
 * @returns {dwv.image.Image} A new Image.
 */
dwv.image.MaskFactory.prototype.create = function (
  dicomElements, pixelBuffer) {
  // check required and supported tags
  for (var d = 0; d < dwv.dicom.requiredDicomSegTags.length; ++d) {
    dwv.dicom.checkTag(dicomElements, dwv.dicom.requiredDicomSegTags[d]);
  }

  // columns
  var columns = dicomElements.getFromKey('x00280011');
  if (!columns) {
    throw new Error('Missing or empty DICOM image number of columns');
  }
  // rows
  var rows = dicomElements.getFromKey('x00280010');
  if (!rows) {
    throw new Error('Missing or empty DICOM image number of rows');
  }
  var sliceSize = columns * rows;

  // frames
  var frames = dicomElements.getFromKey('x00280008');
  if (!frames) {
    frames = 1;
  } else {
    frames = parseInt(frames, 10);
  }

  if (frames !== pixelBuffer.length / sliceSize) {
    throw new Error(
      'Buffer and numberOfFrames meta are not equal.' +
      frames + ' ' + pixelBuffer.length / sliceSize);
  }

  // Dimension Organization and Index
  var dimension = dwv.dicom.getDimensionOrganization(dicomElements);

  // Segment Sequence
  var segSequence = dicomElements.getFromKey('x00620002', true);
  if (!segSequence || typeof segSequence === 'undefined') {
    throw new Error('Missing or empty segmentation sequence');
  }
  var segments = [];
  var storeAsRGB = false;
  for (var i = 0; i < segSequence.length; ++i) {
    var segment = dwv.dicom.getSegment(segSequence[i]);
    if (typeof segment.displayValue.r !== 'undefined' &&
      typeof segment.displayValue.g !== 'undefined' &&
      typeof segment.displayValue.b !== 'undefined') {
      // create rgb image
      storeAsRGB = true;
    }
    // store
    segments.push(segment);
  }

  // image size
  var size = dicomElements.getImageSize();

  // Shared Functional Groups Sequence
  var spacing;
  var imageOrientationPatient;
  var sharedFunctionalGroupsSeq = dicomElements.getFromKey('x52009229', true);
  if (sharedFunctionalGroupsSeq && sharedFunctionalGroupsSeq.length !== 0) {
    // should be only one
    var funcGroup0 = sharedFunctionalGroupsSeq[0];
    // Plane Orientation Sequence
    if (typeof funcGroup0.x00209116 !== 'undefined') {
      var planeOrientationSeq = funcGroup0.x00209116;
      if (planeOrientationSeq.value.length !== 0) {
        // should be only one
        imageOrientationPatient = planeOrientationSeq.value[0].x00200037.value;
      } else {
        dwv.logger.warn(
          'No shared functional group plane orientation sequence items.');
      }
    }
    // Pixel Measures Sequence
    if (typeof funcGroup0.x00289110 !== 'undefined') {
      var pixelMeasuresSeq = funcGroup0.x00289110;
      if (pixelMeasuresSeq.value.length !== 0) {
        // should be only one
        spacing = dwv.dicom.getSpacingFromMeasure(pixelMeasuresSeq.value[0]);
      } else {
        dwv.logger.warn(
          'No shared functional group pixel measure sequence items.');
      }
    }
  }

  var includesPosPat = function (arr, val) {
    return arr.some(function (arrVal) {
      return dwv.dicom.equalPosPat(val, arrVal);
    });
  };

  var findIndexPosPat = function (arr, val) {
    return arr.findIndex(function (arrVal) {
      return dwv.dicom.equalPosPat(val, arrVal);
    });
  };

  // Per-frame Functional Groups Sequence
  var perFrameFuncGroupSequence = dicomElements.getFromKey('x52009230', true);
  if (!perFrameFuncGroupSequence ||
    typeof perFrameFuncGroupSequence === 'undefined') {
    throw new Error('Missing or empty per frame functional sequence');
  }
  if (frames !== perFrameFuncGroupSequence.length) {
    throw new Error(
      'perFrameFuncGroupSequence meta and numberOfFrames are not equal.');
  }
  // create frame info object from per frame func
  var frameInfos = [];
  for (var j = 0; j < perFrameFuncGroupSequence.length; ++j) {
    frameInfos.push(
      dwv.dicom.getSegmentFrameInfo(perFrameFuncGroupSequence[j]));
  }

  // check frame infos
  var framePosPats = [];
  for (var ii = 0; ii < frameInfos.length; ++ii) {
    if (!includesPosPat(framePosPats, frameInfos[ii].imagePosPat)) {
      framePosPats.push(frameInfos[ii].imagePosPat);
    }
    // store orientation if needed, avoid multi
    if (typeof frameInfos[ii].imageOrientationPatient !== 'undefined') {
      if (typeof imageOrientationPatient === 'undefined') {
        imageOrientationPatient = frameInfos[ii].imageOrientationPatient;
      } else {
        if (!dwv.utils.arraySortEquals(
          imageOrientationPatient, frameInfos[ii].imageOrientationPatient)) {
          throw new Error('Unsupported multi orientation dicom seg.');
        }
      }
    }
    // store spacing if needed, avoid multi
    if (typeof frameInfos[ii].spacing !== 'undefined') {
      if (typeof spacing === 'undefined') {
        spacing = frameInfos[ii].spacing;
      } else {
        if (!spacing.equals(frameInfos[ii].spacing)) {
          throw new Error('Unsupported multi resolution dicom seg.');
        }
      }
    }
  }

  // check spacing and orientation
  if (typeof spacing === 'undefined') {
    throw new Error('No spacing found for DICOM SEG');
  }
  if (typeof imageOrientationPatient === 'undefined') {
    throw new Error('No imageOrientationPatient found for DICOM SEG');
  }

  // orientation
  var rowCosines = new dwv.math.Vector3D(
    parseFloat(imageOrientationPatient[0]),
    parseFloat(imageOrientationPatient[1]),
    parseFloat(imageOrientationPatient[2]));
  var colCosines = new dwv.math.Vector3D(
    parseFloat(imageOrientationPatient[3]),
    parseFloat(imageOrientationPatient[4]),
    parseFloat(imageOrientationPatient[5]));
  var normal = rowCosines.crossProduct(colCosines);
  /* eslint-disable array-element-newline */
  var orientationMatrix = new dwv.math.Matrix33([
    rowCosines.getX(), colCosines.getX(), normal.getX(),
    rowCosines.getY(), colCosines.getY(), normal.getY(),
    rowCosines.getZ(), colCosines.getZ(), normal.getZ()
  ]);

  // sort positions patient
  framePosPats.sort(dwv.dicom.getComparePosPat(orientationMatrix));

  var point3DFromArray = function (arr) {
    return new dwv.math.Point3D(arr[0], arr[1], arr[2]);
  };

  // frame origins
  var frameOrigins = [];
  for (var n = 0; n < framePosPats.length; ++n) {
    frameOrigins.push(point3DFromArray(framePosPats[n]));
  }

  // use calculated spacing
  var newSpacing = spacing;
  var geoSliceSpacing = dwv.image.getSliceGeometrySpacing(
    frameOrigins, orientationMatrix, false);
  var spacingValues = spacing.getValues();
  if (typeof geoSliceSpacing !== 'undefined' &&
    geoSliceSpacing !== spacingValues[2]) {
    spacingValues[2] = geoSliceSpacing;
    newSpacing = new dwv.image.Spacing(spacingValues);
  }

  // tmp geometry with correct spacing but only one slice
  var tmpGeometry = new dwv.image.Geometry(
    frameOrigins[0], size, newSpacing, orientationMatrix);

  // origin distance test
  var isNotSmall = function (value) {
    var res = value > dwv.math.REAL_WORLD_EPSILON;
    if (res) {
      // try larger epsilon
      res = value > dwv.math.REAL_WORLD_EPSILON * 10;
      if (!res) {
        // warn if epsilon < value < epsilon * 10
        dwv.logger.warn(
          'Using larger real world epsilon in SEG pos pat adding'
        );
      } else {
        // try even larger epsilon
        res = value > dwv.math.REAL_WORLD_EPSILON * 100;
        if (!res) {
          // warn if epsilon < value < epsilon * 100
          dwv.logger.warn(
            'Using even larger real world epsilon in SEG pos pat adding'
          );
        }
      }
    }
    return res;
  };

  // add possibly missing posPats
  var posPats = [];
  posPats.push(framePosPats[0]);
  var sliceIndex = 0;
  for (var g = 1; g < framePosPats.length; ++g) {
    ++sliceIndex;
    var index = new dwv.math.Index([0, 0, sliceIndex]);
    var point = tmpGeometry.indexToWorld(index).get3D();
    var frameOrigin = frameOrigins[g];
    // check if more pos pats are needed
    var dist = frameOrigin.getDistance(point);
    var distPrevious = dist;
    // TODO: good threshold?
    while (isNotSmall(dist)) {
      dwv.logger.debug('Adding intermediate pos pats for DICOM seg at ' +
        point.toString());
      posPats.push([point.getX(), point.getY(), point.getZ()]);
      ++sliceIndex;
      index = new dwv.math.Index([0, 0, sliceIndex]);
      point = tmpGeometry.indexToWorld(index).get3D();
      dist = frameOrigin.getDistance(point);
      if (dist > distPrevious) {
        throw new Error(
          'Test distance is increasing when adding intermediate pos pats');
      }
    }
    // add frame pos pat
    posPats.push(framePosPats[g]);
  }

  // as many slices as posPats
  var numberOfSlices = posPats.length;

  // final geometry
  var geometry = new dwv.image.Geometry(
    frameOrigins[0], size, newSpacing, orientationMatrix);
  var uids = [0];
  for (var m = 1; m < numberOfSlices; ++m) {
    geometry.appendOrigin(point3DFromArray(posPats[m]), m);
    uids.push(m);
  }

  var getFindSegmentFunc = function (number) {
    return function (item) {
      return item.number === number;
    };
  };

  // create output buffer
  var mul = storeAsRGB ? 3 : 1;
  var buffer = new pixelBuffer.constructor(mul * sliceSize * numberOfSlices);
  buffer.fill(0);
  // merge frame buffers
  var sliceOffset = null;
  var frameOffset = null;
  for (var f = 0; f < frameInfos.length; ++f) {
    // get the slice index from the position in the posPat array
    sliceIndex = findIndexPosPat(posPats, frameInfos[f].imagePosPat);
    frameOffset = sliceSize * f;
    sliceOffset = sliceSize * sliceIndex;
    // get the frame display value
    var frameSegment = segments.find(
      getFindSegmentFunc(frameInfos[f].refSegmentNumber)
    );
    var pixelValue = frameSegment.displayValue;
    for (var l = 0; l < sliceSize; ++l) {
      if (pixelBuffer[frameOffset + l] !== 0) {
        var offset = mul * (sliceOffset + l);
        if (storeAsRGB) {
          buffer[offset] = pixelValue.r;
          buffer[offset + 1] = pixelValue.g;
          buffer[offset + 2] = pixelValue.b;
        } else {
          buffer[offset] = pixelValue;
        }
      }
    }
  }

  // create image
  var image = new dwv.image.Image(geometry, buffer, uids);
  if (storeAsRGB) {
    image.setPhotometricInterpretation('RGB');
  }
  // meta information
  var meta = dwv.dicom.getDefaultDicomSegJson();
  // Study
  meta.StudyDate = dicomElements.getFromKey('x00080020');
  meta.StudyTime = dicomElements.getFromKey('x00080030');
  meta.StudyInstanceUID = dicomElements.getFromKey('x0020000D');
  meta.StudyID = dicomElements.getFromKey('x00200010');
  // Series
  meta.SeriesInstanceUID = dicomElements.getFromKey('x0020000E');
  meta.SeriesNumber = dicomElements.getFromKey('x00200011');
  // ReferringPhysicianName
  meta.ReferringPhysicianName = dicomElements.getFromKey('x00080090');
  // patient info
  meta.PatientName =
    dwv.dicom.cleanString(dicomElements.getFromKey('x00100010'));
  meta.PatientID = dwv.dicom.cleanString(dicomElements.getFromKey('x00100020'));
  meta.PatientBirthDate = dicomElements.getFromKey('x00100030');
  meta.PatientSex =
    dwv.dicom.cleanString(dicomElements.getFromKey('x00100040'));
  // Enhanced General Equipment Module
  meta.Manufacturer = dicomElements.getFromKey('x00080070');
  meta.ManufacturerModelName = dicomElements.getFromKey('x00081090');
  meta.DeviceSerialNumber = dicomElements.getFromKey('x00181000');
  meta.SoftwareVersions = dicomElements.getFromKey('x00181020');
  // dicom seg dimension
  meta.DimensionOrganizationSequence = dimension.organizations;
  meta.DimensionIndexSequence = dimension.indices;
  // custom
  meta.custom = {
    segments: segments,
    frameInfos: frameInfos,
    SOPInstanceUID: dicomElements.getFromKey('x00080018')
  };

  // number of files: in this case equal to number slices,
  //   used to calculate buffer size
  meta.numberOfFiles = numberOfSlices;
  // FrameOfReferenceUID (optional)
  var frameOfReferenceUID = dicomElements.getFromKey('x00200052');
  if (frameOfReferenceUID) {
    meta.FrameOfReferenceUID = frameOfReferenceUID;
  }
  // LossyImageCompression (optional)
  var lossyImageCompression = dicomElements.getFromKey('x00282110');
  if (lossyImageCompression) {
    meta.LossyImageCompression = lossyImageCompression;
  }

  image.setMeta(meta);

  return image;
};

// namespaces
var dwv = dwv || {};
dwv.image = dwv.image || {};

/**
 * Mask segment helper.
 *
 * @class
 * @param {object} mask The associated mask image.
 */
dwv.image.MaskSegmentHelper = function (mask) {

  /**
   * The segments: array of segment description.
   *
   * @private
   * @type {Array}
   */
  var segments = mask.getMeta().custom.segments;

  /**
   * List of ids of hidden segments.
   *
   * @private
   * @type {Array}
   */
  var hiddenSegments = [];

  /**
   * Check if a segment is part of the inner segment list.
   *
   * @param {number} segmentNumber The segment number.
   * @returns {boolean} True if the segment is included.
   */
  this.hasSegment = function (segmentNumber) {
    return typeof this.getSegment(segmentNumber) !== 'undefined';
  };

  /**
   * Check if a segment is present in a mask image.
   *
   * @param {Array} numbers Array of segment numbers.
   * @returns {Array} Array of boolean set to true
   *   if the segment is present in the mask.
   */
  this.maskHasSegments = function (numbers) {
    // create values using displayValue
    var values = [];
    var unknowns = [];
    for (var i = 0; i < numbers.length; ++i) {
      var segment = this.getSegment(numbers[i]);
      if (typeof segment !== 'undefined') {
        values.push(segment.displayValue);
      } else {
        dwv.logger.warn('Unknown segment in maskHasSegments: ' + numbers[i]);
        unknowns.push(i);
      }
    }
    var res = mask.hasValues(values);
    // insert unknowns as false in result
    for (var j = 0; j < unknowns.length; ++j) {
      res.splice(unknowns[j], 0, false);
    }
    return res;
  };

  /**
   * Get a segment from the inner segment list.
   *
   * @param {number} segmentNumber The segment number.
   * @returns {object} The segment.
   */
  this.getSegment = function (segmentNumber) {
    return segments.find(function (item) {
      return item.number === segmentNumber;
    });
  };

  /**
   * Get the inner segment list.
   *
   * @returns {Array} The list of segments.
   */
  this.getSegments = function () {
    return segments;
  };

  /**
   * Set the inner segment list.
   *
   * @param {Array} list The segment list.
   */
  this.setSegments = function (list) {
    segments = list;
  };

  /**
   * Set the hidden segment list.
   * TODO: not sure if needed...
   *
   * @param {Array} list The list of hidden segment numbers.
   */
  this.setHiddenSegments = function (list) {
    hiddenSegments = list;
  };

  /**
   * Get the index of a segment in the hidden list.
   *
   * @param {number} segmentNumber The segment number.
   * @returns {number|undefined} The index in the array.
   */
  function getHiddenIndex(segmentNumber) {
    return hiddenSegments.findIndex(function (item) {
      return item === segmentNumber;
    });
  }

  /**
   * Check if a segment is in the hidden list.
   *
   * @param {number} segmentNumber The segment number.
   * @returns {boolean} True if the segment is in the list.
   */
  this.isHidden = function (segmentNumber) {
    return getHiddenIndex(segmentNumber) !== -1;
  };

  /**
   * Add a segment to the hidden list.
   *
   * @param {number} segmentNumber The segment number.
   */
  this.addToHidden = function (segmentNumber) {
    if (!this.isHidden(segmentNumber)) {
      hiddenSegments.push(segmentNumber);
    } else {
      dwv.logger.warn(
        'Segment is allready in the hidden list: ' + segmentNumber);
    }
  };

  /**
   * Remove a segment from the hidden list.
   *
   * @param {number} segmentNumber The segment number.
   */
  this.removeFromHidden = function (segmentNumber) {
    var index = getHiddenIndex(segmentNumber);
    if (index !== -1) {
      hiddenSegments.splice(index, 1);
    } else {
      dwv.logger.warn('Segment is not in the hidden list: ' + segmentNumber);
    }
  };

  /**
   * Get the alpha function to apply hidden colors.
   *
   * @returns {Function} The corresponding alpha function.
   */
  this.getAlphaFunc = function () {
    // get colours
    var hiddenColours = [{r: 0, g: 0, b: 0}];
    for (var i = 0; i < hiddenSegments.length; ++i) {
      var segment = this.getSegment(hiddenSegments[i]);
      if (typeof segment !== 'undefined') {
        hiddenColours.push(segment.displayValue);
      }
    }

    // create alpha function
    return function (value/*, index*/) {
      for (var i = 0; i < hiddenColours.length; ++i) {
        if (value[0] === hiddenColours[i].r &&
          value[1] === hiddenColours[i].g &&
          value[2] === hiddenColours[i].b) {
          return 0;
        }
      }
      // default
      return 255;
    };
  };

  /**
   * Delete a segment.
   *
   * @param {number} segmentNumber The segment number.
   * @param {Function} cmdCallback The command event callback.
   * @param {Function} exeCallback The post execution callback.
   */
  this.deleteSegment = function (segmentNumber, cmdCallback, exeCallback) {
    var delcmd = new dwv.image.DeleteSegmentCommand(
      mask, this.getSegment(segmentNumber));
    delcmd.onExecute = cmdCallback;
    delcmd.onUndo = cmdCallback;
    if (delcmd.isValid()) {
      delcmd.execute();
      // callback
      exeCallback(delcmd);
      // possibly hidden
      if (this.isHidden(segmentNumber)) {
        this.removeFromHidden(segmentNumber);
      }
    }
  };
};

/**
 * Delete segment command.
 *
 * @param {object} mask The mask image.
 * @param {object} segment The segment to remove.
 * @param {boolean} silent Whether to send a creation event or not.
 * @class
 */
dwv.image.DeleteSegmentCommand = function (mask, segment, silent) {
  var isSilent = (typeof silent === 'undefined') ? false : silent;

  // list of offsets with the colour to delete
  var offsets = mask.getOffsets(segment.displayValue);

  /**
   * Get the command name.
   *
   * @returns {string} The command name.
   */
  this.getName = function () {
    return 'Delete-segment';
  };

  /**
   * Check if a command is valid and can be executed.
   *
   * @returns {boolean} True if the command is valid.
   */
  this.isValid = function () {
    return offsets.length !== 0;
  };

  /**
   * Execute the command.
   *
   * @fires dwv.image.DeleteSegmentCommand#masksegmentdelete
   */
  this.execute = function () {
    // remove
    mask.setAtOffsets(offsets, {r: 0, g: 0, b: 0});

    // callback
    if (!isSilent) {
      /**
       * Segment delete event.
       *
       * @event dwv.image.DeleteSegmentCommand#masksegmentdelete
       * @type {object}
       * @property {number} segmentnumber The segment number.
       */
      this.onExecute({
        type: 'masksegmentdelete',
        segmentnumber: segment.number
      });
    }
  };

  /**
   * Undo the command.
   *
   * @fires dwv.image.DeleteSegmentCommand#masksegmentredraw
   */
  this.undo = function () {
    // re-draw
    mask.setAtOffsets(offsets, segment.displayValue);

    // callback
    /**
     * Segment redraw event.
     *
     * @event dwv.image.DeleteSegmentCommand#masksegmentredraw
     * @type {object}
     * @property {number} segmentnumber The segment number.
     */
    this.onUndo({
      type: 'masksegmentredraw',
      segmentnumber: segment.number
    });
  };
}; // DeleteSegmentCommand class

/**
 * Handle an execute event.
 *
 * @param {object} _event The execute event with type and id.
 */
dwv.image.DeleteSegmentCommand.prototype.onExecute = function (_event) {
  // default does nothing.
};
/**
 * Handle an undo event.
 *
 * @param {object} _event The undo event with type and id.
 */
dwv.image.DeleteSegmentCommand.prototype.onUndo = function (_event) {
  // default does nothing.
};
// namespaces
var dwv = dwv || {};
dwv.image = dwv.image || {};

/**
 * Plane geometry helper.
 *
 * @class
 * @param {dwv.image.Spacing} spacing The spacing.
 * @param {dwv.math.Matrix} imageOrientation The image oientation.
 * @param {dwv.math.Matrix} viewOrientation The view orientation.
 */
dwv.image.PlaneHelper = function (spacing, imageOrientation, viewOrientation) {

  var targetOrientation = dwv.gui.getTargetOrientation(
    imageOrientation, viewOrientation);

  /**
   * Get a 3D offset from a plane one.
   *
   * @param {object} offset2D The plane offset as {x,y}.
   * @returns {dwv.math.Vector3D} The 3D world offset.
   */
  this.getOffset3DFromPlaneOffset = function (offset2D) {
    // make 3D
    var planeOffset = new dwv.math.Vector3D(
      offset2D.x, offset2D.y, 0);
    // de-orient
    var pixelOffset = this.getTargetDeOrientedVector3D(planeOffset);
    // ~indexToWorld
    return new dwv.math.Vector3D(
      pixelOffset.getX() * spacing.get(0),
      pixelOffset.getY() * spacing.get(1),
      pixelOffset.getZ() * spacing.get(2));
  };

  /**
   * Get a plane offset from a 3D one.
   *
   * @param {object} offset3D The 3D offset as {x,y,z}.
   * @returns {object} The plane offset as {x,y}.
   */
  this.getPlaneOffsetFromOffset3D = function (offset3D) {
    // ~worldToIndex
    var pixelOffset = new dwv.math.Vector3D(
      offset3D.x / spacing.get(0),
      offset3D.y / spacing.get(1),
      offset3D.z / spacing.get(2));
    // orient
    var planeOffset = this.getTargetOrientedVector3D(pixelOffset);
    // make 2D
    return {
      x: planeOffset.getX(),
      y: planeOffset.getY()
    };
  };

  /**
   * Orient an input vector from real to target space.
   *
   * @param {dwv.math.Vector3D} vector The input vector.
   * @returns {dwv.math.Vector3D} The oriented vector.
   */
  this.getTargetOrientedVector3D = function (vector) {
    var planeVector = vector;
    if (typeof targetOrientation !== 'undefined') {
      planeVector = targetOrientation.getInverse().multiplyVector3D(vector);
    }
    return planeVector;
  };

  /**
   * De-orient an input vector from target to real space.
   *
   * @param {dwv.math.Vector3D} planeVector The input vector.
   * @returns {dwv.math.Vector3D} The de-orienteded vector.
   */
  this.getTargetDeOrientedVector3D = function (planeVector) {
    var vector = planeVector;
    if (typeof targetOrientation !== 'undefined') {
      vector = targetOrientation.multiplyVector3D(planeVector);
    }
    return vector;
  };

  /**
   * Orient an input vector from target to image space.
   * WARN: returns absolute values...
   * TODO: check why abs is needed...
   *
   * @param {dwv.math.Vector3D} planeVector The input vector.
   * @returns {dwv.math.Vector3D} The orienteded vector.
   */
  this.getImageOrientedVector3D = function (planeVector) {
    var vector = planeVector;
    if (typeof viewOrientation !== 'undefined') {
      // image oriented => view de-oriented
      var values = dwv.image.getDeOrientedArray3D(
        [
          planeVector.getX(),
          planeVector.getY(),
          planeVector.getZ()
        ],
        viewOrientation);
      vector = new dwv.math.Vector3D(
        values[0],
        values[1],
        values[2]
      );
    }
    return vector;
  };

  /**
   * De-orient an input vector from image to target space.
   * WARN: returns absolute values...
   * TODO: check why abs is needed...
   *
   * @param {dwv.math.Vector3D} vector The input vector.
   * @returns {dwv.math.Vector3D} The de-orienteded vector.
   */
  this.getImageDeOrientedVector3D = function (vector) {
    var planeVector = vector;
    if (typeof viewOrientation !== 'undefined') {
      // image de-oriented => view oriented
      var orientedValues = dwv.image.getOrientedArray3D(
        [
          vector.getX(),
          vector.getY(),
          vector.getZ()
        ],
        viewOrientation);
      planeVector = new dwv.math.Vector3D(
        orientedValues[0],
        orientedValues[1],
        orientedValues[2]
      );
    }
    return planeVector;
  };

  /**
   * Reorder values to follow target orientation.
   * WARN: returns absolute values...
   * TODO: check why abs is needed...
   *
   * @param {object} values Values as {x,y,z}.
   * @returns {object} Reoriented values as {x,y,z}.
   */
  this.getTargetOrientedPositiveXYZ = function (values) {
    var orientedValues = dwv.image.getOrientedArray3D(
      [
        values.x,
        values.y,
        values.z
      ],
      targetOrientation);
    return {
      x: orientedValues[0],
      y: orientedValues[1],
      z: orientedValues[2]
    };
  };

  /**
   * Get the (view) scroll dimension index.
   *
   * @returns {number} The index.
   */
  this.getScrollIndex = function () {
    var index = null;
    if (typeof viewOrientation !== 'undefined') {
      index = viewOrientation.getThirdColMajorDirection();
    } else {
      index = 2;
    }
    return index;
  };

  /**
   * Get the native (image) scroll dimension index.
   *
   * @returns {number} The index.
   */
  this.getNativeScrollIndex = function () {
    var index = null;
    if (typeof imageOrientation !== 'undefined') {
      index = imageOrientation.getThirdColMajorDirection();
    } else {
      index = 2;
    }
    return index;
  };

};

// namespaces
var dwv = dwv || {};
dwv.image = dwv.image || {};

/**
 * Rescale LUT class.
 * Typically converts from integer to float.
 *
 * @class
 * @param {object} rsi The rescale slope and intercept.
 * @param {number} bitsStored The number of bits used to store the data.
 */
dwv.image.RescaleLut = function (rsi, bitsStored) {
  /**
   * The internal array.
   *
   * @private
   * @type {Float32Array}
   */
  var lut = null;

  /**
   * Flag to know if the lut is ready or not.
   *
   * @private
   * @type {boolean}
   */
  var isReady = false;

  /**
   * The size of the LUT array.
   *
   * @private
   * @type {number}
   */
  var length = Math.pow(2, bitsStored);

  /**
   * Get the Rescale Slope and Intercept (RSI).
   *
   * @returns {object} The rescale slope and intercept object.
   */
  this.getRSI = function () {
    return rsi;
  };

  /**
   * Is the lut ready to use or not? If not, the user must
   * call 'initialise'.
   *
   * @returns {boolean} True if the lut is ready to use.
   */
  this.isReady = function () {
    return isReady;
  };

  /**
   * Initialise the LUT.
   */
  this.initialise = function () {
    // check if already initialised
    if (isReady) {
      return;
    }
    // create lut and fill it
    lut = new Float32Array(length);
    for (var i = 0; i < length; ++i) {
      lut[i] = rsi.apply(i);
    }
    // update ready flag
    isReady = true;
  };

  /**
   * Get the length of the LUT array.
   *
   * @returns {number} The length of the LUT array.
   */
  this.getLength = function () {
    return length;
  };

  /**
   * Get the value of the LUT at the given offset.
   *
   * @param {number} offset The input offset in [0,2^bitsStored] range.
   * @returns {number} The float32 value of the LUT at the given offset.
   */
  this.getValue = function (offset) {
    return lut[offset];
  };
};

// namespaces
var dwv = dwv || {};
dwv.image = dwv.image || {};

/**
 * Rescale Slope and Intercept
 *
 * @class
 * @param {number} slope The slope of the RSI.
 * @param {number} intercept The intercept of the RSI.
 */
dwv.image.RescaleSlopeAndIntercept = function (slope, intercept) {
  /*// Check the rescale slope.
    if(typeof(slope) === 'undefined') {
        slope = 1;
    }
    // Check the rescale intercept.
    if(typeof(intercept) === 'undefined') {
        intercept = 0;
    }*/

  /**
   * Get the slope of the RSI.
   *
   * @returns {number} The slope of the RSI.
   */
  this.getSlope = function () {
    return slope;
  };

  /**
   * Get the intercept of the RSI.
   *
   * @returns {number} The intercept of the RSI.
   */
  this.getIntercept = function () {
    return intercept;
  };

  /**
   * Apply the RSI on an input value.
   *
   * @param {number} value The input value.
   * @returns {number} The value to rescale.
   */
  this.apply = function (value) {
    return value * slope + intercept;
  };
};

/**
 * Check for RSI equality.
 *
 * @param {object} rhs The other RSI to compare to.
 * @returns {boolean} True if both RSI are equal.
 */
dwv.image.RescaleSlopeAndIntercept.prototype.equals = function (rhs) {
  return rhs !== null &&
        this.getSlope() === rhs.getSlope() &&
        this.getIntercept() === rhs.getIntercept();
};

/**
 * Get a string representation of the RSI.
 *
 * @returns {string} The RSI as a string.
 */
dwv.image.RescaleSlopeAndIntercept.prototype.toString = function () {
  return (this.getSlope() + ', ' + this.getIntercept());
};

/**
 * Is this RSI an ID RSI.
 *
 * @returns {boolean} True if the RSI has a slope of 1 and no intercept.
 */
dwv.image.RescaleSlopeAndIntercept.prototype.isID = function () {
  return (this.getSlope() === 1 && this.getIntercept() === 0);
};

// namespaces
var dwv = dwv || {};
dwv.image = dwv.image || {};

/**
 * Immutable Size class.
 * Warning: the input array is NOT cloned, modifying it will
 *  modify the index values.
 *
 * @class
 * @param {Array} values The size values.
 */
dwv.image.Size = function (values) {
  if (!values || typeof values === 'undefined') {
    throw new Error('Cannot create size with no values.');
  }
  if (values.length === 0) {
    throw new Error('Cannot create size with empty values.');
  }
  var valueCheck = function (val) {
    return !isNaN(val) && val !== 0;
  };
  if (!values.every(valueCheck)) {
    throw new Error('Cannot create size with non number or zero values.');
  }

  /**
   * Get the size value at the given array index.
   *
   * @param {number} i The index to get.
   * @returns {number} The value.
   */
  this.get = function (i) {
    return values[i];
  };

  /**
   * Get the length of the index.
   *
   * @returns {number} The length.
   */
  this.length = function () {
    return values.length;
  };

  /**
   * Get a string representation of the size.
   *
   * @returns {string} The Size as a string.
   */
  this.toString = function () {
    return '(' + values.toString() + ')';
  };

  /**
   * Get the values of this index.
   *
   * @returns {Array} The array of values.
   */
  this.getValues = function () {
    return values.slice();
  };

}; // Size class

/**
 * Check if a dimension exists and has more than one element.
 *
 * @param {number} dimension The dimension to check.
 * @returns {boolean} True if the size is more than one.
 */
dwv.image.Size.prototype.moreThanOne = function (dimension) {
  return this.length() >= dimension + 1 && this.get(dimension) !== 1;
};

/**
 * Check if the associated data is scrollable in 3D.
 *
 * @param {dwv.math.Matrix33} viewOrientation The orientation matrix.
 * @returns {boolean} True if scrollable.
 */
dwv.image.Size.prototype.canScroll3D = function (viewOrientation) {
  var dimension = 2;
  if (typeof viewOrientation !== 'undefined') {
    dimension = viewOrientation.getThirdColMajorDirection();
  }
  return this.moreThanOne(dimension);
};

/**
 * Check if the associated data is scrollable: either in 3D or
 * in other directions.
 *
 * @param {dwv.math.Matrix33} viewOrientation The orientation matrix.
 * @returns {boolean} True if scrollable.
 */
dwv.image.Size.prototype.canScroll = function (viewOrientation) {
  var canScroll = this.canScroll3D(viewOrientation);
  // check possible other dimensions
  for (var i = 3; i < this.length(); ++i) {
    canScroll = canScroll || this.moreThanOne(i);
  }
  return canScroll;
};

/**
 * Get the size of a given dimension.
 *
 * @param {number} dimension The dimension.
 * @param {number} start Optional start dimension to start counting from.
 * @returns {number} The size.
 */
dwv.image.Size.prototype.getDimSize = function (dimension, start) {
  if (dimension > this.length()) {
    return null;
  }
  if (typeof start === 'undefined') {
    start = 0;
  } else {
    if (start < 0 || start > dimension) {
      throw new Error('Invalid start value for getDimSize');
    }
  }
  var size = 1;
  for (var i = start; i < dimension; ++i) {
    size *= this.get(i);
  }
  return size;
};

/**
 * Get the total size.
 *
 * @param {number} start Optional start dimension to base the offset on.
 * @returns {number} The total size.
 */
dwv.image.Size.prototype.getTotalSize = function (start) {
  return this.getDimSize(this.length(), start);
};

/**
 * Check for equality.
 *
 * @param {dwv.image.Size} rhs The object to compare to.
 * @returns {boolean} True if both objects are equal.
 */
dwv.image.Size.prototype.equals = function (rhs) {
  // check input
  if (!rhs) {
    return false;
  }
  // check length
  var length = this.length();
  if (length !== rhs.length()) {
    return false;
  }
  // check values
  for (var i = 0; i < length; ++i) {
    if (this.get(i) !== rhs.get(i)) {
      return false;
    }
  }
  // seems ok!
  return true;
};

/**
 * Check that an index is within bounds.
 *
 * @param {dwv.math.Index} index The index to check.
 * @param {Array} dirs Optional list of directions to check.
 * @returns {boolean} True if the given coordinates are within bounds.
 */
dwv.image.Size.prototype.isInBounds = function (index, dirs) {
  // check input
  if (!index) {
    return false;
  }
  // check length
  var length = this.length();
  if (length !== index.length()) {
    return false;
  }
  // create dirs if not there
  if (typeof dirs === 'undefined') {
    dirs = [];
    for (var j = 0; j < length; ++j) {
      dirs.push(j);
    }
  } else {
    for (var k = 0; k < length; ++k) {
      if (dirs[k] > length - 1) {
        throw new Error('Wrong input dir value: ' + dirs[k]);
      }
    }
  }
  // check values is 0 <= v < size
  var inBound = function (value, size) {
    return value >= 0 && value < size;
  };
  // check
  for (var i = 0; i < dirs.length; ++i) {
    if (!inBound(index.get(dirs[i]), this.get(dirs[i]))) {
      return false;
    }
  }
  // seems ok!
  return true;
};

/**
 * Convert an index to an offset in memory.
 *
 * @param {dwv.math.Index} index The index to convert.
 * @param {number} start Optional start dimension to base the offset on.
 * @returns {number} The offset.
 */
dwv.image.Size.prototype.indexToOffset = function (index, start) {
  // TODO check for equality
  if (index.length() < this.length()) {
    throw new Error('Incompatible index and size length');
  }
  if (typeof start === 'undefined') {
    start = 0;
  } else {
    if (start < 0 || start > this.length() - 1) {
      throw new Error('Invalid start value for indexToOffset');
    }
  }
  var offset = 0;
  for (var i = start; i < this.length(); ++i) {
    offset += index.get(i) * this.getDimSize(i, start);
  }
  return offset;
};

/**
 * Convert an offset in memory to an index.
 *
 * @param {number} offset The offset to convert.
 * @returns {dwv.math.Index} The index.
 */
dwv.image.Size.prototype.offsetToIndex = function (offset) {
  var values = new Array(this.length());
  var off = offset;
  var dimSize = 0;
  for (var i = this.length() - 1; i > 0; --i) {
    dimSize = this.getDimSize(i);
    values[i] = Math.floor(off / dimSize);
    off = off - values[i] * dimSize;
  }
  values[0] = off;
  return new dwv.math.Index(values);
};

/**
 * Get the 2D base of this size.
 *
 * @returns {object} The 2D base [0,1] as {x,y}.
 */
dwv.image.Size.prototype.get2D = function () {
  return {
    x: this.get(0),
    y: this.get(1)
  };
};

// namespaces
var dwv = dwv || {};
dwv.image = dwv.image || {};

/**
 * Immutable Spacing class.
 * Warning: the input array is NOT cloned, modifying it will
 *  modify the index values.
 *
 * @class
 * @param {Array} values The size values.
 */
dwv.image.Spacing = function (values) {
  if (!values || typeof values === 'undefined') {
    throw new Error('Cannot create spacing with no values.');
  }
  if (values.length === 0) {
    throw new Error('Cannot create spacing with empty values.');
  }
  var valueCheck = function (val) {
    return !isNaN(val) && val !== 0;
  };
  if (!values.every(valueCheck)) {
    throw new Error('Cannot create spacing with non number or zero values.');
  }

  /**
   * Get the spacing value at the given array index.
   *
   * @param {number} i The index to get.
   * @returns {number} The value.
   */
  this.get = function (i) {
    return values[i];
  };

  /**
   * Get the length of the spacing.
   *
   * @returns {number} The length.
   */
  this.length = function () {
    return values.length;
  };

  /**
   * Get a string representation of the spacing.
   *
   * @returns {string} The spacing as a string.
   */
  this.toString = function () {
    return '(' + values.toString() + ')';
  };

  /**
   * Get the values of this spacing.
   *
   * @returns {Array} The array of values.
   */
  this.getValues = function () {
    return values.slice();
  };

}; // Spacing class

/**
 * Check for equality.
 *
 * @param {dwv.image.Spacing} rhs The object to compare to.
 * @returns {boolean} True if both objects are equal.
 */
dwv.image.Spacing.prototype.equals = function (rhs) {
  // check input
  if (!rhs) {
    return false;
  }
  // check length
  var length = this.length();
  if (length !== rhs.length()) {
    return false;
  }
  // check values
  for (var i = 0; i < length; ++i) {
    if (this.get(i) !== rhs.get(i)) {
      return false;
    }
  }
  // seems ok!
  return true;
};

/**
 * Get the 2D base of this size.
 *
 * @returns {object} The 2D base [col,row] as {x,y}.
 */
dwv.image.Spacing.prototype.get2D = function () {
  return {
    x: this.get(0),
    y: this.get(1)
  };
};

// namespaces
var dwv = dwv || {};
dwv.image = dwv.image || {};

/**
 * List of view event names.
 *
 * @type {Array}
 */
dwv.image.viewEventNames = [
  'wlchange',
  'wlpresetadd',
  'colourchange',
  'positionchange',
  'opacitychange',
  'alphafuncchange'
];

/**
 * View class.
 *
 * @class
 * @param {Image} image The associated image.
 * Need to set the window lookup table once created
 * (either directly or with helper methods).
 */
dwv.image.View = function (image) {
  // closure to self
  var self = this;

  // listen to appendframe event to update the current position
  //   to add the extra dimension
  image.addEventListener('appendframe', function () {
    // update current position if first appendFrame
    var index = self.getCurrentIndex();
    if (index.length() === 3) {
      // add dimension
      var values = index.getValues();
      values.push(0);
      self.setCurrentIndex(new dwv.math.Index(values));
    }
  });

  /**
   * Window lookup tables, indexed per Rescale Slope and Intercept (RSI).
   *
   * @private
   * @type {Window}
   */
  var windowLuts = {};

  /**
   * Window presets.
   * Minmax will be filled at first use (see view.setWindowLevelPreset).
   *
   * @private
   * @type {object}
   */
  var windowPresets = {minmax: {name: 'minmax'}};

  /**
   * Current window preset name.
   *
   * @private
   * @type {string}
   */
  var currentPresetName = null;

  /**
   * Current window level.
   *
   * @private
   * @type {object}
   */
  var currentWl = null;

  /**
   * colour map.
   *
   * @private
   * @type {object}
   */
  var colourMap = dwv.image.lut.plain;
  /**
   * Current position as a Point3D.
   * Store position and not index to stay geometry independent.
   *
   * @private
   * @type {dwv.math.Point3D}
   */
  var currentPosition = null;
  /**
   * View orientation. Undefined will use the original slice ordering.
   *
   * @private
   * @type {object}
   */
  var orientation;

  /**
   * Listener handler.
   *
   * @type {object}
   * @private
   */
  var listenerHandler = new dwv.utils.ListenerHandler();

  /**
   * Get the associated image.
   *
   * @returns {Image} The associated image.
   */
  this.getImage = function () {
    return image;
  };
  /**
   * Set the associated image.
   *
   * @param {Image} inImage The associated image.
   */
  this.setImage = function (inImage) {
    image = inImage;
  };

  /**
   * Get the view orientation.
   *
   * @returns {dwv.math.Matrix33} The orientation matrix.
   */
  this.getOrientation = function () {
    return orientation;
  };

  /**
   * Set the view orientation.
   *
   * @param {dwv.math.Matrix33} mat33 The orientation matrix.
   */
  this.setOrientation = function (mat33) {
    orientation = mat33;
  };

  /**
   * Initialise the view: set initial index.
   */
  this.init = function () {
    this.setInitialIndex();
  };

  /**
   * Set the initial index to 0.
   */
  this.setInitialIndex = function () {
    var geometry = image.getGeometry();
    var size = geometry.getSize();
    var values = new Array(size.length());
    values.fill(0);
    // middle
    values[0] = Math.floor(size.get(0) / 2);
    values[1] = Math.floor(size.get(1) / 2);
    values[2] = Math.floor(size.get(2) / 2);
    this.setCurrentIndex(new dwv.math.Index(values), true);
  };

  /**
   * Get the milliseconds per frame from frame rate.
   *
   * @param {number} recommendedDisplayFrameRate Recommended Display Frame Rate.
   * @returns {number} The milliseconds per frame.
   */
  this.getPlaybackMilliseconds = function (recommendedDisplayFrameRate) {
    if (!recommendedDisplayFrameRate) {
      // Default to 10 FPS if none is found in the meta
      recommendedDisplayFrameRate = 10;
    }
    // round milliseconds per frame to nearest whole number
    return Math.round(1000 / recommendedDisplayFrameRate);
  };

  /**
   * Per value alpha function.
   *
   * @param {*} _value The pixel value. Can be a number for monochrome
   *  data or an array for RGB data.
   * @param {number} _index The data index of the value.
   * @returns {number} The coresponding alpha [0,255].
   */
  var alphaFunction = function (_value, _index) {
    // default always returns fully visible
    return 0xff;
  };

  /**
   * Get the alpha function.
   *
   * @returns {Function} The function.
   */
  this.getAlphaFunction = function () {
    return alphaFunction;
  };

  /**
   * Set alpha function.
   *
   * @param {Function} func The function.
   * @fires dwv.image.View#alphafuncchange
   */
  this.setAlphaFunction = function (func) {
    alphaFunction = func;
    /**
     * Alpha func change event.
     *
     * @event dwv.image.View#alphafuncchange
     * @type {object}
     */
    fireEvent({
      type: 'alphafuncchange'
    });
  };

  /**
   * Get the window LUT of the image.
   * Warning: can be undefined in no window/level was set.
   *
   * @param {object} rsi Optional image rsi, will take the one of the
   *   current slice otherwise.
   * @returns {Window} The window LUT of the image.
   * @fires dwv.image.View#wlchange
   */
  this.getCurrentWindowLut = function (rsi) {
    // check position
    if (!this.getCurrentIndex()) {
      this.setInitialIndex();
    }
    var currentIndex = this.getCurrentIndex();
    // use current rsi if not provided
    if (typeof rsi === 'undefined') {
      rsi = image.getRescaleSlopeAndIntercept(currentIndex);
    }

    // get the current window level
    var wl = null;
    // special case for 'perslice' presets
    if (currentPresetName &&
      typeof windowPresets[currentPresetName] !== 'undefined' &&
      typeof windowPresets[currentPresetName].perslice !== 'undefined' &&
      windowPresets[currentPresetName].perslice === true) {
      // get the preset for this slice
      var offset = image.getSecondaryOffset(currentIndex);
      wl = windowPresets[currentPresetName].wl[offset];
    }
    // regular case
    if (!wl) {
      // if no current, use first id
      if (!currentWl) {
        this.setWindowLevelPresetById(0, true);
      }
      wl = currentWl;
    }

    // get the window lut
    var wlut = windowLuts[rsi.toString()];
    if (typeof wlut === 'undefined') {
      // create the rescale lookup table
      var rescaleLut = new dwv.image.RescaleLut(
        image.getRescaleSlopeAndIntercept(0), image.getMeta().BitsStored);
      // create the window lookup table
      var windowLut = new dwv.image.WindowLut(
        rescaleLut, image.getMeta().IsSigned);
      // store
      this.addWindowLut(windowLut);
      wlut = windowLut;
    }

    // update lut window level if not present or different from previous
    var lutWl = wlut.getWindowLevel();
    if (!wl.equals(lutWl)) {
      // set lut window level
      wlut.setWindowLevel(wl);
      wlut.update();
      // fire change event
      if (!lutWl ||
        lutWl.getWidth() !== wl.getWidth() ||
        lutWl.getCenter() !== wl.getCenter()) {
        fireEvent({
          type: 'wlchange',
          value: [wl.getCenter(), wl.getWidth()],
          wc: wl.getCenter(),
          ww: wl.getWidth(),
          skipGenerate: true
        });
      }
    }

    // return
    return wlut;
  };
  /**
   * Add the window LUT to the list.
   *
   * @param {Window} wlut The window LUT of the image.
   */
  this.addWindowLut = function (wlut) {
    var rsi = wlut.getRescaleLut().getRSI();
    windowLuts[rsi.toString()] = wlut;
  };

  /**
   * Get the window presets.
   *
   * @returns {object} The window presets.
   */
  this.getWindowPresets = function () {
    return windowPresets;
  };

  /**
   * Get the window presets names.
   *
   * @returns {object} The list of window presets names.
   */
  this.getWindowPresetsNames = function () {
    return Object.keys(windowPresets);
  };

  /**
   * Set the window presets.
   *
   * @param {object} presets The window presets.
   */
  this.setWindowPresets = function (presets) {
    windowPresets = presets;
  };

  /**
   * Set the default colour map.
   *
   * @param {object} map The colour map.
   */
  this.setDefaultColourMap = function (map) {
    colourMap = map;
  };

  /**
   * Add window presets to the existing ones.
   *
   * @param {object} presets The window presets.
   */
  this.addWindowPresets = function (presets) {
    var keys = Object.keys(presets);
    var key = null;
    for (var i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (typeof windowPresets[key] !== 'undefined') {
        if (typeof windowPresets[key].perslice !== 'undefined' &&
          windowPresets[key].perslice === true) {
          throw new Error('Cannot add perslice preset');
        } else {
          windowPresets[key] = presets[key];
        }
      } else {
        // add new
        windowPresets[key] = presets[key];
        // fire event
        /**
         * Window/level add preset event.
         *
         * @event dwv.image.View#wlpresetadd
         * @type {object}
         * @property {string} name The name of the preset.
         */
        fireEvent({
          type: 'wlpresetadd',
          name: key
        });
      }
    }
  };

  /**
   * Get the colour map of the image.
   *
   * @returns {object} The colour map of the image.
   */
  this.getColourMap = function () {
    return colourMap;
  };
  /**
   * Set the colour map of the image.
   *
   * @param {object} map The colour map of the image.
   * @fires dwv.image.View#colourchange
   */
  this.setColourMap = function (map) {
    colourMap = map;
    /**
     * Color change event.
     *
     * @event dwv.image.View#colourchange
     * @type {object}
     * @property {Array} value The changed value.
     * @property {number} wc The new window center value.
     * @property {number} ww The new window wdth value.
     */
    fireEvent({
      type: 'colourchange',
      wc: this.getCurrentWindowLut().getWindowLevel().getCenter(),
      ww: this.getCurrentWindowLut().getWindowLevel().getWidth()
    });
  };

  /**
   * Get the current position.
   *
   * @returns {dwv.math.Point} The current position.
   */
  this.getCurrentPosition = function () {
    return currentPosition;
  };

  /**
   * Get the current index.
   *
   * @returns {dwv.math.Index} The current index.
   */
  this.getCurrentIndex = function () {
    var position = this.getCurrentPosition();
    if (!position) {
      return null;
    }
    var geometry = this.getImage().getGeometry();
    return geometry.worldToIndex(position);
  };

  /**
   * Check is the provided position can be set.
   *
   * @param {dwv.math.Point} position The position.
   * @returns {boolean} True is the position is in bounds.
   */
  this.canSetPosition = function (position) {
    var geometry = image.getGeometry();
    var index = geometry.worldToIndex(position);
    var dirs = [this.getScrollIndex()];
    if (index.length() === 4) {
      dirs.push(3);
    }
    return geometry.isIndexInBounds(index, dirs);
  };

  /**
   * Get the origin at a given position.
   *
   * @param {dwv.math.Point} position The position.
   * @returns {dwv.math.Point} The origin.
   */
  this.getOrigin = function (position) {
    var geometry = image.getGeometry();
    var originIndex = 0;
    if (typeof position !== 'undefined') {
      var index = geometry.worldToIndex(position);
      // index is reoriented, 2 is scroll index
      originIndex = index.get(2);
    }
    return geometry.getOrigins()[originIndex];
  };

  /**
   * Set the current position.
   *
   * @param {dwv.math.Point} position The new position.
   * @param {boolean} silent Flag to fire event or not.
   * @returns {boolean} False if not in bounds
   * @fires dwv.image.View#positionchange
   */
  this.setCurrentPosition = function (position, silent) {
    // send invalid event if not in bounds
    var geometry = image.getGeometry();
    var index = geometry.worldToIndex(position);
    var dirs = [this.getScrollIndex()];
    if (index.length() === 4) {
      dirs.push(3);
    }
    if (!geometry.isIndexInBounds(index, dirs)) {
      if (!silent) {
        // fire event with valid: false
        fireEvent({
          type: 'positionchange',
          value: [
            index.getValues(),
            position.getValues(),
          ],
          valid: false
        });
      }
      return false;
    }
    return this.setCurrentIndex(index, silent);
  };

  /**
   * Set the current index.
   *
   * @param {dwv.math.Index} index The new index.
   * @param {boolean} silent Flag to fire event or not.
   * @returns {boolean} False if not in bounds.
   * @fires dwv.image.View#positionchange
   */
  this.setCurrentIndex = function (index, silent) {
    // check input
    if (typeof silent === 'undefined') {
      silent = false;
    }

    var geometry = image.getGeometry();
    var position = geometry.indexToWorld(index);

    // check if possible
    var dirs = [this.getScrollIndex()];
    if (index.length() === 4) {
      dirs.push(3);
    }
    if (!geometry.isIndexInBounds(index, dirs)) {
      // do no send invalid positionchange event: avoid empty repaint
      return false;
    }

    // calculate diff dims before updating internal
    var diffDims = null;
    var currentIndex = null;
    if (this.getCurrentPosition()) {
      currentIndex = this.getCurrentIndex();
    }
    if (currentIndex) {
      if (currentIndex.canCompare(index)) {
        diffDims = currentIndex.compare(index);
      } else {
        diffDims = [];
        var minLen = Math.min(currentIndex.length(), index.length());
        for (var i = 0; i < minLen; ++i) {
          if (currentIndex.get(i) !== index.get(i)) {
            diffDims.push(i);
          }
        }
        var maxLen = Math.max(currentIndex.length(), index.length());
        for (var j = minLen; j < maxLen; ++j) {
          diffDims.push(j);
        }
      }
    } else {
      diffDims = [];
      for (var k = 0; k < index.length(); ++k) {
        diffDims.push(k);
      }
    }

    // assign
    currentPosition = position;

    if (!silent) {
      /**
       * Position change event.
       *
       * @event dwv.image.View#positionchange
       * @type {object}
       * @property {Array} value The changed value as [index, pixelValue].
       * @property {Array} diffDims An array of modified indices.
       */
      var posEvent = {
        type: 'positionchange',
        value: [
          index.getValues(),
          position.getValues(),
        ],
        diffDims: diffDims,
        data: {
          imageUid: image.getImageUid(index)
        }
      };

      // add value if possible
      if (image.canQuantify()) {
        var pixValue = image.getRescaledValueAtIndex(index);
        posEvent.value.push(pixValue);
      }

      // fire
      fireEvent(posEvent);
    }

    // all good
    return true;
  };

  /**
   * Set the view window/level.
   *
   * @param {number} center The window center.
   * @param {number} width The window width.
   * @param {string} name Associated preset name, defaults to 'manual'.
   * Warning: uses the latest set rescale LUT or the default linear one.
   * @param {boolean} silent Flag to launch events with skipGenerate.
   * @fires dwv.image.View#wlchange
   */
  this.setWindowLevel = function (center, width, name, silent) {
    // window width shall be >= 1 (see https://www.dabsoft.ch/dicom/3/C.11.2.1.2/)
    if (width < 1) {
      return;
    }

    // check input
    if (typeof name === 'undefined') {
      name = 'manual';
    }
    if (typeof silent === 'undefined') {
      silent = false;
    }

    // new window level
    var newWl = new dwv.image.WindowLevel(center, width);

    // check if new
    var isNew = !newWl.equals(currentWl);

    // compare to previous if present
    if (isNew) {
      var isNewWidth = currentWl ? currentWl.getWidth() !== width : true;
      var isNewCenter = currentWl ? currentWl.getCenter() !== center : true;
      // assign
      currentWl = newWl;
      currentPresetName = name;

      if (isNewWidth || isNewCenter) {
        /**
         * Window/level change event.
         *
         * @event dwv.image.View#wlchange
         * @type {object}
         * @property {Array} value The changed value.
         * @property {number} wc The new window center value.
         * @property {number} ww The new window wdth value.
         * @property {boolean} skipGenerate Flag to skip view generation.
         */
        fireEvent({
          type: 'wlchange',
          value: [center, width],
          wc: center,
          ww: width,
          skipGenerate: silent
        });
      }
    }
  };

  /**
   * Set the window level to the preset with the input name.
   *
   * @param {string} name The name of the preset to activate.
   * @param {boolean} silent Flag to launch events with skipGenerate.
   */
  this.setWindowLevelPreset = function (name, silent) {
    var preset = this.getWindowPresets()[name];
    if (typeof preset === 'undefined') {
      throw new Error('Unknown window level preset: \'' + name + '\'');
    }
    // special min/max
    if (name === 'minmax' && typeof preset.wl === 'undefined') {
      preset.wl = [this.getWindowLevelMinMax()];
    }
    // default to first
    var wl = preset.wl[0];
    // check if 'perslice' case
    if (typeof preset.perslice !== 'undefined' &&
      preset.perslice === true) {
      var offset = image.getSecondaryOffset(this.getCurrentIndex());
      wl = preset.wl[offset];
    }
    // set w/l
    this.setWindowLevel(
      wl.getCenter(), wl.getWidth(), name, silent);
  };

  /**
   * Set the window level to the preset with the input id.
   *
   * @param {number} id The id of the preset to activate.
   * @param {boolean} silent Flag to launch events with skipGenerate.
   */
  this.setWindowLevelPresetById = function (id, silent) {
    var keys = Object.keys(this.getWindowPresets());
    this.setWindowLevelPreset(keys[id], silent);
  };

  /**
   * Clone the image using all meta data and the original data buffer.
   *
   * @returns {dwv.image.View} A full copy of this {dwv.image.View}.
   */
  this.clone = function () {
    var copy = new dwv.image.View(this.getImage());
    for (var key in windowLuts) {
      copy.addWindowLut(windowLuts[key]);
    }
    copy.setListeners(this.getListeners());
    return copy;
  };

  /**
   * Add an event listener to this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type, will be called with the fired event.
   */
  this.addEventListener = function (type, callback) {
    listenerHandler.add(type, callback);
  };

  /**
   * Remove an event listener from this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type.
   */
  this.removeEventListener = function (type, callback) {
    listenerHandler.remove(type, callback);
  };

  /**
   * Fire an event: call all associated listeners with the input event object.
   *
   * @param {object} event The event to fire.
   * @private
   */
  function fireEvent(event) {
    listenerHandler.fireEvent(event);
  }
};

/**
 * Get the image window/level that covers the full data range.
 * Warning: uses the latest set rescale LUT or the default linear one.
 *
 * @returns {object} A min/max window level.
 */
dwv.image.View.prototype.getWindowLevelMinMax = function () {
  var range = this.getImage().getRescaledDataRange();
  var min = range.min;
  var max = range.max;
  var width = max - min;
  // full black / white images, defaults to 1.
  if (width < 1) {
    dwv.logger.warn('Zero or negative window width, defaulting to one.');
    width = 1;
  }
  var center = min + width / 2;
  return new dwv.image.WindowLevel(center, width);
};

/**
 * Set the image window/level to cover the full data range.
 * Warning: uses the latest set rescale LUT or the default linear one.
 */
dwv.image.View.prototype.setWindowLevelMinMax = function () {
  // calculate center and width
  var wl = this.getWindowLevelMinMax();
  // set window level
  this.setWindowLevel(wl.getCenter(), wl.getWidth(), 'minmax');
};

/**
 * Generate display image data to be given to a canvas.
 *
 * @param {Array} array The array to fill in.
 * @param {dwv.math.Index} index Optional index at which to generate,
 *   otherwise generates at current index.
 */
dwv.image.View.prototype.generateImageData = function (array, index) {
  // check index
  if (typeof index === 'undefined') {
    if (!this.getCurrentIndex()) {
      this.setInitialIndex();
    }
    index = this.getCurrentIndex();
  }

  var image = this.getImage();
  var iterator = dwv.image.getSliceIterator(
    image, index, false, this.getOrientation());

  var photoInterpretation = image.getPhotometricInterpretation();
  switch (photoInterpretation) {
  case 'MONOCHROME1':
  case 'MONOCHROME2':
    dwv.image.generateImageDataMonochrome(
      array,
      iterator,
      this.getAlphaFunction(),
      this.getCurrentWindowLut(),
      this.getColourMap()
    );
    break;

  case 'PALETTE COLOR':
    dwv.image.generateImageDataPaletteColor(
      array,
      iterator,
      this.getAlphaFunction(),
      this.getColourMap(),
      image.getMeta().BitsStored === 16
    );
    break;

  case 'RGB':
    dwv.image.generateImageDataRgb(
      array,
      iterator,
      this.getAlphaFunction(),
      this.getCurrentWindowLut()
    );
    break;

  case 'YBR_FULL':
    dwv.image.generateImageDataYbrFull(
      array,
      iterator,
      this.getAlphaFunction()
    );
    break;

  default:
    throw new Error(
      'Unsupported photometric interpretation: ' + photoInterpretation);
  }
};

/**
 * Increment the provided dimension.
 *
 * @param {number} dim The dimension to increment.
 * @param {boolean} silent Do not send event.
 * @returns {boolean} False if not in bounds.
 */
dwv.image.View.prototype.incrementIndex = function (dim, silent) {
  var index = this.getCurrentIndex();
  var values = new Array(index.length());
  values.fill(0);
  if (dim < values.length) {
    values[dim] = 1;
  } else {
    console.warn('Cannot increment given index: ', dim, values.length);
  }
  var incr = new dwv.math.Index(values);
  var newIndex = index.add(incr);
  return this.setCurrentIndex(newIndex, silent);
};

/**
 * Decrement the provided dimension.
 *
 * @param {number} dim The dimension to increment.
 * @param {boolean} silent Do not send event.
 * @returns {boolean} False if not in bounds.
 */
dwv.image.View.prototype.decrementIndex = function (dim, silent) {
  var index = this.getCurrentIndex();
  var values = new Array(index.length());
  values.fill(0);
  if (dim < values.length) {
    values[dim] = -1;
  } else {
    console.warn('Cannot decrement given index: ', dim, values.length);
  }
  var incr = new dwv.math.Index(values);
  var newIndex = index.add(incr);
  return this.setCurrentIndex(newIndex, silent);
};

/**
 * Get the scroll dimension index.
 *
 * @returns {number} The index.
 */
dwv.image.View.prototype.getScrollIndex = function () {
  var index = null;
  var orientation = this.getOrientation();
  if (typeof orientation !== 'undefined') {
    index = orientation.getThirdColMajorDirection();
  } else {
    index = 2;
  }
  return index;
};

/**
 * Decrement the scroll dimension index.
 *
 * @param {boolean} silent Do not send event.
 * @returns {boolean} False if not in bounds.
 */
dwv.image.View.prototype.decrementScrollIndex = function (silent) {
  return this.decrementIndex(this.getScrollIndex(), silent);
};

/**
 * Increment the scroll dimension index.
 *
 * @param {boolean} silent Do not send event.
 * @returns {boolean} False if not in bounds.
 */
dwv.image.View.prototype.incrementScrollIndex = function (silent) {
  return this.incrementIndex(this.getScrollIndex(), silent);
};

// namespaces
var dwv = dwv || {};
dwv.image = dwv.image || {};

/**
 * {@link dwv.image.View} factory.
 *
 * @class
 */
dwv.image.ViewFactory = function () {};

/**
 * {@link dwv.image.View} factory. Defaults to local one.
 *
 * @see dwv.image.ViewFactory
 */
dwv.ViewFactory = dwv.image.ViewFactory;

/**
 * Get an View object from the read DICOM file.
 *
 * @param {object} dicomElements The DICOM tags.
 * @param {dwv.image.Image} image The associated image.
 * @returns {dwv.image.View} The new View.
 */
dwv.image.ViewFactory.prototype.create = function (dicomElements, image) {
  // view
  var view = new dwv.image.View(image);

  // default color map
  if (image.getPhotometricInterpretation() === 'MONOCHROME1') {
    view.setDefaultColourMap(dwv.image.lut.invPlain);
  } else if (image.getPhotometricInterpretation() === 'PALETTE COLOR') {
    var paletteLut = image.getMeta().paletteLut;
    if (typeof (paletteLut) !== 'undefined') {
      view.setDefaultColourMap(paletteLut);
    }
  }

  // window level presets
  var windowPresets = {};
  // image presets
  if (typeof image.getMeta().windowPresets !== 'undefined') {
    windowPresets = image.getMeta().windowPresets;
  }
  // min/max
  // Not filled yet since it is stil too costly to calculate min/max
  // for each slice... It will be filled at first use
  // (see view.setWindowLevelPreset).
  // Order is important, if no wl from DICOM, this will be the default.
  windowPresets.minmax = {name: 'minmax'};
  // optional modality presets
  if (typeof dwv.tool !== 'undefined' &&
    typeof dwv.tool.defaultpresets !== 'undefined') {
    var modality = image.getMeta().Modality;
    for (var key in dwv.tool.defaultpresets[modality]) {
      var preset = dwv.tool.defaultpresets[modality][key];
      windowPresets[key] = {
        wl: [new dwv.image.WindowLevel(preset.center, preset.width)],
        name: key
      };
    }
  }

  // store
  view.setWindowPresets(windowPresets);

  // initialise the view
  view.init();

  return view;
};

// namespaces
var dwv = dwv || {};
dwv.image = dwv.image || {};

/**
 * Generate image data for 'MONOCHROME*' photometric interpretation.
 *
 * @param {Array} array The array to store the outut data
 * @param {object} iterator Position iterator.
 * @param {Function} alphaFunc The alpha function.
 * @param {object} windowLut The window/level LUT.
 * @param {object} colourMap The colour map.
 */
dwv.image.generateImageDataMonochrome = function (
  array,
  iterator,
  alphaFunc,
  windowLut,
  colourMap) {
  var index = 0;
  var pxValue = 0;
  var ival = iterator.next();
  while (!ival.done) {
    // pixel value
    pxValue = windowLut.getValue(ival.value);
    // store data
    array.data[index] = colourMap.red[pxValue];
    array.data[index + 1] = colourMap.green[pxValue];
    array.data[index + 2] = colourMap.blue[pxValue];
    array.data[index + 3] = alphaFunc(ival.value, ival.index);
    // increment
    index += 4;
    ival = iterator.next();
  }
};

// namespaces
var dwv = dwv || {};
dwv.image = dwv.image || {};

/**
 * Generate image data for 'PALETTE COLOR' photometric interpretation.
 *
 * @param {Array} array The array to store the outut data
 * @param {object} iterator Position iterator.
 * @param {Function} alphaFunc The alpha function.
 * @param {object} colourMap The colour map.
 * @param {boolean} is16BitsStored Flag to know if the data is 16bits.
 */
dwv.image.generateImageDataPaletteColor = function (
  array,
  iterator,
  alphaFunc,
  colourMap,
  is16BitsStored) {
  // right shift 8
  var to8 = function (value) {
    return value >> 8;
  };

  if (is16BitsStored) {
    dwv.logger.info('Scaling 16bits data to 8bits.');
  }

  var index = 0;
  var pxValue = 0;
  var ival = iterator.next();
  while (!ival.done) {
    // pixel value
    pxValue = ival.value;
    // store data
    // TODO check pxValue fits in lut
    if (is16BitsStored) {
      array.data[index] = to8(colourMap.red[pxValue]);
      array.data[index + 1] = to8(colourMap.green[pxValue]);
      array.data[index + 2] = to8(colourMap.blue[pxValue]);
    } else {
      array.data[index] = colourMap.red[pxValue];
      array.data[index + 1] = colourMap.green[pxValue];
      array.data[index + 2] = colourMap.blue[pxValue];
    }
    array.data[index + 3] = alphaFunc(pxValue, ival.index);
    // increment
    index += 4;
    ival = iterator.next();
  }
};

// namespaces
var dwv = dwv || {};
dwv.image = dwv.image || {};

/**
 * Generate image data for 'RGB' photometric interpretation.
 *
 * @param {Array} array The array to store the outut data
 * @param {object} iterator Position iterator.
 * @param {Function} alphaFunc The alpha function.
 */
dwv.image.generateImageDataRgb = function (
  array,
  iterator,
  alphaFunc) {
  var index = 0;
  var ival = iterator.next();
  while (!ival.done) {
    // store data
    array.data[index] = ival.value[0];
    array.data[index + 1] = ival.value[1];
    array.data[index + 2] = ival.value[2];
    array.data[index + 3] = alphaFunc(ival.value, ival.index);
    // increment
    index += 4;
    ival = iterator.next();
  }
};

// namespaces
var dwv = dwv || {};
dwv.image = dwv.image || {};

/**
 * Generate image data for 'YBR_FULL' photometric interpretation.
 *
 * @param {Array} array The array to store the outut data
 * @param {object} iterator Position iterator.
 * @param {Function} alphaFunc The alpha function.
 */
dwv.image.generateImageDataYbrFull = function (
  array,
  iterator,
  alphaFunc) {
  var index = 0;
  var rgb = null;
  var ival = iterator.next();
  while (!ival.done) {
    // convert ybr to rgb
    rgb = dwv.utils.ybrToRgb(
      ival.value[0], ival.value[1], ival.value[2]);
    // store data
    array.data[index] = rgb.r;
    array.data[index + 1] = rgb.g;
    array.data[index + 2] = rgb.b;
    array.data[index + 3] = alphaFunc(ival.value, ival.index);
    // increment
    index += 4;
    ival = iterator.next();
  }
};

// namespaces
var dwv = dwv || {};
dwv.image = dwv.image || {};

/**
 * Minimum window width value.
 *
 * @see http://dicom.nema.org/dicom/2013/output/chtml/part03/sect_C.11.html#sect_C.11.2.1.2
 */
dwv.image.MinWindowWidth = 1;

/**
 * Validate an input window width.
 *
 * @param {number} value The value to test.
 * @returns {number} A valid window width.
 */
dwv.image.validateWindowWidth = function (value) {
  return value < dwv.image.MinWindowWidth ? dwv.image.MinWindowWidth : value;
};

/**
 * WindowLevel class.
 * <br>Pseudo-code:
 * <pre>
 *  if (x &lt;= c - 0.5 - (w-1)/2), then y = ymin
 *  else if (x > c - 0.5 + (w-1)/2), then y = ymax,
 *  else y = ((x - (c - 0.5)) / (w-1) + 0.5) * (ymax - ymin) + ymin
 * </pre>
 *
 * @see DICOM doc for [Window Center and Window Width]{@link http://dicom.nema.org/dicom/2013/output/chtml/part03/sect_C.11.html#sect_C.11.2.1.2}
 * @param {number} center The window center.
 * @param {number} width The window width.
 * @class
 */
dwv.image.WindowLevel = function (center, width) {
  // check width
  if (width < dwv.image.MinWindowWidth) {
    throw new Error('Window width shall always be greater than or equal to ' +
      dwv.image.MinWindowWidth);
  }

  /**
   * Signed data offset. Defaults to 0.
   *
   * @private
   * @type {number}
   */
  var signedOffset = 0;
  /**
   * Output value minimum. Defaults to 0.
   *
   * @private
   * @type {number}
   */
  var ymin = 0;
  /**
   * Output value maximum. Defaults to 255.
   *
   * @private
   * @type {number}
   */
  var ymax = 255;

  /**
   * Input value minimum (calculated).
   *
   * @private
   * @type {number}
   */
  var xmin = null;
  /**
   * Input value maximum (calculated).
   *
   * @private
   * @type {number}
   */
  var xmax = null;
  /**
   * Window level equation slope (calculated).
   *
   * @private
   * @type {number}
   */
  var slope = null;
  /**
   * Window level equation intercept (calculated).
   *
   * @private
   * @type {number}
   */
  var inter = null;

  /**
   * Initialise members. Called at construction.
   *
   * @private
   */
  function init() {
    var c = center + signedOffset;
    // from the standard
    xmin = c - 0.5 - ((width - 1) / 2);
    xmax = c - 0.5 + ((width - 1) / 2);
    // develop the equation:
    // y = ( ( x - (c - 0.5) ) / (w-1) + 0.5 ) * (ymax - ymin) + ymin
    // y = ( x / (w-1) ) * (ymax - ymin) +
    //     ( -(c - 0.5) / (w-1) + 0.5 ) * (ymax - ymin) + ymin
    slope = (ymax - ymin) / (width - 1);
    inter = (-(c - 0.5) / (width - 1) + 0.5) * (ymax - ymin) + ymin;
  }

  // call init
  init();

  /**
   * Get the window center.
   *
   * @returns {number} The window center.
   */
  this.getCenter = function () {
    return center;
  };
  /**
   * Get the window width.
   *
   * @returns {number} The window width.
   */
  this.getWidth = function () {
    return width;
  };

  /**
   * Set the output value range.
   *
   * @param {number} min The output value minimum.
   * @param {number} max The output value maximum.
   */
  this.setRange = function (min, max) {
    ymin = parseInt(min, 10);
    ymax = parseInt(max, 10);
    // re-initialise
    init();
  };
  /**
   * Set the signed offset.
   *
   * @param {number} offset The signed data offset,
   *   typically: slope * ( size / 2).
   */
  this.setSignedOffset = function (offset) {
    signedOffset = offset;
    // re-initialise
    init();
  };

  /**
   * Apply the window level on an input value.
   *
   * @param {number} value The value to rescale as an integer.
   * @returns {number} The leveled value, in the
   *  [ymin, ymax] range (default [0,255]).
   */
  this.apply = function (value) {
    if (value <= xmin) {
      return ymin;
    } else if (value > xmax) {
      return ymax;
    } else {
      return parseInt(((value * slope) + inter), 10);
    }
  };

};

/**
 * Check for window level equality.
 *
 * @param {object} rhs The other window level to compare to.
 * @returns {boolean} True if both window level are equal.
 */
dwv.image.WindowLevel.prototype.equals = function (rhs) {
  return rhs !== null &&
        this.getCenter() === rhs.getCenter() &&
        this.getWidth() === rhs.getWidth();
};

/**
 * Get a string representation of the window level.
 *
 * @returns {string} The window level as a string.
 */
dwv.image.WindowLevel.prototype.toString = function () {
  return (this.getCenter() + ', ' + this.getWidth());
};

// namespaces
var dwv = dwv || {};
dwv.image = dwv.image || {};

/**
 * Window LUT class.
 * Typically converts from float to integer.
 *
 * @class
 * @param {number} rescaleLut The associated rescale LUT.
 * @param {boolean} isSigned Flag to know if the data is signed or not.
 */
dwv.image.WindowLut = function (rescaleLut, isSigned) {
  /**
   * The internal array: Uint8ClampedArray clamps between 0 and 255.
   *
   * @private
   * @type {Uint8ClampedArray}
   */
  var lut = null;

  /**
   * The window level.
   *
   * @private
   * @type {object}
   */
  var windowLevel = null;

  /**
   * Flag to know if the lut is ready or not.
   *
   * @private
   * @type {boolean}
   */
  var isReady = false;

  /**
   * Shift for signed data.
   *
   * @private
   * @type {number}
   */
  var signedShift = 0;

  /**
   * Get the window / level.
   *
   * @returns {object} The window / level.
   */
  this.getWindowLevel = function () {
    return windowLevel;
  };
  /**
   * Get the signed flag.
   *
   * @returns {boolean} The signed flag.
   */
  this.isSigned = function () {
    return isSigned;
  };
  /**
   * Get the rescale lut.
   *
   * @returns {object} The rescale lut.
   */
  this.getRescaleLut = function () {
    return rescaleLut;
  };

  /**
   * Is the lut ready to use or not? If not, the user must
   * call 'update'.
   *
   * @returns {boolean} True if the lut is ready to use.
   */
  this.isReady = function () {
    return isReady;
  };

  /**
   * Set the window center and width.
   *
   * @param {object} wl The window level.
   */
  this.setWindowLevel = function (wl) {
    // store the window values
    windowLevel = wl;
    // possible signed shift
    signedShift = 0;
    windowLevel.setSignedOffset(0);
    if (isSigned) {
      var size = rescaleLut.getLength();
      signedShift = size / 2;
      windowLevel.setSignedOffset(rescaleLut.getRSI().getSlope() * signedShift);
    }
    // update ready flag
    isReady = false;
  };

  /**
   * Update the lut if needed..
   */
  this.update = function () {
    // check if we need to update
    if (isReady) {
      return;
    }

    // check rescale lut
    if (!rescaleLut.isReady()) {
      rescaleLut.initialise();
    }
    // create window lut
    var size = rescaleLut.getLength();
    if (!lut) {
      // use clamped array (polyfilled in env.js)
      lut = new Uint8ClampedArray(size);
    }
    // by default WindowLevel returns a value in the [0,255] range
    // this is ok with regular Arrays and ClampedArray.
    for (var i = 0; i < size; ++i) {
      lut[i] = windowLevel.apply(rescaleLut.getValue(i));
    }

    // update ready flag
    isReady = true;
  };

  /**
   * Get the length of the LUT array.
   *
   * @returns {number} The length of the LUT array.
   */
  this.getLength = function () {
    return lut.length;
  };

  /**
   * Get the value of the LUT at the given offset.
   *
   * @param {number} offset The input offset in [0,2^bitsStored] range.
   * @returns {number} The integer value (default [0,255]) of the LUT
   *   at the given offset.
   */
  this.getValue = function (offset) {
    return lut[offset + signedShift];
  };
};

// namespaces
var dwv = dwv || {};
dwv.io = dwv.io || {};

/**
 * DICOM data loader.
 *
 * @class
 */
dwv.io.DicomDataLoader = function () {
  // closure to self
  var self = this;

  /**
   * Loader options.
   *
   * @private
   * @type {object}
   */
  var options = {};

  /**
   * Loading flag.
   *
   * @private
   * @type {boolean}
   */
  var isLoading = false;

  /**
   * Set the loader options.
   *
   * @param {object} opt The input options.
   */
  this.setOptions = function (opt) {
    options = opt;
  };

  /**
   * Is the load ongoing?
   *
   * @returns {boolean} True if loading.
   */
  this.isLoading = function () {
    return isLoading;
  };

  /**
   * DICOM buffer to dwv.image.View (asynchronous)
   *
   * @private
   */
  var db2v = new dwv.image.DicomBufferToView();

  /**
   * Load data.
   *
   * @param {object} buffer The DICOM buffer.
   * @param {string} origin The data origin.
   * @param {number} index The data index.
   */
  this.load = function (buffer, origin, index) {
    // setup db2v ony once
    if (!isLoading) {
      // pass options
      db2v.setOptions(options);
      // connect handlers
      db2v.onloadstart = self.onloadstart;
      db2v.onprogress = self.onprogress;
      db2v.onloaditem = self.onloaditem;
      db2v.onload = self.onload;
      db2v.onloadend = function (event) {
        // reset loading flag
        isLoading = false;
        // call listeners
        self.onloadend(event);
      };
      db2v.onerror = function (event) {
        event.source = origin;
        self.onerror(event);
      };
      db2v.onabort = self.onabort;
    }

    // set loading flag
    isLoading = true;
    // convert
    db2v.convert(buffer, origin, index);
  };

  /**
   * Abort load.
   */
  this.abort = function () {
    // reset loading flag
    isLoading = false;
    // abort conversion, will trigger db2v.onabort
    db2v.abort();
  };

}; // class DicomDataLoader

/**
 * Check if the loader can load the provided file.
 *
 * @param {object} file The file to check.
 * @returns {boolean} True if the file can be loaded.
 */
dwv.io.DicomDataLoader.prototype.canLoadFile = function (file) {
  var ext = dwv.utils.getFileExtension(file.name);
  var hasNoExt = (ext === null);
  var hasDcmExt = (ext === 'dcm');
  return hasNoExt || hasDcmExt;
};

/**
 * Check if the loader can load the provided url.
 * True if:
 *  - the url has a 'contentType' and it is 'application/dicom'
 *    (as in wado urls)
 *  - the url has no 'contentType' and no extension or the extension is 'dcm'
 *
 * @param {string} url The url to check.
 * @param {object} options Optional url request options.
 * @returns {boolean} True if the url can be loaded.
 */
dwv.io.DicomDataLoader.prototype.canLoadUrl = function (url, options) {
  // if there are options.requestHeaders, just base check on them
  if (typeof options !== 'undefined' &&
    typeof options.requestHeaders !== 'undefined') {
    // starts with 'application/dicom'
    var isDicom = function (element) {
      return element.name === 'Accept' &&
        dwv.utils.startsWith(element.value, 'application/dicom') &&
        element.value[18] !== '+';
    };
    return typeof options.requestHeaders.find(isDicom) !== 'undefined';
  }

  var urlObjext = dwv.utils.getUrlFromUri(url);
  // extension
  var ext = dwv.utils.getFileExtension(urlObjext.pathname);
  var hasNoExt = (ext === null);
  var hasDcmExt = (ext === 'dcm');
  // content type (for wado url)
  var contentType = urlObjext.searchParams.get('contentType');
  var hasContentType = contentType !== null &&
    typeof contentType !== 'undefined';
  var hasDicomContentType = (contentType === 'application/dicom');

  return hasContentType ? hasDicomContentType : (hasNoExt || hasDcmExt);
};

/**
 * Check if the loader can load the provided memory object.
 *
 * @param {object} mem The memory object.
 * @returns {boolean} True if the object can be loaded.
 */
dwv.io.DicomDataLoader.prototype.canLoadMemory = function (mem) {
  if (typeof mem['Content-Type'] !== 'undefined' &&
    mem['Content-Type'] === 'application/dicom') {
    return true;
  }
  if (typeof mem.filename !== 'undefined') {
    return this.canLoadFile(mem.filename);
  }
  return false;
};

/**
 * Get the file content type needed by the loader.
 *
 * @returns {number} One of the 'dwv.io.fileContentTypes'.
 */
dwv.io.DicomDataLoader.prototype.loadFileAs = function () {
  return dwv.io.fileContentTypes.ArrayBuffer;
};

/**
 * Get the url content type needed by the loader.
 *
 * @returns {number} One of the 'dwv.io.urlContentTypes'.
 */
dwv.io.DicomDataLoader.prototype.loadUrlAs = function () {
  return dwv.io.urlContentTypes.ArrayBuffer;
};

/**
 * Handle a load start event.
 * Default does nothing.
 *
 * @param {object} _event The load start event.
 */
dwv.io.DicomDataLoader.prototype.onloadstart = function (_event) {};
/**
 * Handle a progress event.
 * Default does nothing.
 *
 * @param {object} _event The load progress event.
 */
dwv.io.DicomDataLoader.prototype.onprogress = function (_event) {};
/**
 * Handle a load item event.
 * Default does nothing.
 *
 * @param {object} _event The load item event fired
 *   when a file item has been loaded successfully.
 */
dwv.io.DicomDataLoader.prototype.onloaditem = function (_event) {};
/**
 * Handle a load event.
 * Default does nothing.
 *
 * @param {object} _event The load event fired
 *   when a file has been loaded successfully.
 */
dwv.io.DicomDataLoader.prototype.onload = function (_event) {};
/**
 * Handle an load end event.
 * Default does nothing.
 *
 * @param {object} _event The load end event fired
 *  when a file load has completed, successfully or not.
 */
dwv.io.DicomDataLoader.prototype.onloadend = function (_event) {};
/**
 * Handle an error event.
 * Default does nothing.
 *
 * @param {object} _event The error event.
 */
dwv.io.DicomDataLoader.prototype.onerror = function (_event) {};
/**
 * Handle an abort event.
 * Default does nothing.
 *
 * @param {object} _event The abort event.
 */
dwv.io.DicomDataLoader.prototype.onabort = function (_event) {};

/**
 * Add to Loader list.
 */
dwv.io.loaderList = dwv.io.loaderList || [];
dwv.io.loaderList.push('DicomDataLoader');

// namespaces
var dwv = dwv || {};
/** @namespace */
dwv.io = dwv.io || {};

// file content types
dwv.io.fileContentTypes = {
  Text: 0,
  ArrayBuffer: 1,
  DataURL: 2
};

/**
 * Files loader.
 *
 * @class
 */
dwv.io.FilesLoader = function () {
  /**
   * Closure to self.
   *
   * @private
   * @type {object}
   */
  var self = this;

  /**
   * Input data.
   *
   * @private
   * @type {Array}
   */
  var inputData = null;

  /**
   * Array of launched file readers.
   *
   * @private
   * @type {Array}
   */
  var readers = [];

  /**
   * Data loader.
   *
   * @private
   * @type {object}
   */
  var runningLoader = null;

  /**
   * Number of loaded data.
   *
   * @private
   * @type {number}
   */
  var nLoad = 0;

  /**
   * Number of load end events.
   *
   * @private
   * @type {number}
   */
  var nLoadend = 0;

  /**
   * The default character set (optional).
   *
   * @private
   * @type {string}
   */
  var defaultCharacterSet;

  /**
   * Get the default character set.
   *
   * @returns {string} The default character set.
   */
  this.getDefaultCharacterSet = function () {
    return defaultCharacterSet;
  };

  /**
   * Set the default character set.
   *
   * @param {string} characterSet The character set.
   */
  this.setDefaultCharacterSet = function (characterSet) {
    defaultCharacterSet = characterSet;
  };

  /**
   * Store the current input.
   *
   * @param {object} data The input data.
   * @private
   */
  function storeInputData(data) {
    inputData = data;
    // reset counters
    nLoad = 0;
    nLoadend = 0;
    // clear storage
    clearStoredReaders();
    clearStoredLoader();
  }

  /**
   * Store a launched reader.
   *
   * @param {object} reader The launched reader.
   * @private
   */
  function storeReader(reader) {
    readers.push(reader);
  }

  /**
   * Clear the stored readers.
   *
   * @private
   */
  function clearStoredReaders() {
    readers = [];
  }

  /**
   * Store the launched loader.
   *
   * @param {object} loader The launched loader.
   * @private
   */
  function storeLoader(loader) {
    runningLoader = loader;
  }

  /**
   * Clear the stored loader.
   *
   * @private
   */
  function clearStoredLoader() {
    runningLoader = null;
  }

  /**
   * Launch a load item event and call addLoad.
   *
   * @param {object} event The load data event.
   * @private
   */
  function addLoadItem(event) {
    self.onloaditem(event);
    addLoad();
  }

  /**
   * Increment the number of loaded data
   *   and call onload if loaded all data.
   *
   * @param {object} _event The load data event.
   * @private
   */
  function addLoad(_event) {
    nLoad++;
    // call self.onload when all is loaded
    // (not using the input event since it is not the
    //   general load)
    if (nLoad === inputData.length) {
      self.onload({
        source: inputData
      });
    }
  }

  /**
   * Increment the counter of load end events
   *   and run callbacks when all done, erroneus or not.
   *
   * @param {object} _event The load end event.
   * @private
   */
  function addLoadend(_event) {
    nLoadend++;
    // call self.onloadend when all is run
    // (not using the input event since it is not the
    //   general load end)
    // x2 to count for reader + load
    if (nLoadend === 2 * inputData.length) {
      self.onloadend({
        source: inputData
      });
    }
  }

  /**
   * Augment a callback event with a srouce.
   *
   * @param {object} callback The callback to augment its event.
   * @param {object} source The source to add to the event.
   * @returns {Function} The augmented callback.
   * @private
   */
  function augmentCallbackEvent(callback, source) {
    return function (event) {
      event.source = source;
      callback(event);
    };
  }

  /**
   * Load a list of files.
   *
   * @param {Array} data The list of files to load.
   */
  this.load = function (data) {
    // check input
    if (typeof data === 'undefined' || data.length === 0) {
      return;
    }
    storeInputData(data);

    // send start event
    this.onloadstart({
      source: data
    });

    // create prgress handler
    var mproghandler = new dwv.utils.MultiProgressHandler(self.onprogress);
    mproghandler.setNToLoad(data.length);

    // create loaders
    var loaders = [];
    for (var m = 0; m < dwv.io.loaderList.length; ++m) {
      loaders.push(new dwv.io[dwv.io.loaderList[m]]());
    }

    // find an appropriate loader
    var dataElement = data[0];
    var loader = null;
    var foundLoader = false;
    for (var l = 0; l < loaders.length; ++l) {
      loader = loaders[l];
      if (loader.canLoadFile(dataElement)) {
        foundLoader = true;
        // load options
        loader.setOptions({
          numberOfFiles: data.length,
          defaultCharacterSet: this.getDefaultCharacterSet()
        });
        // set loader callbacks
        // loader.onloadstart: nothing to do
        loader.onprogress = mproghandler.getUndefinedMonoProgressHandler(1);
        if (typeof loader.onloaditem === 'undefined') {
          // handle loaditem locally
          loader.onload = addLoadItem;
        } else {
          loader.onloaditem = self.onloaditem;
          loader.onload = addLoad;
        }
        loader.onloadend = addLoadend;
        loader.onerror = self.onerror;
        loader.onabort = self.onabort;

        // store loader
        storeLoader(loader);
        // exit
        break;
      }
    }
    if (!foundLoader) {
      throw new Error('No loader found for file: ' + dataElement.name);
    }

    var getLoadHandler = function (loader, dataElement, i) {
      return function (event) {
        loader.load(event.target.result, dataElement, i);
      };
    };

    // loop on I/O elements
    for (var i = 0; i < data.length; ++i) {
      dataElement = data[i];

      // check loader
      if (!loader.canLoadFile(dataElement)) {
        throw new Error('Input file of different type: ' + dataElement);
      }

      /**
       * The file reader.
       *
       * @external FileReader
       * @see https://developer.mozilla.org/en-US/docs/Web/API/FileReader
       */
      var reader = new FileReader();
      // store reader
      storeReader(reader);

      // set reader callbacks
      // reader.onloadstart: nothing to do
      reader.onprogress = augmentCallbackEvent(
        mproghandler.getMonoProgressHandler(i, 0), dataElement);
      reader.onload = getLoadHandler(loader, dataElement, i);
      reader.onloadend = addLoadend;
      reader.onerror = augmentCallbackEvent(self.onerror, dataElement);
      reader.onabort = augmentCallbackEvent(self.onabort, dataElement);
      // read
      if (loader.loadFileAs() === dwv.io.fileContentTypes.Text) {
        reader.readAsText(dataElement);
      } else if (loader.loadFileAs() === dwv.io.fileContentTypes.DataURL) {
        reader.readAsDataURL(dataElement);
      } else if (loader.loadFileAs() === dwv.io.fileContentTypes.ArrayBuffer) {
        reader.readAsArrayBuffer(dataElement);
      }
    }
  };

  /**
   * Abort a load.
   */
  this.abort = function () {
    // abort readers
    for (var i = 0; i < readers.length; ++i) {
      // 0: EMPTY, 1: LOADING, 2: DONE
      if (readers[i].readyState === 1) {
        readers[i].abort();
      }
    }
    // abort loader
    if (runningLoader && runningLoader.isLoading()) {
      runningLoader.abort();
    }
  };

}; // class FilesLoader

/**
 * Handle a load start event.
 * Default does nothing.
 *
 * @param {object} _event The load start event.
 */
dwv.io.FilesLoader.prototype.onloadstart = function (_event) {};
/**
 * Handle a load progress event.
 * Default does nothing.
 *
 * @param {object} _event The progress event.
 */
dwv.io.FilesLoader.prototype.onprogress = function (_event) {};
/**
 * Handle a load item event.
 * Default does nothing.
 *
 * @param {object} _event The load item event fired
 *   when a file item has been loaded successfully.
 */
dwv.io.FilesLoader.prototype.onloaditem = function (_event) {};
/**
 * Handle a load event.
 * Default does nothing.
 *
 * @param {object} _event The load event fired
 *   when a file has been loaded successfully.
 */
dwv.io.FilesLoader.prototype.onload = function (_event) {};
/**
 * Handle a load end event.
 * Default does nothing.
 *
 * @param {object} _event The load end event fired
 *  when a file load has completed, successfully or not.
 */
dwv.io.FilesLoader.prototype.onloadend = function (_event) {};
/**
 * Handle an error event.
 * Default does nothing.
 *
 * @param {object} _event The error event.
 */
dwv.io.FilesLoader.prototype.onerror = function (_event) {};
/**
 * Handle an abort event.
 * Default does nothing.
 *
 * @param {object} _event The abort event.
 */
dwv.io.FilesLoader.prototype.onabort = function (_event) {};

// namespaces
var dwv = dwv || {};
dwv.io = dwv.io || {};

/**
 * JSON text loader.
 *
 * @class
 */
dwv.io.JSONTextLoader = function () {
  // closure to self
  var self = this;

  /**
   * Loading flag.
   *
   * @private
   * @type {boolean}
   */
  var isLoading = false;

  /**
   * Set the loader options.
   *
   * @param {object} _opt The input options.
   */
  this.setOptions = function (_opt) {
    // does nothing
  };

  /**
   * Is the load ongoing?
   *
   * @returns {boolean} True if loading.
   */
  this.isLoading = function () {
    return isLoading;
  };

  /**
   * Load data.
   *
   * @param {object} text The input text.
   * @param {string} origin The data origin.
   * @param {number} index The data index.
   */
  this.load = function (text, origin, index) {
    // set loading flag
    isLoading = true;
    self.onloadstart({
      source: origin
    });

    try {
      self.onprogress({
        lengthComputable: true,
        loaded: 100,
        total: 100,
        index: index,
        source: origin
      });
      self.onload({
        data: text,
        source: origin
      });
    } catch (error) {
      self.onerror({
        error: error,
        source: origin
      });
    } finally {
      // reset loading flag
      isLoading = false;
      self.onloadend({
        source: origin
      });
    }
  };

  /**
   * Abort load: pass to listeners.
   */
  this.abort = function () {
    // reset loading flag
    isLoading = false;
    // call listeners
    self.onabort({});
    self.onloadend({});
  };

}; // class JSONTextLoader

/**
 * Check if the loader can load the provided file.
 *
 * @param {object} file The file to check.
 * @returns {boolean} True if the file can be loaded.
 */
dwv.io.JSONTextLoader.prototype.canLoadFile = function (file) {
  var ext = dwv.utils.getFileExtension(file.name);
  return (ext === 'json');
};

/**
 * Check if the loader can load the provided url.
 *
 * @param {string} url The url to check.
 * @param {object} options Optional url request options.
 * @returns {boolean} True if the url can be loaded.
 */
dwv.io.JSONTextLoader.prototype.canLoadUrl = function (url, options) {
  // if there are options.requestHeader, just base check on them
  if (typeof options !== 'undefined' &&
    typeof options.requestHeaders !== 'undefined') {
    // starts with 'application/json' or 'application/dicom+json
    var isJson = function (element) {
      return element.name === 'Accept' &&
        dwv.utils.startsWith(element.value, 'application/json') &&
        dwv.utils.startsWith(element.value, 'application/dicom+json');
    };
    return typeof options.requestHeaders.find(isJson) !== 'undefined';
  }

  var urlObjext = dwv.utils.getUrlFromUri(url);
  var ext = dwv.utils.getFileExtension(urlObjext.pathname);
  return (ext === 'json');
};

/**
 * Check if the loader can load the provided memory object.
 *
 * @param {object} mem The memory object.
 * @returns {boolean} True if the object can be loaded.
 */
dwv.io.JSONTextLoader.prototype.canLoadMemory = function (mem) {
  if (typeof mem['Content-Type'] !== 'undefined') {
    if (mem['Content-Type'].includes('json')) {
      return true;
    }
  }
  if (typeof mem.filename !== 'undefined') {
    return this.canLoadFile(mem.filename);
  }
  return false;
};

/**
 * Get the file content type needed by the loader.
 *
 * @returns {number} One of the 'dwv.io.fileContentTypes'.
 */
dwv.io.JSONTextLoader.prototype.loadFileAs = function () {
  return dwv.io.fileContentTypes.Text;
};

/**
 * Get the url content type needed by the loader.
 *
 * @returns {number} One of the 'dwv.io.urlContentTypes'.
 */
dwv.io.JSONTextLoader.prototype.loadUrlAs = function () {
  return dwv.io.urlContentTypes.Text;
};

/**
 * Handle a load start event.
 * Default does nothing.
 *
 * @param {object} _event The load start event.
 */
dwv.io.JSONTextLoader.prototype.onloadstart = function (_event) {};
/**
 * Handle a progress event.
 * Default does nothing.
 *
 * @param {object} _event The load progress event.
 */
dwv.io.JSONTextLoader.prototype.onprogress = function (_event) {};
/**
 * Handle a load event.
 * Default does nothing.
 *
 * @param {object} _event The load event fired
 *   when a file has been loaded successfully.
 */
dwv.io.JSONTextLoader.prototype.onload = function (_event) {};
/**
 * Handle an load end event.
 * Default does nothing.
 *
 * @param {object} _event The load end event fired
 *  when a file load has completed, successfully or not.
 */
dwv.io.JSONTextLoader.prototype.onloadend = function (_event) {};
/**
 * Handle an error event.
 * Default does nothing.
 *
 * @param {object} _event The error event.
 */
dwv.io.JSONTextLoader.prototype.onerror = function (_event) {};
/**
 * Handle an abort event.
 * Default does nothing.
 *
 * @param {object} _event The abort event.
 */
dwv.io.JSONTextLoader.prototype.onabort = function (_event) {};

/**
 * Add to Loader list.
 */
dwv.io.loaderList = dwv.io.loaderList || [];
dwv.io.loaderList.push('JSONTextLoader');

// namespaces
var dwv = dwv || {};
dwv.io = dwv.io || {};

/**
 * Memory loader.
 *
 * @class
 */
dwv.io.MemoryLoader = function () {
  /**
   * Closure to self.
   *
   * @private
   * @type {object}
   */
  var self = this;

  /**
   * Input data.
   *
   * @private
   * @type {Array}
   */
  var inputData = null;

  /**
   * Data loader.
   *
   * @private
   * @type {object}
   */
  var runningLoader = null;

  /**
   * Number of loaded data.
   *
   * @private
   * @type {number}
   */
  var nLoad = 0;

  /**
   * Number of load end events.
   *
   * @private
   * @type {number}
   */
  var nLoadend = 0;

  /**
   * The default character set (optional).
   *
   * @private
   * @type {string}
   */
  var defaultCharacterSet;

  /**
   * Get the default character set.
   *
   * @returns {string} The default character set.
   */
  this.getDefaultCharacterSet = function () {
    return defaultCharacterSet;
  };

  /**
   * Set the default character set.
   *
   * @param {string} characterSet The character set.
   */
  this.setDefaultCharacterSet = function (characterSet) {
    defaultCharacterSet = characterSet;
  };

  /**
   * Store the current input.
   *
   * @param {object} data The input data.
   * @private
   */
  function storeInputData(data) {
    inputData = data;
    // reset counters
    nLoad = 0;
    nLoadend = 0;
    // clear storage
    clearStoredLoader();
  }

  /**
   * Store the launched loader.
   *
   * @param {object} loader The launched loader.
   * @private
   */
  function storeLoader(loader) {
    runningLoader = loader;
  }

  /**
   * Clear the stored loader.
   *
   * @private
   */
  function clearStoredLoader() {
    runningLoader = null;
  }

  /**
   * Launch a load item event and call addLoad.
   *
   * @param {object} event The load data event.
   * @private
   */
  function addLoadItem(event) {
    self.onloaditem(event);
    addLoad();
  }

  /**
   * Increment the number of loaded data
   *   and call onload if loaded all data.
   *
   * @param {object} _event The load data event.
   * @private
   */
  function addLoad(_event) {
    nLoad++;
    // call self.onload when all is loaded
    // (not using the input event since it is not the
    //   general load)
    if (nLoad === inputData.length) {
      self.onload({
        source: inputData
      });
    }
  }

  /**
   * Increment the counter of load end events
   *   and run callbacks when all done, erroneus or not.
   *
   * @param {object} _event The load end event.
   * @private
   */
  function addLoadend(_event) {
    nLoadend++;
    // call self.onloadend when all is run
    // (not using the input event since it is not the
    //   general load end)
    if (nLoadend === inputData.length) {
      self.onloadend({
        source: inputData
      });
    }
  }

  /**
   * Load a list of buffers.
   *
   * @param {Array} data The list of buffers to load.
   */
  this.load = function (data) {
    // check input
    if (typeof data === 'undefined' || data.length === 0) {
      return;
    }
    storeInputData(data);

    // send start event
    this.onloadstart({
      source: data
    });

    // create prgress handler
    var mproghandler = new dwv.utils.MultiProgressHandler(self.onprogress);
    mproghandler.setNToLoad(data.length);
    mproghandler.setNumberOfDimensions(1);

    // create loaders
    var loaders = [];
    for (var m = 0; m < dwv.io.loaderList.length; ++m) {
      loaders.push(new dwv.io[dwv.io.loaderList[m]]());
    }

    // find an appropriate loader
    var dataElement = data[0];
    var loader = null;
    var foundLoader = false;
    for (var l = 0; l < loaders.length; ++l) {
      loader = loaders[l];
      if (loader.canLoadMemory(dataElement)) {
        foundLoader = true;
        // load options
        loader.setOptions({
          numberOfFiles: data.length,
          defaultCharacterSet: this.getDefaultCharacterSet()
        });
        // set loader callbacks
        // loader.onloadstart: nothing to do
        loader.onprogress = mproghandler.getUndefinedMonoProgressHandler(0);
        if (typeof loader.onloaditem === 'undefined') {
          // handle loaditem locally
          loader.onload = addLoadItem;
        } else {
          loader.onloaditem = self.onloaditem;
          loader.onload = addLoad;
        }
        loader.onloadend = addLoadend;
        loader.onerror = self.onerror;
        loader.onabort = self.onabort;

        // store loader
        storeLoader(loader);
        // exit
        break;
      }
    }
    if (!foundLoader) {
      throw new Error('No loader found for data: ' + dataElement.filename);
    }

    // loop on I/O elements
    for (var i = 0; i < data.length; ++i) {
      dataElement = data[i];
      // check loader
      if (!loader.canLoadMemory(dataElement)) {
        throw new Error('Input data of different type: ' +
          dataElement.filename);
      }
      // read
      loader.load(dataElement.data, dataElement.filename, i);
    }
  };

  /**
   * Abort a load.
   */
  this.abort = function () {
    // abort loader
    if (runningLoader && runningLoader.isLoading()) {
      runningLoader.abort();
    }
  };

}; // class MemoryLoader

/**
 * Handle a load start event.
 * Default does nothing.
 *
 * @param {object} _event The load start event.
 */
dwv.io.MemoryLoader.prototype.onloadstart = function (_event) {};
/**
 * Handle a load progress event.
 * Default does nothing.
 *
 * @param {object} _event The progress event.
 */
dwv.io.MemoryLoader.prototype.onprogress = function (_event) {};
/**
 * Handle a load item event.
 * Default does nothing.
 *
 * @param {object} _event The load item event fired
 *   when a file item has been loaded successfully.
 */
dwv.io.MemoryLoader.prototype.onloaditem = function (_event) {};
/**
 * Handle a load event.
 * Default does nothing.
 *
 * @param {object} _event The load event fired
 *   when a file has been loaded successfully.
 */
dwv.io.MemoryLoader.prototype.onload = function (_event) {};
/**
 * Handle a load end event.
 * Default does nothing.
 *
 * @param {object} _event The load end event fired
 *  when a file load has completed, successfully or not.
 */
dwv.io.MemoryLoader.prototype.onloadend = function (_event) {};
/**
 * Handle an error event.
 * Default does nothing.
 *
 * @param {object} _event The error event.
 */
dwv.io.MemoryLoader.prototype.onerror = function (_event) {};
/**
 * Handle an abort event.
 * Default does nothing.
 *
 * @param {object} _event The abort event.
 */
dwv.io.MemoryLoader.prototype.onabort = function (_event) {};

// namespaces
var dwv = dwv || {};
dwv.io = dwv.io || {};

/**
 * Multipart data loader.
 *
 * @class
 */
dwv.io.MultipartLoader = function () {
  // closure to self
  var self = this;

  /**
   * Loading flag.
   *
   * @private
   * @type {boolean}
   */
  var isLoading = false;

  /**
   * Set the loader options.
   *
   * @param {object} _opt The input options.
   */
  this.setOptions = function (_opt) {
    // does nothing
  };

  /**
   * Is the load ongoing?
   *
   * @returns {boolean} True if loading.
   */
  this.isLoading = function () {
    return isLoading;
  };

  /**
   * Load data.
   *
   * @param {object} buffer The DICOM buffer.
   * @param {string} origin The data origin.
   * @param {number} index The data index.
   */
  this.load = function (buffer, origin, index) {
    // send start event
    this.onloadstart({
      source: origin
    });
    // set loading flag
    isLoading = true;

    var memoryIO = new dwv.io.MemoryLoader();
    // memoryIO.onloadstart: nothing to do
    memoryIO.onprogress = function (progress) {
      // add 50% to take into account the un-Multipartping
      progress.loaded = 50 + progress.loaded / 2;
      // set data index
      progress.index = index;
      self.onprogress(progress);
    };
    memoryIO.onloaditem = self.onloaditem;
    memoryIO.onload = self.onload;
    memoryIO.onloadend = function (event) {
      // reset loading flag
      isLoading = false;
      // call listeners
      self.onloadend(event);
    };
    memoryIO.onerror = self.onerror;
    memoryIO.onabort = self.onabort;
    // launch
    memoryIO.load(dwv.utils.parseMultipart(buffer));
  };

  /**
   * Abort load: pass to listeners.
   */
  this.abort = function () {
    // reset loading flag
    isLoading = false;
    // call listeners
    self.onabort({});
    self.onloadend({});
  };

}; // class MultipartLoader

/**
 * Check if the loader can load the provided file.
 *
 * @param {object} _file The file to check.
 * @returns {boolean} True if the file can be loaded.
 */
dwv.io.MultipartLoader.prototype.canLoadFile = function (_file) {
  return false;
};

/**
 * Check if the loader can load the provided url.
 *
 * @param {string} url The url to check.
 * @param {object} options The url request options.
 * @returns {boolean} True if the url can be loaded.
 */
dwv.io.MultipartLoader.prototype.canLoadUrl = function (url, options) {
  // if there are options.requestHeaders, just base check on them
  if (typeof options !== 'undefined' &&
    typeof options.requestHeaders !== 'undefined') {
    var isMultipart = function (element) {
      return element.name === 'Accept' &&
        dwv.utils.startsWith(element.value, 'multipart/related');
    };
    return typeof options.requestHeaders.find(isMultipart) !== 'undefined';
  }

  return false;
};

/**
 * Check if the loader can load the provided memory object.
 *
 * @param {object} _mem The memory object.
 * @returns {boolean} True if the url can be loaded.
 */
dwv.io.MultipartLoader.prototype.canLoadMemory = function (_mem) {
  return false;
};

/**
 * Get the file content type needed by the loader.
 *
 * @returns {number} One of the 'dwv.io.fileContentTypes'.
 */
dwv.io.MultipartLoader.prototype.loadFileAs = function () {
  return dwv.io.fileContentTypes.ArrayBuffer;
};

/**
 * Get the url content type needed by the loader.
 *
 * @returns {number} One of the 'dwv.io.urlContentTypes'.
 */
dwv.io.MultipartLoader.prototype.loadUrlAs = function () {
  return dwv.io.urlContentTypes.ArrayBuffer;
};

/**
 * Handle a load start event.
 * Default does nothing.
 *
 * @param {object} _event The load start event.
 */
dwv.io.MultipartLoader.prototype.onloadstart = function (_event) {};
/**
 * Handle a load progress event.
 * Default does nothing.
 *
 * @param {object} _event The progress event.
 */
dwv.io.MultipartLoader.prototype.onprogress = function (_event) {};
/**
 * Handle a load item event.
 * Default does nothing.
 *
 * @param {object} _event The load item event fired
 *   when a file item has been loaded successfully.
 */
dwv.io.MultipartLoader.prototype.onloaditem = function (_event) {};
/**
 * Handle a load event.
 * Default does nothing.
 *
 * @param {object} _event The load event fired
 *   when a file has been loaded successfully.
 */
dwv.io.MultipartLoader.prototype.onload = function (_event) {};
/**
 * Handle an load end event.
 * Default does nothing.
 *
 * @param {object} _event The load end event fired
 *  when a file load has completed, successfully or not.
 */
dwv.io.MultipartLoader.prototype.onloadend = function (_event) {};
/**
 * Handle an error event.
 * Default does nothing.
 *
 * @param {object} _event The error event.
 */
dwv.io.MultipartLoader.prototype.onerror = function (_event) {};
/**
 * Handle an abort event.
 * Default does nothing.
 *
 * @param {object} _event The abort event.
 */
dwv.io.MultipartLoader.prototype.onabort = function (_event) {};

/**
 * Add to Loader list.
 */
dwv.io.loaderList = dwv.io.loaderList || [];
dwv.io.loaderList.push('MultipartLoader');

// namespaces
var dwv = dwv || {};
dwv.io = dwv.io || {};

/**
 * Raw image loader.
 *
 * @class
 */
dwv.io.RawImageLoader = function () {
  // closure to self
  var self = this;

  /**
   * if abort is triggered, all image.onload callbacks have to be cancelled
   *
   * @type {boolean}
   * @private
   */
  var aborted = false;

  /**
   * Set the loader options.
   *
   * @param {object} _opt The input options.
   */
  this.setOptions = function (_opt) {
    // does nothing
  };

  /**
   * Is the load ongoing? TODO...
   *
   * @returns {boolean} True if loading.
   */
  this.isLoading = function () {
    return true;
  };

  /**
   * Create a Data URI from an HTTP request response.
   *
   * @param {object} response The HTTP request response.
   * @param {string} dataType The data type.
   * @returns {string} The data URI.
   * @private
   */
  function createDataUri(response, dataType) {
    // image type
    var imageType = dataType;
    if (!imageType || imageType === 'jpg') {
      imageType = 'jpeg';
    }
    // create uri
    var file = new Blob([response], {type: 'image/' + imageType});
    return window.URL.createObjectURL(file);
  }

  /**
   * Load data.
   *
   * @param {object} buffer The read data.
   * @param {string} origin The data origin.
   * @param {number} index The data index.
   */
  this.load = function (buffer, origin, index) {
    aborted = false;
    // create a DOM image
    var image = new Image();
    // triggered by ctx.drawImage
    image.onload = function (/*event*/) {
      try {
        if (!aborted) {
          self.onprogress({
            lengthComputable: true,
            loaded: 100,
            total: 100,
            index: index,
            source: origin
          });
          self.onload(dwv.image.getViewFromDOMImage(this, origin));
        }
      } catch (error) {
        self.onerror({
          error: error,
          source: origin
        });
      } finally {
        self.onloadend({
          source: origin
        });
      }
    };
    // storing values to pass them on
    image.origin = origin;
    image.index = index;
    if (typeof origin === 'string') {
      // url case
      var ext = origin.split('.').pop().toLowerCase();
      image.src = createDataUri(buffer, ext);
    } else {
      image.src = buffer;
    }
  };

  /**
   * Abort load.
   */
  this.abort = function () {
    aborted = true;
    self.onabort({});
    self.onloadend({});
  };

}; // class RawImageLoader

/**
 * Check if the loader can load the provided file.
 *
 * @param {object} file The file to check.
 * @returns {boolean} True if the file can be loaded.
 */
dwv.io.RawImageLoader.prototype.canLoadFile = function (file) {
  return file.type.match('image.*');
};

/**
 * Check if the loader can load the provided url.
 *
 * @param {string} url The url to check.
 * @param {object} options Optional url request options.
 * @returns {boolean} True if the url can be loaded.
 */
dwv.io.RawImageLoader.prototype.canLoadUrl = function (url, options) {
  // if there are options.requestHeaders, just base check on them
  if (typeof options !== 'undefined' &&
    typeof options.requestHeaders !== 'undefined') {
    // starts with 'image/'
    var isImage = function (element) {
      return element.name === 'Accept' &&
        dwv.utils.startsWith(element.value, 'image/');
    };
    return typeof options.requestHeaders.find(isImage) !== 'undefined';
  }

  var urlObjext = dwv.utils.getUrlFromUri(url);
  // extension
  var ext = dwv.utils.getFileExtension(urlObjext.pathname);
  var hasImageExt = (ext === 'jpeg') || (ext === 'jpg') ||
            (ext === 'png') || (ext === 'gif');
    // content type (for wado url)
  var contentType = urlObjext.searchParams.get('contentType');
  var hasContentType = contentType !== null &&
        typeof contentType !== 'undefined';
  var hasImageContentType = (contentType === 'image/jpeg') ||
        (contentType === 'image/png') ||
        (contentType === 'image/gif');

  return hasContentType ? hasImageContentType : hasImageExt;
};

/**
 * Check if the loader can load the provided memory object.
 *
 * @param {object} mem The memory object.
 * @returns {boolean} True if the object can be loaded.
 */
dwv.io.RawImageLoader.prototype.canLoadMemory = function (mem) {
  if (typeof mem.filename !== 'undefined') {
    return this.canLoadFile(mem.filename);
  }
  return false;
};

/**
 * Get the file content type needed by the loader.
 *
 * @returns {number} One of the 'dwv.io.fileContentTypes'.
 */
dwv.io.RawImageLoader.prototype.loadFileAs = function () {
  return dwv.io.fileContentTypes.DataURL;
};

/**
 * Get the url content type needed by the loader.
 *
 * @returns {number} One of the 'dwv.io.urlContentTypes'.
 */
dwv.io.RawImageLoader.prototype.loadUrlAs = function () {
  return dwv.io.urlContentTypes.ArrayBuffer;
};

/**
 * Handle a load start event.
 * Default does nothing.
 *
 * @param {object} _event The load start event.
 */
dwv.io.RawImageLoader.prototype.onloadstart = function (_event) {};
/**
 * Handle a progress event.
 * Default does nothing.
 *
 * @param {object} _event The progress event.
 */
dwv.io.RawImageLoader.prototype.onprogress = function (_event) {};
/**
 * Handle a load event.
 * Default does nothing.
 *
 * @param {object} _event The load event fired
 *   when a file has been loaded successfully.
 */
dwv.io.RawImageLoader.prototype.onload = function (_event) {};
/**
 * Handle an load end event.
 * Default does nothing.
 *
 * @param {object} _event The load end event fired
 *  when a file load has completed, successfully or not.
 */
dwv.io.RawImageLoader.prototype.onloadend = function (_event) {};
/**
 * Handle an error event.
 * Default does nothing.
 *
 * @param {object} _event The error event.
 */
dwv.io.RawImageLoader.prototype.onerror = function (_event) {};
/**
 * Handle an abort event.
 * Default does nothing.
 *
 * @param {object} _event The abort event.
 */
dwv.io.RawImageLoader.prototype.onabort = function (_event) {};

/**
 * Add to Loader list.
 */
dwv.io.loaderList = dwv.io.loaderList || [];
dwv.io.loaderList.push('RawImageLoader');

// namespaces
var dwv = dwv || {};
dwv.io = dwv.io || {};

/**
 * Raw video loader.
 * url example (cors enabled):
 *   https://raw.githubusercontent.com/clappr/clappr/master/test/fixtures/SampleVideo_360x240_1mb.mp4
 *
 * @class
 */
dwv.io.RawVideoLoader = function () {
  // closure to self
  var self = this;

  /**
   * Set the loader options.
   *
   * @param {object} _opt The input options.
   */
  this.setOptions = function (_opt) {
    // does nothing
  };

  /**
   * Is the load ongoing? TODO...
   *
   * @returns {boolean} True if loading.
   */
  this.isLoading = function () {
    return true;
  };

  /**
   * Create a Data URI from an HTTP request response.
   *
   * @param {object} response The HTTP request response.
   * @param {string} dataType The data type.
   * @returns {string} The data URI.
   * @private
   */
  function createDataUri(response, dataType) {
    // image data as string
    var bytes = new Uint8Array(response);
    var videoDataStr = '';
    for (var i = 0; i < bytes.byteLength; ++i) {
      videoDataStr += String.fromCharCode(bytes[i]);
    }
    // create uri
    var uri = 'data:video/' + dataType + ';base64,' + window.btoa(videoDataStr);
    return uri;
  }

  /**
   * Internal Data URI load.
   *
   * @param {object} buffer The read data.
   * @param {string} origin The data origin.
   * @param {number} index The data index.
   */
  this.load = function (buffer, origin, index) {
    // create a DOM video
    var video = document.createElement('video');
    if (typeof origin === 'string') {
      // url case
      var ext = origin.split('.').pop().toLowerCase();
      video.src = createDataUri(buffer, ext);
    } else {
      video.src = buffer;
    }
    // storing values to pass them on
    video.file = origin;
    video.index = index;
    // onload handler
    video.onloadedmetadata = function (/*event*/) {
      try {
        dwv.image.getViewFromDOMVideo(this,
          self.onloaditem, self.onload,
          self.onprogress, self.onloadend,
          index, origin);
      } catch (error) {
        self.onerror({
          error: error,
          source: origin
        });
        self.onloadend({
          source: origin
        });
      }
    };
  };

  /**
   * Abort load.
   */
  this.abort = function () {
    self.onabort({});
    self.onloadend({});
  };

}; // class RawVideoLoader

/**
 * Check if the loader can load the provided file.
 *
 * @param {object} file The file to check.
 * @returns {boolean} True if the file can be loaded.
 */
dwv.io.RawVideoLoader.prototype.canLoadFile = function (file) {
  return file.type.match('video.*');
};

/**
 * Check if the loader can load the provided url.
 *
 * @param {string} url The url to check.
 * @param {object} options Optional url request options.
 * @returns {boolean} True if the url can be loaded.
 */
dwv.io.RawVideoLoader.prototype.canLoadUrl = function (url, options) {
  // if there are options.requestHeaders, just base check on them
  if (typeof options !== 'undefined' &&
    typeof options.requestHeaders !== 'undefined') {
    // starts with 'video/'
    var isVideo = function (element) {
      return element.name === 'Accept' &&
        dwv.utils.startsWith(element.value, 'video/');
    };
    return typeof options.requestHeaders.find(isVideo) !== 'undefined';
  }

  var urlObjext = dwv.utils.getUrlFromUri(url);
  var ext = dwv.utils.getFileExtension(urlObjext.pathname);
  return (ext === 'mp4') || (ext === 'ogg') ||
            (ext === 'webm');
};

/**
 * Check if the loader can load the provided memory object.
 *
 * @param {object} mem The memory object.
 * @returns {boolean} True if the object can be loaded.
 */
dwv.io.RawVideoLoader.prototype.canLoadMemory = function (mem) {
  if (typeof mem.filename !== 'undefined') {
    return this.canLoadFile(mem.filename);
  }
  return false;
};

/**
 * Get the file content type needed by the loader.
 *
 * @returns {number} One of the 'dwv.io.fileContentTypes'.
 */
dwv.io.RawVideoLoader.prototype.loadFileAs = function () {
  return dwv.io.fileContentTypes.DataURL;
};

/**
 * Get the url content type needed by the loader.
 *
 * @returns {number} One of the 'dwv.io.urlContentTypes'.
 */
dwv.io.RawVideoLoader.prototype.loadUrlAs = function () {
  return dwv.io.urlContentTypes.ArrayBuffer;
};

/**
 * Handle a load start event.
 * Default does nothing.
 *
 * @param {object} _event The load start event.
 */
dwv.io.RawVideoLoader.prototype.onloadstart = function (_event) {};
/**
 * Handle a progress event.
 * Default does nothing.
 *
 * @param {object} _event The progress event.
 */
dwv.io.RawVideoLoader.prototype.onprogress = function (_event) {};
/**
 * Handle a load item event.
 * Default does nothing.
 *
 * @param {object} _event The load item event fired
 * when a file item has been loaded successfully.
 */
dwv.io.RawVideoLoader.prototype.onloaditem = function (_event) {};
/**
 * Handle a load event.
 * Default does nothing.
 *
 * @param {object} _event The load event fired
 * when a file has been loaded successfully.
 */
dwv.io.RawVideoLoader.prototype.onload = function (_event) {};
/**
 * Handle an load end event.
 * Default does nothing.
 *
 * @param {object} _event The load end event fired
 *  when a file load has completed, successfully or not.
 */
dwv.io.RawVideoLoader.prototype.onloadend = function (_event) {};
/**
 * Handle an error event.
 * Default does nothing.
 *
 * @param {object} _event The error event.
 */
dwv.io.RawVideoLoader.prototype.onerror = function (_event) {};
/**
 * Handle an abort event.
 * Default does nothing.
 *
 * @param {object} _event The abort event.
 */
dwv.io.RawVideoLoader.prototype.onabort = function (_event) {};

/**
 * Add to Loader list.
 */
dwv.io.loaderList = dwv.io.loaderList || [];
dwv.io.loaderList.push('RawVideoLoader');

// namespaces
var dwv = dwv || {};
dwv.io = dwv.io || {};
// external
var Konva = Konva || {};

/**
 * State class.
 * Saves: data url/path, display info.
 *
 * History:
 * - v0.5 (dwv 0.30.0, 12/2021)
 *   - store position as array
 *   - new draw position group key
 * - v0.4 (dwv 0.29.0, 06/2021)
 *   - move drawing details into meta property
 *   - remove scale center and translation, add offset
 * - v0.3 (dwv v0.23.0, 03/2018)
 *   - new drawing structure, drawings are now the full layer object and
 *     using toObject to avoid saving a string representation
 *   - new details structure: simple array of objects referenced by draw ids
 * - v0.2 (dwv v0.17.0, 12/2016)
 *   - adds draw details: array [nslices][nframes] of detail objects
 * - v0.1 (dwv v0.15.0, 07/2016)
 *   - adds version
 *   - drawings: array [nslices][nframes] with all groups
 * - initial release (dwv v0.10.0, 05/2015), no version number...
 *   - content: window-center, window-width, position, scale,
 *       scaleCenter, translation, drawings
 *   - drawings: array [nslices] with all groups
 *
 * @class
 */
dwv.io.State = function () {
  /**
   * Save the application state as JSON.
   *
   * @param {object} app The associated application.
   * @returns {string} The state as a JSON string.
   */
  this.toJSON = function (app) {
    var layerGroup = app.getActiveLayerGroup();
    var viewController =
      layerGroup.getActiveViewLayer().getViewController();
    var position = viewController.getCurrentIndex();
    var drawLayer = layerGroup.getActiveDrawLayer();
    var drawController = drawLayer.getDrawController();
    // return a JSON string
    return JSON.stringify({
      version: '0.5',
      'window-center': viewController.getWindowLevel().center,
      'window-width': viewController.getWindowLevel().width,
      position: position.getValues(),
      scale: app.getAddedScale(),
      offset: app.getOffset(),
      drawings: drawLayer.getKonvaLayer().toObject(),
      drawingsDetails: drawController.getDrawStoreDetails()
    });
  };
  /**
   * Load an application state from JSON.
   *
   * @param {string} json The JSON representation of the state.
   * @returns {object} The state object.
   */
  this.fromJSON = function (json) {
    var data = JSON.parse(json);
    var res = null;
    if (data.version === '0.1') {
      res = readV01(data);
    } else if (data.version === '0.2') {
      res = readV02(data);
    } else if (data.version === '0.3') {
      res = readV03(data);
    } else if (data.version === '0.4') {
      res = readV04(data);
    } else if (data.version === '0.5') {
      res = readV05(data);
    } else {
      throw new Error('Unknown state file format version: \'' +
        data.version + '\'.');
    }
    return res;
  };
  /**
   * Load an application state from JSON.
   *
   * @param {object} app The app to apply the state to.
   * @param {object} data The state data.
   */
  this.apply = function (app, data) {
    var layerGroup = app.getActiveLayerGroup();
    var viewController =
      layerGroup.getActiveViewLayer().getViewController();
    // display
    viewController.setWindowLevel(
      data['window-center'], data['window-width']);
    // position is index...
    viewController.setCurrentIndex(new dwv.math.Index(data.position));
    // apply saved scale on top of current base one
    var baseScale = app.getActiveLayerGroup().getBaseScale();
    var scale = null;
    var offset = null;
    if (typeof data.scaleCenter !== 'undefined') {
      scale = {
        x: data.scale * baseScale.x,
        y: data.scale * baseScale.y,
        z: 1
      };
      // ---- transform translation (now) ----
      // Tx = -offset.x * scale.x
      // => offset.x = -Tx / scale.x
      // ---- transform translation (before) ----
      // origin.x = centerX - (centerX - origin.x) * (newZoomX / zoom.x);
      // (zoom.x -> initial zoom = base scale, origin.x = 0)
      // Tx = origin.x + (trans.x * zoom.x)
      var originX = data.scaleCenter.x - data.scaleCenter.x * data.scale;
      var originY = data.scaleCenter.y - data.scaleCenter.y * data.scale;
      var oldTx = originX + data.translation.x * scale.x;
      var oldTy = originY + data.translation.y * scale.y;
      offset = {
        x: -oldTx / scale.x,
        y: -oldTy / scale.y,
        z: 0
      };
    } else {
      scale = {
        x: data.scale.x * baseScale.x,
        y: data.scale.y * baseScale.y,
        z: baseScale.z
      };
      offset = {
        x: data.offset.x,
        y: data.offset.y,
        z: 0
      };
    }
    app.getActiveLayerGroup().setScale(scale);
    app.getActiveLayerGroup().setOffset(offset);
    // render to draw the view layer
    app.render(0); //todo: fix
    // drawings (will draw the draw layer)
    app.setDrawings(data.drawings, data.drawingsDetails);
  };
  /**
   * Read an application state from an Object in v0.1 format.
   *
   * @param {object} data The Object representation of the state.
   * @returns {object} The state object.
   * @private
   */
  function readV01(data) {
    // v0.1 -> v0.2
    var v02DAndD = dwv.io.v01Tov02DrawingsAndDetails(data.drawings);
    // v0.2 -> v0.3, v0.4
    data.drawings = dwv.io.v02Tov03Drawings(v02DAndD.drawings).toObject();
    data.drawingsDetails = dwv.io.v03Tov04DrawingsDetails(
      v02DAndD.drawingsDetails);
    // v0.4 -> v0.5
    data = dwv.io.v04Tov05Data(data);
    data.drawings = dwv.io.v04Tov05Drawings(data.drawings);
    return data;
  }
  /**
   * Read an application state from an Object in v0.2 format.
   *
   * @param {object} data The Object representation of the state.
   * @returns {object} The state object.
   * @private
   */
  function readV02(data) {
    // v0.2 -> v0.3, v0.4
    data.drawings = dwv.io.v02Tov03Drawings(data.drawings).toObject();
    data.drawingsDetails = dwv.io.v03Tov04DrawingsDetails(
      dwv.io.v02Tov03DrawingsDetails(data.drawingsDetails));
    // v0.4 -> v0.5
    data = dwv.io.v04Tov05Data(data);
    data.drawings = dwv.io.v04Tov05Drawings(data.drawings);
    return data;
  }
  /**
   * Read an application state from an Object in v0.3 format.
   *
   * @param {object} data The Object representation of the state.
   * @returns {object} The state object.
   * @private
   */
  function readV03(data) {
    // v0.3 -> v0.4
    data.drawingsDetails = dwv.io.v03Tov04DrawingsDetails(data.drawingsDetails);
    // v0.4 -> v0.5
    data = dwv.io.v04Tov05Data(data);
    data.drawings = dwv.io.v04Tov05Drawings(data.drawings);
    return data;
  }
  /**
   * Read an application state from an Object in v0.4 format.
   *
   * @param {object} data The Object representation of the state.
   * @returns {object} The state object.
   * @private
   */
  function readV04(data) {
    // v0.4 -> v0.5
    data = dwv.io.v04Tov05Data(data);
    data.drawings = dwv.io.v04Tov05Drawings(data.drawings);
    return data;
  }
  /**
   * Read an application state from an Object in v0.5 format.
   *
   * @param {object} data The Object representation of the state.
   * @returns {object} The state object.
   * @private
   */
  function readV05(data) {
    return data;
  }

}; // State class

/**
 * Convert drawings from v0.2 to v0.3.
 * v0.2: one layer per slice/frame
 * v0.3: one layer, one group per slice. setDrawing expects the full stage
 *
 * @param {Array} drawings An array of drawings.
 * @returns {object} The layer with the converted drawings.
 */
dwv.io.v02Tov03Drawings = function (drawings) {
  // Auxiliar variables
  var group, groupShapes, parentGroup;
  // Avoid errors when dropping multiple states
  //drawLayer.getChildren().each(function(node){
  //    node.visible(false);
  //});

  var drawLayer = new Konva.Layer({
    listening: false,
    visible: true
  });

  // Get the positions-groups data
  var groupDrawings = typeof drawings === 'string'
    ? JSON.parse(drawings) : drawings;
  // Iterate over each position-groups
  for (var k = 0, lenk = groupDrawings.length; k < lenk; ++k) {
    // Iterate over each frame
    for (var f = 0, lenf = groupDrawings[k].length; f < lenf; ++f) {
      groupShapes = groupDrawings[k][f];
      if (groupShapes.length !== 0) {
        // Create position-group set as visible and append it to drawLayer
        parentGroup = new Konva.Group({
          id: dwv.draw.getDrawPositionGroupId(new dwv.math.Index([1, 1, k, f])),
          name: 'position-group',
          visible: false
        });

        // Iterate over shapes-group
        for (var g = 0, leng = groupShapes.length; g < leng; ++g) {
          // create the konva group
          group = Konva.Node.create(groupShapes[g]);
          // enforce draggable: only the shape was draggable in v0.2,
          // now the whole group is.
          group.draggable(true);
          group.getChildren().forEach(function (gnode) {
            gnode.draggable(false);
          });
          // add to position group
          parentGroup.add(group);
        }
        // add to layer
        drawLayer.add(parentGroup);
      }
    }
  }

  return drawLayer;
};

/**
 * Convert drawings from v0.1 to v0.2.
 * v0.1: text on its own
 * v0.2: text as part of label
 *
 * @param {Array} inputDrawings An array of drawings.
 * @returns {object} The converted drawings.
 */
dwv.io.v01Tov02DrawingsAndDetails = function (inputDrawings) {
  var newDrawings = [];
  var drawingsDetails = {};

  var drawGroups;
  var drawGroup;
  // loop over each slice
  for (var k = 0, lenk = inputDrawings.length; k < lenk; ++k) {
    // loop over each frame
    newDrawings[k] = [];
    for (var f = 0, lenf = inputDrawings[k].length; f < lenf; ++f) {
      // draw group
      drawGroups = inputDrawings[k][f];
      var newFrameDrawings = [];
      // Iterate over shapes-group
      for (var g = 0, leng = drawGroups.length; g < leng; ++g) {
        // create konva group from input
        drawGroup = Konva.Node.create(drawGroups[g]);
        // force visible (not set in state)
        drawGroup.visible(true);
        // label position
        var pos = {x: 0, y: 0};
        // update shape colour
        var kshape = drawGroup.getChildren(function (node) {
          return node.name() === 'shape';
        })[0];
        kshape.stroke(dwv.utils.colourNameToHex(kshape.stroke()));
        // special line case
        if (drawGroup.name() === 'line-group') {
          // update name
          drawGroup.name('ruler-group');
          // add ticks
          var ktick0 = new Konva.Line({
            points: [kshape.points()[0],
              kshape.points()[1],
              kshape.points()[0],
              kshape.points()[1]],
            name: 'shape-tick0'
          });
          drawGroup.add(ktick0);
          var ktick1 = new Konva.Line({
            points: [kshape.points()[2],
              kshape.points()[3],
              kshape.points()[2],
              kshape.points()[3]],
            name: 'shape-tick1'
          });
          drawGroup.add(ktick1);
        }
        // special protractor case: update arc name
        var karcs = drawGroup.getChildren(function (node) {
          return node.name() === 'arc';
        });
        if (karcs.length === 1) {
          karcs[0].name('shape-arc');
        }
        // get its text
        var ktexts = drawGroup.getChildren(function (node) {
          return node.name() === 'text';
        });
        // update text: move it into a label
        var ktext = new Konva.Text({
          name: 'text',
          text: ''
        });
        if (ktexts.length === 1) {
          pos.x = ktexts[0].x();
          pos.y = ktexts[0].y();
          // remove it from the group
          ktexts[0].remove();
          // use it
          ktext = ktexts[0];
        } else {
          // use shape position if no text
          if (kshape.points().length !== 0) {
            pos = {x: kshape.points()[0],
              y: kshape.points()[1]};
          }
        }
        // create new label with text and tag
        var klabel = new Konva.Label({
          x: pos.x,
          y: pos.y,
          name: 'label'
        });
        klabel.add(ktext);
        klabel.add(new Konva.Tag());
        // add label to group
        drawGroup.add(klabel);
        // add group to list
        newFrameDrawings.push(JSON.stringify(drawGroup.toObject()));

        // create details (v0.3 format)
        var textExpr = ktext.text();
        var txtLen = textExpr.length;
        var quant = null;
        // adapt to text with flag
        if (drawGroup.name() === 'ruler-group') {
          quant = {
            length: {
              value: parseFloat(textExpr.substring(0, txtLen - 2)),
              unit: textExpr.substring(-2)
            }
          };
          textExpr = '{length}';
        } else if (drawGroup.name() === 'ellipse-group' ||
                    drawGroup.name() === 'rectangle-group') {
          quant = {
            surface: {
              value: parseFloat(textExpr.substring(0, txtLen - 3)),
              unit: textExpr.substring(-3)
            }
          };
          textExpr = '{surface}';
        } else if (drawGroup.name() === 'protractor-group' ||
                    drawGroup.name() === 'rectangle-group') {
          quant = {
            angle: {
              value: parseFloat(textExpr.substring(0, txtLen - 1)),
              unit: textExpr.substring(-1)
            }
          };
          textExpr = '{angle}';
        }
        // set details
        drawingsDetails[drawGroup.id()] = {
          textExpr: textExpr,
          longText: '',
          quant: quant
        };

      }
      newDrawings[k].push(newFrameDrawings);
    }
  }

  return {drawings: newDrawings, drawingsDetails: drawingsDetails};
};

/**
 * Convert drawing details from v0.2 to v0.3.
 * - v0.2: array [nslices][nframes] with all
 * - v0.3: simple array of objects referenced by draw ids
 *
 * @param {Array} details An array of drawing details.
 * @returns {object} The converted drawings.
 */
dwv.io.v02Tov03DrawingsDetails = function (details) {
  var res = {};
  // Get the positions-groups data
  var groupDetails = typeof details === 'string'
    ? JSON.parse(details) : details;
  // Iterate over each position-groups
  for (var k = 0, lenk = groupDetails.length; k < lenk; ++k) {
    // Iterate over each frame
    for (var f = 0, lenf = groupDetails[k].length; f < lenf; ++f) {
      // Iterate over shapes-group
      for (var g = 0, leng = groupDetails[k][f].length; g < leng; ++g) {
        var group = groupDetails[k][f][g];
        res[group.id] = {
          textExpr: group.textExpr,
          longText: group.longText,
          quant: group.quant
        };
      }
    }
  }
  return res;
};

/**
 * Convert drawing details from v0.3 to v0.4.
 * - v0.3: properties at group root
 * - v0.4: properties in group meta object
 *
 * @param {Array} details An array of drawing details.
 * @returns {object} The converted drawings.
 */
dwv.io.v03Tov04DrawingsDetails = function (details) {
  var res = {};
  var keys = Object.keys(details);
  // Iterate over each position-groups
  for (var k = 0, lenk = keys.length; k < lenk; ++k) {
    var detail = details[keys[k]];
    res[keys[k]] = {
      meta: {
        textExpr: detail.textExpr,
        longText: detail.longText,
        quantification: detail.quant
      }
    };
  }
  return res;
};

/**
 * Convert drawing from v0.4 to v0.5.
 * - v0.4: position as object
 * - v0.5: position as array
 *
 * @param {Array} data An array of drawing.
 * @returns {object} The converted drawings.
 */
dwv.io.v04Tov05Data = function (data) {
  var pos = data.position;
  data.position = [pos.i, pos.j, pos.k];
  return data;
};

/**
 * Convert drawing from v0.4 to v0.5.
 * - v0.4: draw id as 'slice-0_frame-1'
 * - v0.5: draw id as '#2-0_#3-1''
 *
 * @param {Array} inputDrawings An array of drawing.
 * @returns {object} The converted drawings.
 */
dwv.io.v04Tov05Drawings = function (inputDrawings) {
  // Iterate over each position-groups
  var posGroups = inputDrawings.children;
  for (var k = 0, lenk = posGroups.length; k < lenk; ++k) {
    var posGroup = posGroups[k];
    var id = posGroup.attrs.id;
    var ids = id.split('_');
    var sliceNumber = parseInt(ids[0].substring(6), 10); // 'slice-0'
    var frameNumber = parseInt(ids[1].substring(6), 10); // 'frame-0'
    var newId = '#2-';
    if (sliceNumber === 0 && frameNumber !== 0) {
      newId += frameNumber;
    } else {
      newId += sliceNumber;
    }
    posGroup.attrs.id = newId;
  }
  return inputDrawings;
};

// namespaces
var dwv = dwv || {};
dwv.io = dwv.io || {};

// url content types
dwv.io.urlContentTypes = {
  Text: 0,
  ArrayBuffer: 1
};

/**
 * Urls loader.
 *
 * @class
 */
dwv.io.UrlsLoader = function () {
  /**
   * Closure to self.
   *
   * @private
   * @type {object}
   */
  var self = this;

  /**
   * Input data.
   *
   * @private
   * @type {Array}
   */
  var inputData = null;

  /**
   * Array of launched requests.
   *
   * @private
   * @type {Array}
   */
  var requests = [];

  /**
   * Data loader.
   *
   * @private
   * @type {object}
   */
  var runningLoader = null;

  /**
   * Number of loaded data.
   *
   * @private
   * @type {number}
   */
  var nLoad = 0;

  /**
   * Number of load end events.
   *
   * @private
   * @type {number}
   */
  var nLoadend = 0;

  /**
   * Flag to know if the load is aborting.
   *
   * @private
   * @type {boolean}
   */
  var aborting;

  /**
   * The default character set (optional).
   *
   * @private
   * @type {string}
   */
  var defaultCharacterSet;

  /**
   * Get the default character set.
   *
   * @returns {string} The default character set.
   */
  this.getDefaultCharacterSet = function () {
    return defaultCharacterSet;
  };

  /**
   * Set the default character set.
   *
   * @param {string} characterSet The character set.
   */
  this.setDefaultCharacterSet = function (characterSet) {
    defaultCharacterSet = characterSet;
  };

  /**
   * Store the current input.
   *
   * @param {object} data The input data.
   * @private
   */
  function storeInputData(data) {
    inputData = data;
    // reset counters
    nLoad = 0;
    nLoadend = 0;
    // reset flag
    aborting = false;
    // clear storage
    clearStoredRequests();
    clearStoredLoader();
  }

  /**
   * Store a launched request.
   *
   * @param {object} request The launched request.
   * @private
   */
  function storeRequest(request) {
    requests.push(request);
  }

  /**
   * Clear the stored requests.
   *
   * @private
   */
  function clearStoredRequests() {
    requests = [];
  }

  /**
   * Store the launched loader.
   *
   * @param {object} loader The launched loader.
   * @private
   */
  function storeLoader(loader) {
    runningLoader = loader;
  }

  /**
   * Clear the stored loader.
   *
   * @private
   */
  function clearStoredLoader() {
    runningLoader = null;
  }

  /**
   * Launch a load item event and call addLoad.
   *
   * @param {object} event The load data event.
   * @private
   */
  function addLoadItem(event) {
    self.onloaditem(event);
    addLoad();
  }

  /**
   * Increment the number of loaded data
   *   and call onload if loaded all data.
   *
   * @param {object} _event The load data event.
   * @private
   */
  function addLoad(_event) {
    nLoad++;
    // call self.onload when all is loaded
    // (not using the input event since it is not the
    //   general load)
    if (nLoad === inputData.length) {
      self.onload({
        source: inputData
      });
    }
  }

  /**
   * Increment the counter of load end events
   *   and run callbacks when all done, erroneus or not.
   *
   * @param {object} _event The load end event.
   * @private
   */
  function addLoadend(_event) {
    nLoadend++;
    // call self.onloadend when all is run
    // (not using the input event since it is not the
    //   general load end)
    // x2 to count for request + load
    if (nLoadend === 2 * inputData.length) {
      self.onloadend({
        source: inputData
      });
    }
  }

  /**
   * Augment a callback event with a srouce.
   *
   * @param {object} callback The callback to augment its event.
   * @param {object} source The source to add to the event.
   * @returns {Function} The augmented callback.
   * @private
   */
  function augmentCallbackEvent(callback, source) {
    return function (event) {
      event.source = source;
      callback(event);
    };
  }

  /**
   * Load a list of URLs or a DICOMDIR.
   *
   * @param {Array} data The list of urls to load.
   * @param {object} options Load options.
   */
  this.load = function (data, options) {
    // send start event
    self.onloadstart({
      source: data
    });

    // check if DICOMDIR case
    if (data.length === 1 &&
            (dwv.utils.endsWith(data[0], 'DICOMDIR') ||
             dwv.utils.endsWith(data[0], '.dcmdir'))) {
      loadDicomDir(data[0], options);
    } else {
      loadUrls(data, options);
    }
  };

  /**
   * Load a list of urls.
   *
   * @param {Array} data The list of urls to load.
   * @param {object} options The options object, can contain:
   *  - requestHeaders: an array of {name, value} to use as request headers
   *  - withCredentials: boolean xhr.withCredentials flag to pass
   *    to the request
   *  - batchSize: the size of the request url batch
   * @private
   */
  function loadUrls(data, options) {
    // check input
    if (typeof data === 'undefined' || data.length === 0) {
      return;
    }
    storeInputData(data);

    // create prgress handler
    var mproghandler = new dwv.utils.MultiProgressHandler(self.onprogress);
    mproghandler.setNToLoad(data.length);

    // create loaders
    var loaders = [];
    for (var m = 0; m < dwv.io.loaderList.length; ++m) {
      loaders.push(new dwv.io[dwv.io.loaderList[m]]());
    }

    // find an appropriate loader
    var dataElement = data[0];
    var loader = null;
    var foundLoader = false;
    for (var l = 0; l < loaders.length; ++l) {
      loader = loaders[l];
      if (loader.canLoadUrl(dataElement, options)) {
        foundLoader = true;
        // load options
        loader.setOptions({
          numberOfFiles: data.length,
          defaultCharacterSet: self.getDefaultCharacterSet()
        });
        // set loader callbacks
        // loader.onloadstart: nothing to do
        loader.onprogress = mproghandler.getUndefinedMonoProgressHandler(1);
        if (typeof loader.onloaditem === 'undefined') {
          // handle loaditem locally
          loader.onload = addLoadItem;
        } else {
          loader.onloaditem = self.onloaditem;
          loader.onload = addLoad;
        }
        loader.onloadend = addLoadend;
        loader.onerror = self.onerror;
        loader.onabort = self.onabort;

        // store loader
        storeLoader(loader);
        // exit
        break;
      }
    }
    if (!foundLoader) {
      throw new Error('No loader found for url: ' + dataElement);
    }

    var getLoadHandler = function (loader, dataElement, i) {
      return function (event) {
        // check response status
        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Response_codes
        // status 200: "OK"; status 0: "debug"
        var status = event.target.status;
        if (status !== 200 && status !== 0) {
          self.onerror({
            source: dataElement,
            error: 'GET ' + event.target.responseURL +
                            ' ' + event.target.status +
                            ' (' + event.target.statusText + ')',
            target: event.target
          });
          addLoadend();
        } else {
          loader.load(event.target.response, dataElement, i);
        }
      };
    };

    // store last run request index
    var lastRunRequestIndex = 0;
    var requestOnLoadEnd = function () {
      addLoadend();
      // launch next in queue
      if (lastRunRequestIndex < requests.length - 1 && !aborting) {
        ++lastRunRequestIndex;
        requests[lastRunRequestIndex].send(null);
      }
    };

    // loop on I/O elements
    for (var i = 0; i < data.length; ++i) {
      dataElement = data[i];

      // check loader
      if (!loader.canLoadUrl(dataElement, options)) {
        throw new Error('Input url of different type: ' + dataElement);
      }
      /**
       * The http request.
       *
       * @external XMLHttpRequest
       * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest
       */
      var request = new XMLHttpRequest();
      request.open('GET', dataElement, true);

      // request options
      if (typeof options !== 'undefined') {
        // optional request headers
        if (typeof options.requestHeaders !== 'undefined') {
          var requestHeaders = options.requestHeaders;
          for (var j = 0; j < requestHeaders.length; ++j) {
            if (typeof requestHeaders[j].name !== 'undefined' &&
              typeof requestHeaders[j].value !== 'undefined') {
              request.setRequestHeader(
                requestHeaders[j].name, requestHeaders[j].value);
            }
          }
        }
        // optional withCredentials
        // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials
        if (typeof options.withCredentials !== 'undefined') {
          request.withCredentials = options.withCredentials;
        }
      }

      // set request callbacks
      // request.onloadstart: nothing to do
      request.onprogress = augmentCallbackEvent(
        mproghandler.getMonoProgressHandler(i, 0), dataElement);
      request.onload = getLoadHandler(loader, dataElement, i);
      request.onloadend = requestOnLoadEnd;
      request.onerror = augmentCallbackEvent(self.onerror, dataElement);
      request.onabort = augmentCallbackEvent(self.onabort, dataElement);
      // response type (default is 'text')
      if (loader.loadUrlAs() === dwv.io.urlContentTypes.ArrayBuffer) {
        request.responseType = 'arraybuffer';
      }

      // store request
      storeRequest(request);
    }

    // launch requests in batch
    var batchSize = requests.length;
    if (typeof options !== 'undefined') {
      // optional request batch size
      if (typeof options.batchSize !== 'undefined' && batchSize !== 0) {
        batchSize = Math.min(options.batchSize, requests.length);
      }
    }
    for (var r = 0; r < batchSize; ++r) {
      if (!aborting) {
        lastRunRequestIndex = r;
        requests[lastRunRequestIndex].send(null);
      }
    }
  }

  /**
   * Load a DICOMDIR.
   *
   * @param {string} dicomDirUrl The DICOMDIR url.
   * @param {object} options Load options.
   * @private
   */
  function loadDicomDir(dicomDirUrl, options) {
    // read DICOMDIR
    var request = new XMLHttpRequest();
    request.open('GET', dicomDirUrl, true);
    request.responseType = 'arraybuffer';
    // request.onloadstart: nothing to do
    request.onload = function (event) {
      // check status
      var status = event.target.status;
      if (status !== 200 && status !== 0) {
        self.onerror({
          source: dicomDirUrl,
          error: 'GET ' + event.target.responseURL +
                        ' ' + event.target.status +
                        ' (' + event.target.statusText + ')',
          target: event.target
        });
        self.onloadend({});
        return;
      }
      // get the file list
      var list = dwv.dicom.getFileListFromDicomDir(event.target.response);
      // use the first list
      var urls = list[0][0];
      // append root url
      var rootUrl = dwv.utils.getRootPath(dicomDirUrl);
      var fullUrls = [];
      for (var i = 0; i < urls.length; ++i) {
        fullUrls.push(rootUrl + '/' + urls[i]);
      }
      // load urls
      loadUrls(fullUrls, options);
    };
    request.onerror = function (event) {
      augmentCallbackEvent(self.onerror, dicomDirUrl)(event);
      self.onloadend({});
    };
    request.onabort = function (event) {
      augmentCallbackEvent(self.onabort, dicomDirUrl)(event);
      self.onloadend({});
    };
    // request.onloadend: nothing to do
    // send request
    request.send(null);
  }

  /**
   * Abort a load.
   */
  this.abort = function () {
    aborting = true;
    // abort non finished requests
    for (var i = 0; i < requests.length; ++i) {
      // 0: UNSENT, 1: OPENED, 2: HEADERS_RECEIVED (send()), 3: LOADING, 4: DONE
      if (requests[i].readyState !== 4) {
        requests[i].abort();
      }
    }
    // abort loader
    if (runningLoader && runningLoader.isLoading()) {
      runningLoader.abort();
    }
  };

}; // class UrlsLoader

/**
 * Handle a load start event.
 * Default does nothing.
 *
 * @param {object} _event The load start event.
 */
dwv.io.UrlsLoader.prototype.onloadstart = function (_event) {};
/**
 * Handle a load progress event.
 * Default does nothing.
 *
 * @param {object} _event The progress event.
 */
dwv.io.UrlsLoader.prototype.onprogress = function (_event) {};
/**
 * Handle a load item event.
 * Default does nothing.
 *
 * @param {object} _event The load item event fired
 *   when a file item has been loaded successfully.
 */
dwv.io.UrlsLoader.prototype.onloaditem = function (_event) {};
/**
 * Handle a load event.
 * Default does nothing.
 *
 * @param {object} _event The load event fired
 *   when a file has been loaded successfully.
 */
dwv.io.UrlsLoader.prototype.onload = function (_event) {};
/**
 * Handle a load end event.
 * Default does nothing.
 *
 * @param {object} _event The load end event fired
 *  when a file load has completed, successfully or not.
 */
dwv.io.UrlsLoader.prototype.onloadend = function (_event) {};
/**
 * Handle an error event.
 * Default does nothing.
 *
 * @param {object} _event The error event.
 */
dwv.io.UrlsLoader.prototype.onerror = function (_event) {};
/**
 * Handle an abort event.
 * Default does nothing.
 *
 * @param {object} _event The abort event.
 */
dwv.io.UrlsLoader.prototype.onabort = function (_event) {};

// namespaces
var dwv = dwv || {};
dwv.io = dwv.io || {};
/**
 * The zip library.
 *
 * @external JSZip
 * @see https://github.com/Stuk/jszip
 */
var JSZip = JSZip || {};

/**
 * ZIP data loader.
 *
 * @class
 */
dwv.io.ZipLoader = function () {
  // closure to self
  var self = this;

  /**
   * Loading flag.
   *
   * @private
   * @type {boolean}
   */
  var isLoading = false;

  /**
   * Set the loader options.
   *
   * @param {object} _opt The input options.
   */
  this.setOptions = function (_opt) {
    // does nothing
  };

  /**
   * Is the load ongoing?
   *
   * @returns {boolean} True if loading.
   */
  this.isLoading = function () {
    return isLoading;
  };

  var filename = '';
  var files = [];
  var zobjs = null;

  /**
   * JSZip.async callback
   *
   * @param {ArrayBuffer} content unzipped file image
   * @param {object} origin The origin of the file.
   * @param {number} index The data index.
   * @private
   */
  function zipAsyncCallback(content, origin, index) {
    files.push({filename: filename, data: content});

    // sent un-ziped progress with the data index
    // (max 50% to take into account the memory loading)
    var unzipPercent = files.length * 100 / zobjs.length;
    self.onprogress({
      lengthComputable: true,
      loaded: (unzipPercent / 2),
      total: 100,
      index: index,
      item: {
        loaded: unzipPercent,
        total: 100,
        source: origin
      }
    });

    // recursively call until we have all the files
    if (files.length < zobjs.length) {
      var num = files.length;
      filename = zobjs[num].name;
      zobjs[num].async('arrayBuffer').then(function (content) {
        zipAsyncCallback(content, origin, index);
      });
    } else {
      var memoryIO = new dwv.io.MemoryLoader();
      // memoryIO.onloadstart: nothing to do
      memoryIO.onprogress = function (progress) {
        // add 50% to take into account the un-zipping
        progress.loaded = 50 + progress.loaded / 2;
        // set data index
        progress.index = index;
        self.onprogress(progress);
      };
      memoryIO.onloaditem = self.onloaditem;
      memoryIO.onload = self.onload;
      memoryIO.onloadend = function (event) {
        // reset loading flag
        isLoading = false;
        // call listeners
        self.onloadend(event);
      };
      memoryIO.onerror = self.onerror;
      memoryIO.onabort = self.onabort;
      // launch
      memoryIO.load(files);
    }
  }

  /**
   * Load data.
   *
   * @param {object} buffer The DICOM buffer.
   * @param {string} origin The data origin.
   * @param {number} index The data index.
   */
  this.load = function (buffer, origin, index) {
    // send start event
    this.onloadstart({
      source: origin
    });
    // set loading flag
    isLoading = true;

    JSZip.loadAsync(buffer).then(function (zip) {
      files = [];
      zobjs = zip.file(/.*\.dcm/);
      // recursively load zip files into the files array
      var num = files.length;
      filename = zobjs[num].name;
      zobjs[num].async('arrayBuffer').then(function (content) {
        zipAsyncCallback(content, origin, index);
      });
    });
  };

  /**
   * Abort load: pass to listeners.
   */
  this.abort = function () {
    // reset loading flag
    isLoading = false;
    // call listeners
    self.onabort({});
    self.onloadend({});
  };

}; // class DicomDataLoader

/**
 * Check if the loader can load the provided file.
 *
 * @param {object} file The file to check.
 * @returns {boolean} True if the file can be loaded.
 */
dwv.io.ZipLoader.prototype.canLoadFile = function (file) {
  var ext = dwv.utils.getFileExtension(file.name);
  return (ext === 'zip');
};

/**
 * Check if the loader can load the provided url.
 *
 * @param {string} url The url to check.
 * @param {object} options Optional url request options.
 * @returns {boolean} True if the url can be loaded.
 */
dwv.io.ZipLoader.prototype.canLoadUrl = function (url, options) {
  // if there are options.requestHeaders, just base check on them
  if (typeof options !== 'undefined' &&
    typeof options.requestHeaders !== 'undefined') {
    // starts with 'application/zip'
    var isZip = function (element) {
      return element.name === 'Accept' &&
        dwv.utils.startsWith(element.value, 'application/zip');
    };
    return typeof options.requestHeaders.find(isZip) !== 'undefined';
  }

  var urlObjext = dwv.utils.getUrlFromUri(url);
  var ext = dwv.utils.getFileExtension(urlObjext.pathname);
  return (ext === 'zip');
};

/**
 * Check if the loader can load the provided memory object.
 *
 * @param {object} _mem The memory object.
 * @returns {boolean} True if the object can be loaded.
 */
dwv.io.ZipLoader.prototype.canLoadMemory = function (_mem) {
  return false;
};

/**
 * Get the file content type needed by the loader.
 *
 * @returns {number} One of the 'dwv.io.fileContentTypes'.
 */
dwv.io.ZipLoader.prototype.loadFileAs = function () {
  return dwv.io.fileContentTypes.ArrayBuffer;
};

/**
 * Get the url content type needed by the loader.
 *
 * @returns {number} One of the 'dwv.io.urlContentTypes'.
 */
dwv.io.ZipLoader.prototype.loadUrlAs = function () {
  return dwv.io.urlContentTypes.ArrayBuffer;
};

/**
 * Handle a load start event.
 * Default does nothing.
 *
 * @param {object} _event The load start event.
 */
dwv.io.ZipLoader.prototype.onloadstart = function (_event) {};
/**
 * Handle a load progress event.
 * Default does nothing.
 *
 * @param {object} _event The progress event.
 */
dwv.io.ZipLoader.prototype.onprogress = function (_event) {};
/**
 * Handle a load item event.
 * Default does nothing.
 *
 * @param {object} _event The load item event fired
 *   when a file item has been loaded successfully.
 */
dwv.io.ZipLoader.prototype.onloaditem = function (_event) {};
/**
 * Handle a load event.
 * Default does nothing.
 *
 * @param {object} _event The load event fired
 *   when a file has been loaded successfully.
 */
dwv.io.ZipLoader.prototype.onload = function (_event) {};
/**
 * Handle an load end event.
 * Default does nothing.
 *
 * @param {object} _event The load end event fired
 *  when a file load has completed, successfully or not.
 */
dwv.io.ZipLoader.prototype.onloadend = function (_event) {};
/**
 * Handle an error event.
 * Default does nothing.
 *
 * @param {object} _event The error event.
 */
dwv.io.ZipLoader.prototype.onerror = function (_event) {};
/**
 * Handle an abort event.
 * Default does nothing.
 *
 * @param {object} _event The abort event.
 */
dwv.io.ZipLoader.prototype.onabort = function (_event) {};

/**
 * Add to Loader list.
 */
dwv.io.loaderList = dwv.io.loaderList || [];
dwv.io.loaderList.push('ZipLoader');

// namespaces
var dwv = dwv || {};
/** @namespace */
dwv.math = dwv.math || {};

/**
 * Circular Bucket Queue.
 *
 * Returns input'd points in sorted order. All operations run in roughly O(1)
 * time (for input with small cost values), but it has a strict requirement:
 *
 * If the most recent point had a cost of c, any points added should have a cost
 * c' in the range c <= c' <= c + (capacity - 1).
 *
 * @class
 * @param {number} bits Number of bits.
 * @param {Function} cost_functor The cost functor.
 */
dwv.math.BucketQueue = function (bits, cost_functor) {
  this.bucketCount = 1 << bits; // # of buckets = 2^bits
  this.mask = this.bucketCount - 1; // 2^bits - 1 = index mask
  this.size = 0;

  this.loc = 0; // Current index in bucket list

  // Cost defaults to item value
  this.cost = (typeof (cost_functor) !== 'undefined')
    ? cost_functor : function (item) {
      return item;
    };

  this.buckets = this.buildArray(this.bucketCount);
};

dwv.math.BucketQueue.prototype.push = function (item) {
  // Prepend item to the list in the appropriate bucket
  var bucket = this.getBucket(item);
  item.next = this.buckets[bucket];
  this.buckets[bucket] = item;

  this.size++;
};

dwv.math.BucketQueue.prototype.pop = function () {
  if (this.size === 0) {
    throw new Error('Cannot pop, bucketQueue is empty.');
  }

  // Find first empty bucket
  while (this.buckets[this.loc] === null) {
    this.loc = (this.loc + 1) % this.bucketCount;
  }

  // All items in bucket have same cost, return the first one
  var ret = this.buckets[this.loc];
  this.buckets[this.loc] = ret.next;
  ret.next = null;

  this.size--;
  return ret;
};

// TODO: needs at least two items...
dwv.math.BucketQueue.prototype.remove = function (item) {
  // Tries to remove item from queue. Returns true on success, false otherwise
  if (!item) {
    return false;
  }

  // To find node, go to bucket and search through unsorted list.
  var bucket = this.getBucket(item);
  var node = this.buckets[bucket];

  while (node !== null &&
    !(node.next !== null &&
    item.x === node.next.x &&
    item.y === node.next.y)) {
    node = node.next;
  }

  if (node === null) {
    // Item not in list, ergo item not in queue
    return false;
  } else {
    // Found item, do standard list node deletion
    node.next = node.next.next;

    this.size--;
    return true;
  }
};

dwv.math.BucketQueue.prototype.isEmpty = function () {
  return this.size === 0;
};

dwv.math.BucketQueue.prototype.getBucket = function (item) {
  // Bucket index is the masked cost
  return this.cost(item) & this.mask;
};

dwv.math.BucketQueue.prototype.buildArray = function (newSize) {
  // Create array and initialze pointers to null
  var buckets = new Array(newSize);

  for (var i = 0; i < buckets.length; i++) {
    buckets[i] = null;
  }

  return buckets;
};

// namespaces
var dwv = dwv || {};
dwv.math = dwv.math || {};

/**
 * Mulitply the three inputs if the last two are not null.
 *
 * @param {number} a The first input.
 * @param {number} b The second input.
 * @param {number} c The third input.
 * @returns {number} The multiplication of the three inputs or
 *  null if one of the last two is null.
 */
dwv.math.mulABC = function (a, b, c) {
  var res = null;
  if (b !== null && c !== null) {
    res = a * b * c;
  }
  return res;
};

/**
 * Circle shape.
 *
 * @class
 * @param {dwv.math.Point2D} centre A Point2D representing the centre
 *   of the circle.
 * @param {number} radius The radius of the circle.
 */
dwv.math.Circle = function (centre, radius) {
  /**
   * Get the centre (point) of the circle.
   *
   * @returns {dwv.math.Point2D} The center (point) of the circle.
   */
  this.getCenter = function () {
    return centre;
  };

  /**
   * Get the radius of the circle.
   *
   * @returns {number} The radius of the circle.
   */
  this.getRadius = function () {
    return radius;
  };

}; // Circle class

/**
 * Check for equality.
 *
 * @param {dwv.math.Circle} rhs The object to compare to.
 * @returns {boolean} True if both objects are equal.
 */
dwv.math.Circle.prototype.equals = function (rhs) {
  return rhs !== null &&
    this.getCenter().equals(rhs.getCenter()) &&
    this.getRadius() === rhs.getRadius();
};

/**
 * Get the surface of the circle.
 *
 * @returns {number} The surface of the circle.
 */
dwv.math.Circle.prototype.getSurface = function () {
  return Math.PI * this.getRadius() * this.getRadius();
};

/**
 * Get the surface of the circle according to a spacing.
 *
 * @param {number} spacingX The X spacing.
 * @param {number} spacingY The Y spacing.
 * @returns {number} The surface of the circle multiplied by the given
 *  spacing or null for null spacings.
 */
dwv.math.Circle.prototype.getWorldSurface = function (spacingX, spacingY) {
  return dwv.math.mulABC(this.getSurface(), spacingX, spacingY);
};

/**
 * Get the rounded limits of the circle.
 * (see https://en.wikipedia.org/wiki/Circle#Equations)
 * Circle formula: x*x + y*y = r*r
 * => y = (+-) sqrt(r*r - x*x)
 *
 * @returns {Array} The rounded limits.
 */
dwv.math.Circle.prototype.getRound = function () {
  var centerX = this.getCenter().getX();
  var centerY = this.getCenter().getY();
  var radius = this.getRadius();
  var rSquare = Math.pow(radius, 2);
  // Y bounds
  var minY = centerY - radius;
  var maxY = centerY + radius;
  var regions = [];
  // loop through lines and store limits
  for (var y = minY; y < maxY; ++y) {
    var diff = rSquare - Math.pow(y - centerY, 2);
    // remove small values (possibly negative)
    if (Math.abs(diff) < 1e-7) {
      continue;
    }
    var transX = Math.sqrt(diff);
    // remove small values
    if (transX < 0.5) {
      continue;
    }
    regions.push([
      [Math.round(centerX - transX), Math.round(y)],
      [Math.round(centerX + transX), Math.round(y)]
    ]);
  }
  return regions;
};

/**
 * Quantify an circle according to view information.
 *
 * @param {dwv.ctrl.ViewController} viewController The associated view
 *   controller.
 * @param {Array} flags A list of stat values to calculate.
 * @returns {object} A quantification object.
 */
dwv.math.Circle.prototype.quantify = function (viewController, flags) {
  var quant = {};
  // surface
  var spacing = viewController.get2DSpacing();
  var surface = this.getWorldSurface(spacing[0], spacing[1]);
  if (surface !== null) {
    quant.surface = {value: surface / 100, unit: dwv.i18n('unit.cm2')};
  }

  // pixel quantification
  if (viewController.canQuantifyImage()) {
    var regions = this.getRound();
    if (regions.length !== 0) {
      var values = viewController.getImageVariableRegionValues(regions);
      var quantif = dwv.math.getStats(values, flags);
      quant.min = {value: quantif.getMin(), unit: ''};
      quant.max = {value: quantif.getMax(), unit: ''};
      quant.mean = {value: quantif.getMean(), unit: ''};
      quant.stdDev = {value: quantif.getStdDev(), unit: ''};
      if (typeof quantif.getMedian !== 'undefined') {
        quant.median = {value: quantif.getMedian(), unit: ''};
      }
      if (typeof quantif.getP25 !== 'undefined') {
        quant.p25 = {value: quantif.getP25(), unit: ''};
      }
      if (typeof quantif.getP75 !== 'undefined') {
        quant.p75 = {value: quantif.getP75(), unit: ''};
      }
    }
  }

  // return
  return quant;
};

// namespaces
var dwv = dwv || {};
dwv.math = dwv.math || {};

/**
 * Mulitply the three inputs if the last two are not null.
 *
 * @param {number} a The first input.
 * @param {number} b The second input.
 * @param {number} c The third input.
 * @returns {number} The multiplication of the three inputs or
 *  null if one of the last two is null.
 */
dwv.math.mulABC = function (a, b, c) {
  var res = null;
  if (b !== null && c !== null) {
    res = a * b * c;
  }
  return res;
};

/**
 * Ellipse shape.
 *
 * @class
 * @param {dwv.math.Point2D} centre A Point2D representing the centre
 *   of the ellipse.
 * @param {number} a The radius of the ellipse on the horizontal axe.
 * @param {number} b The radius of the ellipse on the vertical axe.
 */
dwv.math.Ellipse = function (centre, a, b) {
  /**
   * Get the centre (point) of the ellipse.
   *
   * @returns {dwv.math.Point2D} The center (point) of the ellipse.
   */
  this.getCenter = function () {
    return centre;
  };

  /**
   * Get the radius of the ellipse on the horizontal axe.
   *
   * @returns {number} The radius of the ellipse on the horizontal axe.
   */
  this.getA = function () {
    return a;
  };

  /**
   * Get the radius of the ellipse on the vertical axe.
   *
   * @returns {number} The radius of the ellipse on the vertical axe.
   */
  this.getB = function () {
    return b;
  };
}; // Ellipse class

/**
 * Check for equality.
 *
 * @param {dwv.math.Ellipse} rhs The object to compare to.
 * @returns {boolean} True if both objects are equal.
 */
dwv.math.Ellipse.prototype.equals = function (rhs) {
  return rhs !== null &&
    this.getCenter().equals(rhs.getCenter()) &&
    this.getA() === rhs.getA() &&
    this.getB() === rhs.getB();
};

/**
 * Get the surface of the ellipse.
 *
 * @returns {number} The surface of the ellipse.
 */
dwv.math.Ellipse.prototype.getSurface = function () {
  return Math.PI * this.getA() * this.getB();
};

/**
 * Get the surface of the ellipse according to a spacing.
 *
 * @param {number} spacingX The X spacing.
 * @param {number} spacingY The Y spacing.
 * @returns {number} The surface of the ellipse multiplied by the given
 *  spacing or null for null spacings.
 */
dwv.math.Ellipse.prototype.getWorldSurface = function (spacingX, spacingY) {
  return dwv.math.mulABC(this.getSurface(), spacingX, spacingY);
};

/**
 * Get the rounded limits of the ellipse.
 * (see https://en.wikipedia.org/wiki/Ellipse#Standard_equation)
 * Ellipse formula: x*x / a*a + y*y / b*b = 1
 * => y = (+-)(b/a) * sqrt(a*a - x*x)
 *
 * @returns {Array} The rounded limits.
 */
dwv.math.Ellipse.prototype.getRound = function () {
  var centerX = this.getCenter().getX();
  var centerY = this.getCenter().getY();
  var radiusX = this.getA();
  var radiusY = this.getB();
  var radiusRatio = radiusX / radiusY;
  var rySquare = Math.pow(radiusY, 2);
  // Y bounds
  var minY = centerY - radiusY;
  var maxY = centerY + radiusY;
  var regions = [];
  // loop through lines and store limits
  for (var y = minY; y < maxY; ++y) {
    var diff = rySquare - Math.pow(y - centerY, 2);
    // remove small values (possibly negative)
    if (Math.abs(diff) < 1e-7) {
      continue;
    }
    var transX = radiusRatio * Math.sqrt(diff);
    // remove small values
    if (transX < 0.5) {
      continue;
    }
    regions.push([
      [Math.round(centerX - transX), Math.round(y)],
      [Math.round(centerX + transX), Math.round(y)]
    ]);
  }
  return regions;
};

/**
 * Quantify an ellipse according to view information.
 *
 * @param {dwv.ctrl.ViewController} viewController The associated view
 *   controller.
 * @param {Array} flags A list of stat values to calculate.
 * @returns {object} A quantification object.
 */
dwv.math.Ellipse.prototype.quantify = function (viewController, flags) {
  var quant = {};
  // surface
  var spacing = viewController.get2DSpacing();
  var surface = this.getWorldSurface(spacing[0], spacing[1]);
  if (surface !== null) {
    quant.surface = {value: surface / 100, unit: dwv.i18n('unit.cm2')};
  }

  // pixel quantification
  if (viewController.canQuantifyImage()) {
    var regions = this.getRound();
    if (regions.length !== 0) {
      var values = viewController.getImageVariableRegionValues(regions);
      var quantif = dwv.math.getStats(values, flags);
      quant.min = {value: quantif.getMin(), unit: ''};
      quant.max = {value: quantif.getMax(), unit: ''};
      quant.mean = {value: quantif.getMean(), unit: ''};
      quant.stdDev = {value: quantif.getStdDev(), unit: ''};
      if (typeof quantif.getMedian !== 'undefined') {
        quant.median = {value: quantif.getMedian(), unit: ''};
      }
      if (typeof quantif.getP25 !== 'undefined') {
        quant.p25 = {value: quantif.getP25(), unit: ''};
      }
      if (typeof quantif.getP75 !== 'undefined') {
        quant.p75 = {value: quantif.getP75(), unit: ''};
      }
    }
  }

  // return
  return quant;
};

/**
 * Get the indices that form a ellpise.
 *
 * @param {dwv.math.Index} center The ellipse center.
 * @param {Array} radius The 2 ellipse radiuses.
 * @param {Array} dir The 2 ellipse directions.
 * @returns {Array} The indices of the ellipse.
 */
dwv.math.getEllipseIndices = function (center, radius, dir) {
  var centerValues = center.getValues();
  // keep all values for possible extra dimensions
  var values = centerValues.slice();
  var indices = [];
  var radiusI = radius[0];
  var radiusJ = radius[1];
  var radiusRatio = radiusI / radiusJ;
  var radiusJ2 = Math.pow(radiusJ, 2);
  var di = dir[0];
  var dj = dir[1];
  // deduce 4 positions from top right
  for (var j = 0; j < radiusJ; ++j) {
    // right triangle formed by radiuses, j and len
    // ellipse: i*i / a*a + j*j / b*b = 1
    // -> i = a/b * sqrt(b*b - j*j)
    var len = Math.round(
      radiusRatio * Math.sqrt(radiusJ2 - Math.pow(j, 2)));
    var jmax = centerValues[dj] + j;
    var jmin = centerValues[dj] - j;
    for (var i = 0; i < len; ++i) {
      var imax = centerValues[di] + i;
      var imin = centerValues[di] - i;

      // right
      values[di] = imax;
      // right - top
      values[dj] = jmax;
      indices.push(new dwv.math.Index(values.slice()));
      // right - bottom
      if (jmin !== jmax) {
        values[dj] = jmin;
        indices.push(new dwv.math.Index(values.slice()));
      }

      // left
      if (imin !== imax) {
        values[di] = imin;
        // left - top
        values[dj] = jmax;
        indices.push(new dwv.math.Index(values.slice()));
        // left - bottom
        if (jmin !== jmax) {
          values[dj] = jmin;
          indices.push(new dwv.math.Index(values.slice()));
        }
      }
    }
  }
  return indices;
};

// namespaces
var dwv = dwv || {};
dwv.math = dwv.math || {};

/**
 * Immutable index.
 * Warning: the input array is NOT cloned, modifying it will
 *  modify the index values.
 *
 * @class
 * @param {Array} values The index values.
 */
dwv.math.Index = function (values) {
  if (!values || typeof values === 'undefined') {
    throw new Error('Cannot create index with no values.');
  }
  if (values.length === 0) {
    throw new Error('Cannot create index with empty values.');
  }
  var valueCheck = function (val) {
    return !isNaN(val);
  };
  if (!values.every(valueCheck)) {
    throw new Error('Cannot create index with non number values.');
  }

  /**
   * Get the index value at the given array index.
   *
   * @param {number} i The index to get.
   * @returns {number|undefined} The value or undefined if not in range.
   */
  this.get = function (i) {
    return values[i];
  };

  /**
   * Get the length of the index.
   *
   * @returns {number} The length.
   */
  this.length = function () {
    return values.length;
  };

  /**
   * Get a string representation of the Index.
   *
   * @returns {string} The Index as a string.
   */
  this.toString = function () {
    return '(' + values.toString() + ')';
  };

  /**
   * Get the values of this index.
   *
   * @returns {Array} The array of values.
   */
  this.getValues = function () {
    return values.slice();
  };

}; // Index class

/**
 * Check if the input index can be compared to this one.
 *
 * @param {dwv.math.Index} rhs The index to compare to.
 * @returns {boolean} True if both indices are comparable.
 */
dwv.math.Index.prototype.canCompare = function (rhs) {
  // check input
  if (!rhs) {
    return false;
  }
  // check length
  if (this.length() !== rhs.length()) {
    return false;
  }
  // seems ok!
  return true;
};

/**
 * Check for Index equality.
 *
 * @param {dwv.math.Index} rhs The index to compare to.
 * @returns {boolean} True if both indices are equal.
 */
dwv.math.Index.prototype.equals = function (rhs) {
  // check if can compare
  if (!this.canCompare(rhs)) {
    return false;
  }
  // check values
  for (var i = 0, leni = this.length(); i < leni; ++i) {
    if (this.get(i) !== rhs.get(i)) {
      return false;
    }
  }
  // seems ok!
  return true;
};

/**
 * Compare indices and return different dimensions.
 *
 * @param {dwv.math.Index} rhs The index to compare to.
 * @returns {Array} The list of different dimensions.
 */
dwv.math.Index.prototype.compare = function (rhs) {
  // check if can compare
  if (!this.canCompare(rhs)) {
    return null;
  }
  // check values
  var diffDims = [];
  for (var i = 0, leni = this.length(); i < leni; ++i) {
    if (this.get(i) !== rhs.get(i)) {
      diffDims.push(i);
    }
  }
  return diffDims;
};

/**
 * Add another index to this one.
 *
 * @param {dwv.math.Index} rhs The index to add.
 * @returns {dwv.math.Index} The index representing the sum of both indices.
 */
dwv.math.Index.prototype.add = function (rhs) {
  // check if can compare
  if (!this.canCompare(rhs)) {
    return null;
  }
  // add values
  var values = [];
  for (var i = 0, leni = this.length(); i < leni; ++i) {
    values.push(this.get(i) + rhs.get(i));
  }
  // seems ok!
  return new dwv.math.Index(values);
};

/**
 * Get the current index with a new 2D base.
 *
 * @param {number} i The new 0 index.
 * @param {number} j The new 1 index.
 * @returns {dwv.math.Index} The new index.
 */
dwv.math.Index.prototype.getWithNew2D = function (i, j) {
  var values = [i, j];
  for (var l = 2, lenl = this.length(); l < lenl; ++l) {
    values.push(this.get(l));
  }
  return new dwv.math.Index(values);
};

/**
 * Get an index with values set to 0 and the input size.
 *
 * @param {number} size The size of the index.
 * @returns {dwv.math.Index} The zero index.
 */
dwv.math.getZeroIndex = function (size) {
  var values = new Array(size);
  values.fill(0);
  return new dwv.math.Index(values);
};

/**
 * Get an array sort callback.
 * f(a,b) > 0 -> b,a
 * f(a,b) < 0 -> a,b
 * f(a,b) = 0 -> original order
 *
 * @param {number} direction The direction to use to compare indices.
 * @returns {Function} A function that compares two dwv.math.Index.
 */
dwv.math.getIndexCompareFunction = function (direction) {
  return function (a, b) {
    return a.get(direction) - b.get(direction);
  };
};

/**
 * Get a string id from the index values in the form of: '#0-1_#1-2'.
 *
 * @param {Array} dims Optional list of dimensions to use.
 * @returns {string} The string id.
 */
dwv.math.Index.prototype.toStringId = function (dims) {
  if (typeof dims === 'undefined') {
    dims = [];
    for (var j = 0; j < this.length(); ++j) {
      dims.push(j);
    }
  }
  for (var ii = 0; ii < dims.length; ++ii) {
    if (dims[ii] >= this.length()) {
      throw new Error('Non valid dimension for toStringId.');
    }
  }
  var res = '';
  for (var i = 0; i < dims.length; ++i) {
    if (i !== 0) {
      res += '_';
    }
    res += '#' + dims[i] + '-' + this.get(dims[i]);
  }
  return res;
};

/**
 * Get an index from an id string in the form of: '#0-1_#1-2'
 * (result of index.toStringId).
 *
 * @param {string} inputStr The input string.
 * @returns {dwv.math.Index} The corresponding index.
 */
dwv.math.getIndexFromStringId = function (inputStr) {
  // split ids
  var strIds = inputStr.split('_');
  // get the size of the index
  var pointLength = 0;
  var dim;
  for (var i = 0; i < strIds.length; ++i) {
    dim = parseInt(strIds[i].substring(1, 2), 10);
    if (dim > pointLength) {
      pointLength = dim;
    }
  }
  if (pointLength === 0) {
    throw new Error('No dimension found in point stringId');
  }
  // default values
  var values = new Array(pointLength);
  values.fill(0);
  // get other values from the input string
  for (var j = 0; j < strIds.length; ++j) {
    dim = parseInt(strIds[j].substring(1, 3), 10);
    var value = parseInt(strIds[j].substring(3), 10);
    values[dim] = value;
  }
  return new dwv.math.Point(values);
};

// namespaces
var dwv = dwv || {};
dwv.math = dwv.math || {};

/**
 * Line shape.
 *
 * @class
 * @param {dwv.math.Point2D} begin A Point2D representing the beginning
 *   of the line.
 * @param {dwv.math.Point2D} end A Point2D representing the end of the line.
 */
dwv.math.Line = function (begin, end) {
  /**
   * Get the begin point of the line.
   *
   * @returns {dwv.math.Point2D} The beginning point of the line.
   */
  this.getBegin = function () {
    return begin;
  };

  /**
   * Get the end point of the line.
   *
   * @returns {dwv.math.Point2D} The ending point of the line.
   */
  this.getEnd = function () {
    return end;
  };
}; // Line class

/**
 * Check for equality.
 *
 * @param {dwv.math.Line} rhs The object to compare to.
 * @returns {boolean} True if both objects are equal.
 */
dwv.math.Line.prototype.equals = function (rhs) {
  return rhs !== null &&
    this.getBegin().equals(rhs.getBegin()) &&
    this.getEnd().equals(rhs.getEnd());
};

/**
 * Get the line delta in the X direction.
 *
 * @returns {number} The delta in the X direction.
 */
dwv.math.Line.prototype.getDeltaX = function () {
  return this.getEnd().getX() - this.getBegin().getX();
};

/**
 * Get the line delta in the Y direction.
 *
 * @returns {number} The delta in the Y direction.
 */
dwv.math.Line.prototype.getDeltaY = function () {
  return this.getEnd().getY() - this.getBegin().getY();
};

/**
 * Get the length of the line.
 *
 * @returns {number} The length of the line.
 */
dwv.math.Line.prototype.getLength = function () {
  return Math.sqrt(
    this.getDeltaX() * this.getDeltaX() +
    this.getDeltaY() * this.getDeltaY()
  );
};

/**
 * Get the length of the line according to a  spacing.
 *
 * @param {number} spacingX The X spacing.
 * @param {number} spacingY The Y spacing.
 * @returns {number} The length of the line with spacing
 *  or null for null spacings.
 */
dwv.math.Line.prototype.getWorldLength = function (spacingX, spacingY) {
  var wlen = null;
  if (spacingX !== null && spacingY !== null) {
    var dxs = this.getDeltaX() * spacingX;
    var dys = this.getDeltaY() * spacingY;
    wlen = Math.sqrt(dxs * dxs + dys * dys);
  }
  return wlen;
};

/**
 * Get the mid point of the line.
 *
 * @returns {dwv.math.Point2D} The mid point of the line.
 */
dwv.math.Line.prototype.getMidpoint = function () {
  return new dwv.math.Point2D(
    parseInt((this.getBegin().getX() + this.getEnd().getX()) / 2, 10),
    parseInt((this.getBegin().getY() + this.getEnd().getY()) / 2, 10)
  );
};

/**
 * Get the slope of the line.
 *
 * @returns {number} The slope of the line.
 */
dwv.math.Line.prototype.getSlope = function () {
  return this.getDeltaY() / this.getDeltaX();
};

/**
 * Get the intercept of the line.
 *
 * @returns {number} The slope of the line.
 */
dwv.math.Line.prototype.getIntercept = function () {
  return (
    this.getEnd().getX() * this.getBegin().getY() -
    this.getBegin().getX() * this.getEnd().getY()
  ) / this.getDeltaX();
};

/**
 * Get the inclination of the line.
 *
 * @returns {number} The inclination of the line.
 */
dwv.math.Line.prototype.getInclination = function () {
  // tan(theta) = slope
  var angle = Math.atan2(this.getDeltaY(), this.getDeltaX()) * 180 / Math.PI;
  // shift?
  return 180 - angle;
};

/**
 * Get the angle between two lines in degree.
 *
 * @param {dwv.math.Line} line0 The first line.
 * @param {dwv.math.Line} line1 The second line.
 * @returns {number} The angle.
 */
dwv.math.getAngle = function (line0, line1) {
  var dx0 = line0.getDeltaX();
  var dy0 = line0.getDeltaY();
  var dx1 = line1.getDeltaX();
  var dy1 = line1.getDeltaY();
  // dot = ||a||*||b||*cos(theta)
  var dot = dx0 * dx1 + dy0 * dy1;
  // cross = ||a||*||b||*sin(theta)
  var det = dx0 * dy1 - dy0 * dx1;
  // tan = sin / cos
  var angle = Math.atan2(det, dot) * 180 / Math.PI;
  // complementary angle
  // shift?
  return 360 - (180 - angle);
};

/**
 * Get a perpendicular line to an input one.
 *
 * @param {dwv.math.Line} line The line to be perpendicular to.
 * @param {dwv.math.Point2D} point The middle point of the perpendicular line.
 * @param {number} length The length of the perpendicular line.
 * @returns {object} A perpendicular line.
 */
dwv.math.getPerpendicularLine = function (line, point, length) {
  // begin point
  var beginX = 0;
  var beginY = 0;
  // end point
  var endX = 0;
  var endY = 0;

  // check slope:
  // 0 -> horizontal
  // Infinite -> vertical (a/Infinite = 0)
  if (line.getSlope() !== 0) {
    // a0 * a1 = -1
    var slope = -1 / line.getSlope();
    // y0 = a1*x0 + b1 -> b1 = y0 - a1*x0
    var intercept = point.getY() - slope * point.getX();

    // 1. (x - x0)^2 + (y - y0)^2 = d^2
    // 2. a = (y - y0) / (x - x0) -> y = a*(x - x0) + y0
    // ->  (x - x0)^2 + m^2 * (x - x0)^2 = d^2
    // -> x = x0 +- d / sqrt(1+m^2)

    // length is the distance between begin and end,
    // point is half way between both -> d = length / 2
    var dx = length / (2 * Math.sqrt(1 + slope * slope));

    // begin point
    beginX = point.getX() - dx;
    beginY = slope * beginX + intercept;
    // end point
    endX = point.getX() + dx;
    endY = slope * endX + intercept;
  } else {
    // horizontal input line -> perpendicular is vertical!
    // begin point
    beginX = point.getX();
    beginY = point.getY() - length / 2;
    // end point
    endX = point.getX();
    endY = point.getY() + length / 2;
  }
  // perpendicalar line
  return new dwv.math.Line(
    new dwv.math.Point2D(beginX, beginY),
    new dwv.math.Point2D(endX, endY));
};

/**
 * Quantify a line according to view information.
 *
 * @param {object} viewController The associated view controller.
 * @returns {object} A quantification object.
 */
dwv.math.Line.prototype.quantify = function (viewController) {
  var quant = {};
  // length
  var spacing = viewController.get2DSpacing();
  var length = this.getWorldLength(spacing[0], spacing[1]);
  if (length !== null) {
    quant.length = {value: length, unit: dwv.i18n('unit.mm')};
  }
  // return
  return quant;
};

// namespaces
var dwv = dwv || {};
dwv.math = dwv.math || {};

// difference between 1 and the smallest floating point number greater than 1
// -> ~2e-16
if (typeof Number.EPSILON === 'undefined') {
  Number.EPSILON = Math.pow(2, -52);
}
// -> ~2e-12
dwv.math.BIG_EPSILON = Number.EPSILON * 1e4;
// 'real world', for example when comparing positions
dwv.math.REAL_WORLD_EPSILON = 1e-4;

/**
 * Check if two numbers are similar.
 *
 * @param {number} a The first number.
 * @param {number} b The second number.
 * @param {number} tol The comparison tolerance
 *   default to Number.EPSILON.
 * @returns {boolean} True if similar.
 */
dwv.math.isSimilar = function (a, b, tol) {
  if (typeof tol === 'undefined') {
    tol = Number.EPSILON;
  }
  return Math.abs(a - b) < tol;
};

/**
 * Immutable 3x3 Matrix.
 *
 * @param {Array} values row-major ordered 9 values.
 * @class
 */
dwv.math.Matrix33 = function (values) {
  // matrix inverse, calculated at first ask
  var inverse = null;

  /**
   * Get a value of the matrix.
   *
   * @param {number} row The row at wich to get the value.
   * @param {number} col The column at wich to get the value.
   * @returns {number} The value at the position.
   */
  this.get = function (row, col) {
    return values[row * 3 + col];
  };

  /**
   * Get the inverse of this matrix.
   *
   * @returns {dwv.math.Matrix33|undefined} The inverse matrix or undefined
   *   if the determinant is zero.
   */
  this.getInverse = function () {
    if (inverse === null) {
      inverse = dwv.math.getMatrixInverse(this);
    }
    return inverse;
  };

}; // Matrix33

/**
 * Check for Matrix33 equality.
 *
 * @param {dwv.math.Matrix33} rhs The other matrix to compare to.
 * @param {number} p A numeric expression for the precision to use in check
 *   (ex: 0.001). Defaults to Number.EPSILON if not provided.
 * @returns {boolean} True if both matrices are equal.
 */
dwv.math.Matrix33.prototype.equals = function (rhs, p) {
  // TODO: add type check
  // check values
  for (var i = 0; i < 3; ++i) {
    for (var j = 0; j < 3; ++j) {
      if (!dwv.math.isSimilar(this.get(i, j), rhs.get(i, j), p)) {
        return false;
      }
    }
  }
  return true;
};

/**
 * Get a string representation of the Matrix33.
 *
 * @returns {string} The matrix as a string.
 */
dwv.math.Matrix33.prototype.toString = function () {
  var str = '[';
  for (var i = 0; i < 3; ++i) {
    if (i !== 0) {
      str += ', \n ';
    }
    for (var j = 0; j < 3; ++j) {
      if (j !== 0) {
        str += ', ';
      }
      str += this.get(i, j);
    }
  }
  str += ']';
  return str;
};

/**
 * Multiply this matrix by another.
 *
 * @param {dwv.math.Matrix33} rhs The matrix to multiply by.
 * @returns {dwv.math.Matrix33} The product matrix.
 */
dwv.math.Matrix33.prototype.multiply = function (rhs) {
  var values = [];
  for (var i = 0; i < 3; ++i) {
    for (var j = 0; j < 3; ++j) {
      var tmp = 0;
      for (var k = 0; k < 3; ++k) {
        tmp += this.get(i, k) * rhs.get(k, j);
      }
      values.push(tmp);
    }
  }
  return new dwv.math.Matrix33(values);
};

/**
 * Get the absolute value of this matrix.
 *
 * @returns {dwv.math.Matrix33} The result matrix.
 */
dwv.math.Matrix33.prototype.getAbs = function () {
  var values = [];
  for (var i = 0; i < 3; ++i) {
    for (var j = 0; j < 3; ++j) {
      values.push(Math.abs(this.get(i, j)));
    }
  }
  return new dwv.math.Matrix33(values);
};

/**
 * Multiply this matrix by a 3D array.
 *
 * @param {Array} array3D The input 3D array.
 * @returns {Array} The result 3D array.
 */
dwv.math.Matrix33.prototype.multiplyArray3D = function (array3D) {
  if (array3D.length !== 3) {
    throw new Error('Cannot multiply 3x3 matrix with non 3D array: ',
      array3D.length);
  }
  var values = [];
  for (var i = 0; i < 3; ++i) {
    var tmp = 0;
    for (var j = 0; j < 3; ++j) {
      tmp += this.get(i, j) * array3D[j];
    }
    values.push(tmp);
  }
  return values;
};

/**
 * Multiply this matrix by a 3D vector.
 *
 * @param {dwv.math.Vector3D} vector3D The input 3D vector.
 * @returns {dwv.math.Vector3D} The result 3D vector.
 */
dwv.math.Matrix33.prototype.multiplyVector3D = function (vector3D) {
  var array3D = this.multiplyArray3D(
    [vector3D.getX(), vector3D.getY(), vector3D.getZ()]
  );
  return new dwv.math.Vector3D(array3D[0], array3D[1], array3D[2]);
};

/**
 * Multiply this matrix by a 3D point.
 *
 * @param {dwv.math.Point3D} point3D The input 3D point.
 * @returns {dwv.math.Point3D} The result 3D point.
 */
dwv.math.Matrix33.prototype.multiplyPoint3D = function (point3D) {
  var array3D = this.multiplyArray3D(
    [point3D.getX(), point3D.getY(), point3D.getZ()]
  );
  return new dwv.math.Point3D(array3D[0], array3D[1], array3D[2]);
};

/**
 * Multiply this matrix by a 3D index.
 *
 * @param {dwv.math.Index} index3D The input 3D index.
 * @returns {dwv.math.Index} The result 3D index.
 */
dwv.math.Matrix33.prototype.multiplyIndex3D = function (index3D) {
  var array3D = this.multiplyArray3D(index3D.getValues());
  return new dwv.math.Index(array3D);
};

/**
 * Get the inverse of an input 3*3 matrix.
 *
 * @param {dwv.math.Matrix33} m The input matrix.
 * @returns {dwv.math.Matrix33|undefined} The inverse matrix or undefined
 *   if the determinant is zero.
 * @see https://en.wikipedia.org/wiki/Invertible_matrix#Inversion_of_3_%C3%97_3_matrices
 * @see https://github.com/willnode/N-Matrix-Programmer
 */
dwv.math.getMatrixInverse = function (m) {
  var m00 = m.get(0, 0);
  var m01 = m.get(0, 1);
  var m02 = m.get(0, 2);
  var m10 = m.get(1, 0);
  var m11 = m.get(1, 1);
  var m12 = m.get(1, 2);
  var m20 = m.get(2, 0);
  var m21 = m.get(2, 1);
  var m22 = m.get(2, 2);

  var a1212 = m11 * m22 - m12 * m21;
  var a2012 = m12 * m20 - m10 * m22;
  var a0112 = m10 * m21 - m11 * m20;

  var det = m00 * a1212 + m01 * a2012 + m02 * a0112;
  if (det === 0) {
    dwv.logger.warn('Cannot invert 3*3 matrix with zero determinant.');
    return undefined;
  }
  det = 1 / det;

  var values = [
    det * a1212,
    det * (m02 * m21 - m01 * m22),
    det * (m01 * m12 - m02 * m11),
    det * a2012,
    det * (m00 * m22 - m02 * m20),
    det * (m02 * m10 - m00 * m12),
    det * a0112,
    det * (m01 * m20 - m00 * m21),
    det * (m00 * m11 - m01 * m10)
  ];

  return new dwv.math.Matrix33(values);
};

/**
 * Get the index of the maximum in absolute value of a row.
 *
 * @param {number} row The row to get the maximum from.
 * @returns {object} The {value,index} of the maximum.
 */
dwv.math.Matrix33.prototype.getRowAbsMax = function (row) {
  var values = [
    Math.abs(this.get(row, 0)),
    Math.abs(this.get(row, 1)),
    Math.abs(this.get(row, 2))
  ];
  var absMax = Math.max.apply(null, values);
  var index = values.indexOf(absMax);
  return {
    value: this.get(row, index),
    index: index
  };
};

/**
 * Get the index of the maximum in absolute value of a column.
 *
 * @param {number} col The column to get the maximum from.
 * @returns {object} The {value,index} of the maximum.
 */
dwv.math.Matrix33.prototype.getColAbsMax = function (col) {
  var values = [
    Math.abs(this.get(0, col)),
    Math.abs(this.get(1, col)),
    Math.abs(this.get(2, col))
  ];
  var absMax = Math.max.apply(null, values);
  var index = values.indexOf(absMax);
  return {
    value: this.get(index, col),
    index: index
  };
};

/**
 * Get this matrix with only zero and +/- ones instead of the maximum,
 *
 * @returns {dwv.math.Matrix33} The simplified matrix.
 */
dwv.math.Matrix33.prototype.asOneAndZeros = function () {
  var res = [];
  for (var j = 0; j < 3; ++j) {
    var max = this.getRowAbsMax(j);
    var sign = max.value > 0 ? 1 : -1;
    for (var i = 0; i < 3; ++i) {
      if (i === max.index) {
        //res.push(1);
        res.push(1 * sign);
      } else {
        res.push(0);
      }
    }
  }
  return new dwv.math.Matrix33(res);
};

/**
 * Get the third column direction index of an orientation matrix.
 *
 * @returns {number} The index of the absolute maximum of the last column.
 */
dwv.math.Matrix33.prototype.getThirdColMajorDirection = function () {
  return this.getColAbsMax(2).index;
};

/**
 * Create a 3x3 identity matrix.
 *
 * @returns {dwv.math.Matrix33} The identity matrix.
 */
dwv.math.getIdentityMat33 = function () {
  /* eslint-disable array-element-newline */
  return new dwv.math.Matrix33([
    1, 0, 0,
    0, 1, 0,
    0, 0, 1
  ]);
  /* eslint-enable array-element-newline */
};

/**
 * Check if a matrix is a 3x3 identity matrix.
 *
 * @param {dwv.math.Matrix33} mat33 The matrix to test.
 * @returns {boolean} True if identity.
 */
dwv.math.isIdentityMat33 = function (mat33) {
  return mat33.equals(dwv.math.getIdentityMat33());
};

/**
 * Create a 3x3 coronal (xzy) matrix.
 *
 * @returns {dwv.math.Matrix33} The coronal matrix.
 */
dwv.math.getCoronalMat33 = function () {
  /* eslint-disable array-element-newline */
  return new dwv.math.Matrix33([
    1, 0, 0,
    0, 0, 1,
    0, -1, 0
  ]);
  /* eslint-enable array-element-newline */
};

/**
 * Create a 3x3 sagittal (yzx) matrix.
 *
 * @returns {dwv.math.Matrix33} The sagittal matrix.
 */
dwv.math.getSagittalMat33 = function () {
  /* eslint-disable array-element-newline */
  return new dwv.math.Matrix33([
    0, 0, -1,
    1, 0, 0,
    0, -1, 0
  ]);
  /* eslint-enable array-element-newline */
};

/**
 * Get an orientation matrix from a name.
 *
 * @param {string} name The orientation name.
 * @returns {dwv.math.Matrix33} The orientation matrix.
 */
dwv.math.getMatrixFromName = function (name) {
  var matrix = null;
  if (name === 'axial') {
    matrix = dwv.math.getIdentityMat33();
  } else if (name === 'coronal') {
    matrix = dwv.math.getCoronalMat33();
  } else if (name === 'sagittal') {
    matrix = dwv.math.getSagittalMat33();
  }
  return matrix;
};

// namespaces
var dwv = dwv || {};
dwv.math = dwv.math || {};

/**
 * Path shape.
 *
 * @class
 * @param {Array} inputPointArray The list of Point2D that make
 *   the path (optional).
 * @param {Array} inputControlPointIndexArray The list of control point of path,
 *  as indexes (optional).
 * Note: first and last point do not need to be equal.
 */
dwv.math.Path = function (inputPointArray, inputControlPointIndexArray) {
  /**
   * List of points.
   *
   * @type {Array}
   */
  this.pointArray = inputPointArray ? inputPointArray.slice() : [];
  /**
   * List of control points.
   *
   * @type {Array}
   */
  this.controlPointIndexArray = inputControlPointIndexArray
    ? inputControlPointIndexArray.slice() : [];
}; // Path class

/**
 * Get a point of the list.
 *
 * @param {number} index The index of the point to get (beware, no size check).
 * @returns {dwv.math.Point2D} The Point2D at the given index.
 */
dwv.math.Path.prototype.getPoint = function (index) {
  return this.pointArray[index];
};

/**
 * Is the given point a control point.
 *
 * @param {dwv.math.Point2D} point The Point2D to check.
 * @returns {boolean} True if a control point.
 */
dwv.math.Path.prototype.isControlPoint = function (point) {
  var index = this.pointArray.indexOf(point);
  if (index !== -1) {
    return this.controlPointIndexArray.indexOf(index) !== -1;
  } else {
    throw new Error('Error: isControlPoint called with not in list point.');
  }
};

/**
 * Get the length of the path.
 *
 * @returns {number} The length of the path.
 */
dwv.math.Path.prototype.getLength = function () {
  return this.pointArray.length;
};

/**
 * Add a point to the path.
 *
 * @param {dwv.math.Point2D} point The Point2D to add.
 */
dwv.math.Path.prototype.addPoint = function (point) {
  this.pointArray.push(point);
};

/**
 * Add a control point to the path.
 *
 * @param {dwv.math.Point2D} point The Point2D to make a control point.
 */
dwv.math.Path.prototype.addControlPoint = function (point) {
  var index = this.pointArray.indexOf(point);
  if (index !== -1) {
    this.controlPointIndexArray.push(index);
  } else {
    throw new Error(
      'Cannot mark a non registered point as control point.');
  }
};

/**
 * Add points to the path.
 *
 * @param {Array} newPointArray The list of Point2D to add.
 */
dwv.math.Path.prototype.addPoints = function (newPointArray) {
  this.pointArray = this.pointArray.concat(newPointArray);
};

/**
 * Append a Path to this one.
 *
 * @param {dwv.math.Path} other The Path to append.
 */
dwv.math.Path.prototype.appenPath = function (other) {
  var oldSize = this.pointArray.length;
  this.pointArray = this.pointArray.concat(other.pointArray);
  var indexArray = [];
  for (var i = 0; i < other.controlPointIndexArray.length; ++i) {
    indexArray[i] = other.controlPointIndexArray[i] + oldSize;
  }
  this.controlPointIndexArray = this.controlPointIndexArray.concat(indexArray);
};

// namespaces
var dwv = dwv || {};
dwv.math = dwv.math || {};

/**
 * Immutable 2D point.
 *
 * @class
 * @param {number} x The X coordinate for the point.
 * @param {number} y The Y coordinate for the point.
 */
dwv.math.Point2D = function (x, y) {
  /**
   * Get the X position of the point.
   *
   * @returns {number} The X position of the point.
   */
  this.getX = function () {
    return x;
  };
  /**
   * Get the Y position of the point.
   *
   * @returns {number} The Y position of the point.
   */
  this.getY = function () {
    return y;
  };
}; // Point2D class

/**
 * Check for Point2D equality.
 *
 * @param {dwv.math.Point2D} rhs The other point to compare to.
 * @returns {boolean} True if both points are equal.
 */
dwv.math.Point2D.prototype.equals = function (rhs) {
  return rhs !== null &&
    this.getX() === rhs.getX() &&
    this.getY() === rhs.getY();
};

/**
 * Get a string representation of the Point2D.
 *
 * @returns {string} The point as a string.
 */
dwv.math.Point2D.prototype.toString = function () {
  return '(' + this.getX() + ', ' + this.getY() + ')';
};

/**
 * Get the distance to another Point2D.
 *
 * @param {dwv.math.Point2D} point2D The input point.
 * @returns {number} The distance to the input point.
 */
dwv.math.Point2D.prototype.getDistance = function (point2D) {
  return Math.sqrt(
    (this.getX() - point2D.getX()) * (this.getX() - point2D.getX()) +
    (this.getY() - point2D.getY()) * (this.getY() - point2D.getY()));
};

/**
 * Round a Point2D.
 *
 * @returns {dwv.math.Point2D} The rounded point.
 */
dwv.math.Point2D.prototype.getRound = function () {
  return new dwv.math.Point2D(
    Math.round(this.getX()),
    Math.round(this.getY())
  );
};

/**
 * Immutable 3D point.
 *
 * @class
 * @param {number} x The X coordinate for the point.
 * @param {number} y The Y coordinate for the point.
 * @param {number} z The Z coordinate for the point.
 */
dwv.math.Point3D = function (x, y, z) {
  /**
   * Get the X position of the point.
   *
   * @returns {number} The X position of the point.
   */
  this.getX = function () {
    return x;
  };
  /**
   * Get the Y position of the point.
   *
   * @returns {number} The Y position of the point.
   */
  this.getY = function () {
    return y;
  };
  /**
   * Get the Z position of the point.
   *
   * @returns {number} The Z position of the point.
   */
  this.getZ = function () {
    return z;
  };
}; // Point3D class

/**
 * Check for Point3D equality.
 *
 * @param {dwv.math.Point3D} rhs The other point to compare to.
 * @returns {boolean} True if both points are equal.
 */
dwv.math.Point3D.prototype.equals = function (rhs) {
  return rhs !== null &&
    this.getX() === rhs.getX() &&
    this.getY() === rhs.getY() &&
    this.getZ() === rhs.getZ();
};

/**
 * Check for Point3D similarity.
 *
 * @param {dwv.math.Point3D} rhs The other point to compare to.
 * @param {number} tol Optional comparison tolerance,
 *   default to Number.EPSILON.
 * @returns {boolean} True if both points are equal.
 */
dwv.math.Point3D.prototype.isSimilar = function (rhs, tol) {
  return rhs !== null &&
    dwv.math.isSimilar(this.getX(), rhs.getX(), tol) &&
    dwv.math.isSimilar(this.getY(), rhs.getY(), tol) &&
    dwv.math.isSimilar(this.getZ(), rhs.getZ(), tol);
};

/**
 * Get a string representation of the Point3D.
 *
 * @returns {string} The point as a string.
 */
dwv.math.Point3D.prototype.toString = function () {
  return '(' + this.getX() +
    ', ' + this.getY() +
    ', ' + this.getZ() + ')';
};

/**
 * Get the distance to another Point3D.
 *
 * @param {dwv.math.Point3D} point3D The input point.
 * @returns {number} Ths distance to the input point.
 */
dwv.math.Point3D.prototype.getDistance = function (point3D) {
  return Math.sqrt(
    (this.getX() - point3D.getX()) * (this.getX() - point3D.getX()) +
    (this.getY() - point3D.getY()) * (this.getY() - point3D.getY()) +
    (this.getZ() - point3D.getZ()) * (this.getZ() - point3D.getZ()));
};

/**
 * Get the difference to another Point3D.
 *
 * @param {dwv.math.Point3D} point3D The input point.
 * @returns {dwv.math.Point3D} The 3D vector from the input point to this one.
 */
dwv.math.Point3D.prototype.minus = function (point3D) {
  return new dwv.math.Vector3D(
    (this.getX() - point3D.getX()),
    (this.getY() - point3D.getY()),
    (this.getZ() - point3D.getZ()));
};

/**
 * Get an array find callback for an equal input point.
 *
 * @param {dwv.math.Point3D} point The point to compare to.
 * @returns {Function} A function that compares, using `equals`,
 *   its input point to the one given as input to this function.
 */
dwv.math.getEqualPoint3DFunction = function (point) {
  return function (element) {
    return element.equals(point);
  };
};

/**
 * Get an array find callback for a similar input point.
 *
 * @param {dwv.math.Point3D} point The point to compare to.
 * @param {number} tol The comparison tolerance
 *   default to Number.EPSILON.
 * @returns {Function} A function that compares, using `isSimilar`,
 *   its input point to the one given as input to this function.
 */
dwv.math.getSimilarPoint3DFunction = function (point, tol) {
  return function (element) {
    return element.isSimilar(point, tol);
  };
};

/**
 * Immutable point.
 * Warning: the input array is NOT cloned, modifying it will
 *  modify the index values.
 *
 * @class
 * @param {Array} values The point values.
 */
dwv.math.Point = function (values) {
  if (!values || typeof values === 'undefined') {
    throw new Error('Cannot create point with no values.');
  }
  if (values.length === 0) {
    throw new Error('Cannot create point with empty values.');
  }
  var valueCheck = function (val) {
    return !isNaN(val);
  };
  if (!values.every(valueCheck)) {
    throw new Error('Cannot create point with non number values.');
  }

  /**
   * Get the index value at the given array index.
   *
   * @param {number} i The index to get.
   * @returns {number} The value.
   */
  this.get = function (i) {
    return values[i];
  };

  /**
   * Get the length of the index.
   *
   * @returns {number} The length.
   */
  this.length = function () {
    return values.length;
  };

  /**
   * Get a string representation of the Index.
   *
   * @returns {string} The Index as a string.
   */
  this.toString = function () {
    return '(' + values.toString() + ')';
  };

  /**
   * Get the values of this index.
   *
   * @returns {Array} The array of values.
   */
  this.getValues = function () {
    return values.slice();
  };

}; // Point class

/**
 * Check if the input point can be compared to this one.
 *
 * @param {dwv.math.Point} rhs The point to compare to.
 * @returns {boolean} True if both points are comparable.
 */
dwv.math.Point.prototype.canCompare = function (rhs) {
  // check input
  if (!rhs) {
    return false;
  }
  // check length
  if (this.length() !== rhs.length()) {
    return false;
  }
  // seems ok!
  return true;
};

/**
 * Check for Point equality.
 *
 * @param {dwv.math.Point} rhs The point to compare to.
 * @returns {boolean} True if both points are equal.
 */
dwv.math.Point.prototype.equals = function (rhs) {
  // check if can compare
  if (!this.canCompare(rhs)) {
    return false;
  }
  // check values
  for (var i = 0, leni = this.length(); i < leni; ++i) {
    if (this.get(i) !== rhs.get(i)) {
      return false;
    }
  }
  // seems ok!
  return true;
};

/**
 * Compare points and return different dimensions.
 *
 * @param {dwv.math.Point} rhs The point to compare to.
 * @returns {Array} The list of different dimensions.
 */
dwv.math.Point.prototype.compare = function (rhs) {
  // check if can compare
  if (!this.canCompare(rhs)) {
    return null;
  }
  // check values
  var diffDims = [];
  for (var i = 0, leni = this.length(); i < leni; ++i) {
    if (this.get(i) !== rhs.get(i)) {
      diffDims.push(i);
    }
  }
  return diffDims;
};

/**
 * Get the 3D part of this point.
 *
 * @returns {dwv.math.Point3D} The Point3D.
 */
dwv.math.Point.prototype.get3D = function () {
  return new dwv.math.Point3D(this.get(0), this.get(1), this.get(2));
};

/**
 * Add another point to this one.
 *
 * @param {dwv.math.Point} rhs The point to add.
 * @returns {dwv.math.Point} The point representing the sum of both points.
 */
dwv.math.Point.prototype.add = function (rhs) {
  // check if can compare
  if (!this.canCompare(rhs)) {
    return null;
  }
  var values = [];
  var values0 = this.getValues();
  var values1 = rhs.getValues();
  for (var i = 0; i < values0.length; ++i) {
    values.push(values0[i] + values1[i]);
  }
  return new dwv.math.Point(values);
};

/**
 * Merge this point with a Point3D to create a new point.
 *
 * @param {dwv.math.Point3D} rhs The Point3D to merge with.
 * @returns {dwv.math.Point} The merge result.
 */
dwv.math.Point.prototype.mergeWith3D = function (rhs) {
  var values = this.getValues();
  values[0] = rhs.getX();
  values[1] = rhs.getY();
  values[2] = rhs.getZ();
  return new dwv.math.Point(values);
};

// namespaces
var dwv = dwv || {};
dwv.math = dwv.math || {};

/**
 * Mulitply the three inputs if the last two are not null.
 *
 * @param {number} a The first input.
 * @param {number} b The second input.
 * @param {number} c The third input.
 * @returns {number} The multiplication of the three inputs or
 *  null if one of the last two is null.
 */
dwv.math.mulABC = function (a, b, c) {
  var res = null;
  if (b !== null && c !== null) {
    res = a * b * c;
  }
  return res;
};

/**
 * Rectangle shape.
 *
 * @class
 * @param {dwv.math.Point2D} begin A Point2D representing the beginning
 *   of the rectangle.
 * @param {dwv.math.Point2D} end A Point2D representing the end
 *   of the rectangle.
 */
dwv.math.Rectangle = function (begin, end) {
  if (end.getX() < begin.getX()) {
    var tmpX = begin.getX();
    begin = new dwv.math.Point2D(end.getX(), begin.getY());
    end = new dwv.math.Point2D(tmpX, end.getY());
  }
  if (end.getY() < begin.getY()) {
    var tmpY = begin.getY();
    begin = new dwv.math.Point2D(begin.getX(), end.getY());
    end = new dwv.math.Point2D(end.getX(), tmpY);
  }

  /**
   * Get the begin point of the rectangle.
   *
   * @returns {dwv.math.Point2D} The begin point of the rectangle
   */
  this.getBegin = function () {
    return begin;
  };

  /**
   * Get the end point of the rectangle.
   *
   * @returns {dwv.math.Point2D} The end point of the rectangle
   */
  this.getEnd = function () {
    return end;
  };
}; // Rectangle class

/**
 * Check for equality.
 *
 * @param {dwv.math.Rectangle} rhs The object to compare to.
 * @returns {boolean} True if both objects are equal.
 */
dwv.math.Rectangle.prototype.equals = function (rhs) {
  return rhs !== null &&
    this.getBegin().equals(rhs.getBegin()) &&
    this.getEnd().equals(rhs.getEnd());
};

/**
 * Get the surface of the rectangle.
 *
 * @returns {number} The surface of the rectangle.
 */
dwv.math.Rectangle.prototype.getSurface = function () {
  var begin = this.getBegin();
  var end = this.getEnd();
  return Math.abs(end.getX() - begin.getX()) *
    Math.abs(end.getY() - begin.getY());
};

/**
 * Get the surface of the rectangle according to a spacing.
 *
 * @param {number} spacingX The X spacing.
 * @param {number} spacingY The Y spacing.
 * @returns {number} The surface of the rectangle multiplied by the given
 *  spacing or null for null spacings.
 */
dwv.math.Rectangle.prototype.getWorldSurface = function (spacingX, spacingY) {
  return dwv.math.mulABC(this.getSurface(), spacingX, spacingY);
};

/**
 * Get the real width of the rectangle.
 *
 * @returns {number} The real width of the rectangle.
 */
dwv.math.Rectangle.prototype.getRealWidth = function () {
  return this.getEnd().getX() - this.getBegin().getX();
};

/**
 * Get the real height of the rectangle.
 *
 * @returns {number} The real height of the rectangle.
 */
dwv.math.Rectangle.prototype.getRealHeight = function () {
  return this.getEnd().getY() - this.getBegin().getY();
};

/**
 * Get the width of the rectangle.
 *
 * @returns {number} The width of the rectangle.
 */
dwv.math.Rectangle.prototype.getWidth = function () {
  return Math.abs(this.getRealWidth());
};

/**
 * Get the height of the rectangle.
 *
 * @returns {number} The height of the rectangle.
 */
dwv.math.Rectangle.prototype.getHeight = function () {
  return Math.abs(this.getRealHeight());
};

/**
 * Get the rounded limits of the rectangle.
 *
 * @returns {object} The rounded limits.
 */
dwv.math.Rectangle.prototype.getRound = function () {
  return {
    min: this.getBegin().getRound(),
    max: this.getEnd().getRound()
  };
};

/**
 * Quantify a rectangle according to view information.
 *
 * @param {object} viewController The associated view controller.
 * @param {Array} flags A list of stat values to calculate.
 * @returns {object} A quantification object.
 */
dwv.math.Rectangle.prototype.quantify = function (viewController, flags) {
  var quant = {};
  // surface
  var spacing = viewController.get2DSpacing();
  var surface = this.getWorldSurface(spacing[0], spacing[1]);
  if (surface !== null) {
    quant.surface = {value: surface / 100, unit: dwv.i18n('unit.cm2')};
  }

  // pixel quantification
  if (viewController.canQuantifyImage()) {
    var round = this.getRound();
    var values = viewController.getImageRegionValues(round.min, round.max);
    var quantif = dwv.math.getStats(values, flags);
    quant.min = {value: quantif.getMin(), unit: ''};
    quant.max = {value: quantif.getMax(), unit: ''};
    quant.mean = {value: quantif.getMean(), unit: ''};
    quant.stdDev = {value: quantif.getStdDev(), unit: ''};
    if (typeof quantif.getMedian !== 'undefined') {
      quant.median = {value: quantif.getMedian(), unit: ''};
    }
    if (typeof quantif.getP25 !== 'undefined') {
      quant.p25 = {value: quantif.getP25(), unit: ''};
    }
    if (typeof quantif.getP75 !== 'undefined') {
      quant.p75 = {value: quantif.getP75(), unit: ''};
    }
  }

  // return
  return quant;
};

// namespaces
var dwv = dwv || {};
dwv.math = dwv.math || {};

/**
 * Region Of Interest shape.
 * Note: should be a closed path.
 *
 * @class
 */
dwv.math.ROI = function () {
  /**
   * List of points.
   *
   * @private
   * @type {Array}
   */
  var points = [];

  /**
   * Get a point of the list at a given index.
   *
   * @param {number} index The index of the point to get
   *   (beware, no size check).
   * @returns {dwv.math.Point2D} The Point2D at the given index.
   */
  this.getPoint = function (index) {
    return points[index];
  };
  /**
   * Get the length of the point list.
   *
   * @returns {number} The length of the point list.
   */
  this.getLength = function () {
    return points.length;
  };
  /**
   * Add a point to the ROI.
   *
   * @param {dwv.math.Point2D} point The Point2D to add.
   */
  this.addPoint = function (point) {
    points.push(point);
  };
  /**
   * Add points to the ROI.
   *
   * @param {Array} rhs The array of POints2D to add.
   */
  this.addPoints = function (rhs) {
    points = points.concat(rhs);
  };
}; // ROI class

// namespaces
var dwv = dwv || {};
dwv.math = dwv.math || {};

// Pre-created to reduce allocation in inner loops
var __twothirdpi = (2 / (3 * Math.PI));

/**
 * @param {Array} data The input data.
 * @param {number} width The width of the output.
 * @param {number} height The height of the output.
 * @returns {Array} A greyscale object
 */
dwv.math.computeGreyscale = function (data, width, height) {
  // Returns 2D augmented array containing greyscale data
  // Greyscale values found by averaging colour channels
  // Input should be in a flat RGBA array, with values between 0 and 255
  var greyscale = [];

  // Compute actual values
  for (var y = 0; y < height; y++) {
    greyscale[y] = [];

    for (var x = 0; x < width; x++) {
      var p = (y * width + x) * 4;
      greyscale[y][x] = (data[p] + data[p + 1] + data[p + 2]) / (3 * 255);
    }
  }

  // Augment with convenience functions
  greyscale.dx = function (x, y) {
    if (x + 1 === this[y].length) {
      // If we're at the end, back up one
      x--;
    }
    return this[y][x + 1] - this[y][x];
  };

  greyscale.dy = function (x, y) {
    if (y + 1 === this.length) {
      // If we're at the end, back up one
      y--;
    }
    return this[y][x] - this[y + 1][x];
  };

  greyscale.gradMagnitude = function (x, y) {
    var dx = this.dx(x, y);
    var dy = this.dy(x, y);
    return Math.sqrt(dx * dx + dy * dy);
  };

  greyscale.laplace = function (x, y) {
    // Laplacian of Gaussian
    var lap = -16 * this[y][x];
    lap += this[y - 2][x];
    lap += this[y - 1][x - 1] + 2 * this[y - 1][x] + this[y - 1][x + 1];
    lap += this[y][x - 2] +
      2 * this[y][x - 1] + 2 * this[y][x + 1] + this[y][x + 2];
    lap += this[y + 1][x - 1] + 2 * this[y + 1][x] + this[y + 1][x + 1];
    lap += this[y + 2][x];

    return lap;
  };

  return greyscale;
};

/**
 * @param {object} greyscale The input greyscale-
 * @returns {object} A gradient object
 */
dwv.math.computeGradient = function (greyscale) {
  // Returns a 2D array of gradient magnitude values for greyscale. The values
  // are scaled between 0 and 1, and then flipped, so that it works as a cost
  // function.
  var gradient = [];

  var max = 0; // Maximum gradient found, for scaling purposes

  var x = 0;
  var y = 0;

  for (y = 0; y < greyscale.length - 1; y++) {
    gradient[y] = [];

    for (x = 0; x < greyscale[y].length - 1; x++) {
      gradient[y][x] = greyscale.gradMagnitude(x, y);
      max = Math.max(gradient[y][x], max);
    }

    gradient[y][greyscale[y].length - 1] = gradient[y][greyscale.length - 2];
  }

  gradient[greyscale.length - 1] = [];
  for (var i = 0; i < gradient[0].length; i++) {
    gradient[greyscale.length - 1][i] = gradient[greyscale.length - 2][i];
  }

  // Flip and scale.
  for (y = 0; y < gradient.length; y++) {
    for (x = 0; x < gradient[y].length; x++) {
      gradient[y][x] = 1 - (gradient[y][x] / max);
    }
  }

  return gradient;
};

/**
 * @param {object} greyscale The input greyscale.
 * @returns {object} A laplace object.
 */
dwv.math.computeLaplace = function (greyscale) {
  // Returns a 2D array of Laplacian of Gaussian values
  var laplace = [];

  // Make the edges low cost here.

  laplace[0] = [];
  laplace[1] = [];
  for (var i = 1; i < greyscale.length; i++) {
    // Pad top, since we can't compute Laplacian
    laplace[0][i] = 1;
    laplace[1][i] = 1;
  }

  for (var y = 2; y < greyscale.length - 2; y++) {
    laplace[y] = [];
    // Pad left, ditto
    laplace[y][0] = 1;
    laplace[y][1] = 1;

    for (var x = 2; x < greyscale[y].length - 2; x++) {
      // Threshold needed to get rid of clutter.
      laplace[y][x] = (greyscale.laplace(x, y) > 0.33) ? 0 : 1;
    }

    // Pad right, ditto
    laplace[y][greyscale[y].length - 2] = 1;
    laplace[y][greyscale[y].length - 1] = 1;
  }

  laplace[greyscale.length - 2] = [];
  laplace[greyscale.length - 1] = [];
  for (var j = 1; j < greyscale.length; j++) {
    // Pad bottom, ditto
    laplace[greyscale.length - 2][j] = 1;
    laplace[greyscale.length - 1][j] = 1;
  }

  return laplace;
};

dwv.math.computeGradX = function (greyscale) {
  // Returns 2D array of x-gradient values for greyscale
  var gradX = [];

  for (var y = 0; y < greyscale.length; y++) {
    gradX[y] = [];

    for (var x = 0; x < greyscale[y].length - 1; x++) {
      gradX[y][x] = greyscale.dx(x, y);
    }

    gradX[y][greyscale[y].length - 1] = gradX[y][greyscale[y].length - 2];
  }

  return gradX;
};

dwv.math.computeGradY = function (greyscale) {
  // Returns 2D array of y-gradient values for greyscale
  var gradY = [];

  for (var y = 0; y < greyscale.length - 1; y++) {
    gradY[y] = [];

    for (var x = 0; x < greyscale[y].length; x++) {
      gradY[y][x] = greyscale.dy(x, y);
    }
  }

  gradY[greyscale.length - 1] = [];
  for (var i = 0; i < greyscale[0].length; i++) {
    gradY[greyscale.length - 1][i] = gradY[greyscale.length - 2][i];
  }

  return gradY;
};

dwv.math.gradUnitVector = function (gradX, gradY, px, py, out) {
  // Returns the gradient vector at (px,py), scaled to a magnitude of 1
  var ox = gradX[py][px];
  var oy = gradY[py][px];

  var gvm = Math.sqrt(ox * ox + oy * oy);
  gvm = Math.max(gvm, 1e-100); // To avoid possible divide-by-0 errors

  out.x = ox / gvm;
  out.y = oy / gvm;
};

dwv.math.gradDirection = function (gradX, gradY, px, py, qx, qy) {
  var __dgpuv = {x: -1, y: -1};
  var __gdquv = {x: -1, y: -1};
  // Compute the gradiant direction, in radians, between to points
  dwv.math.gradUnitVector(gradX, gradY, px, py, __dgpuv);
  dwv.math.gradUnitVector(gradX, gradY, qx, qy, __gdquv);

  var dp = __dgpuv.y * (qx - px) - __dgpuv.x * (qy - py);
  var dq = __gdquv.y * (qx - px) - __gdquv.x * (qy - py);

  // Make sure dp is positive, to keep things consistant
  if (dp < 0) {
    dp = -dp;
    dq = -dq;
  }

  if (px !== qx && py !== qy) {
    // We're going diagonally between pixels
    dp *= Math.SQRT1_2;
    dq *= Math.SQRT1_2;
  }

  return __twothirdpi * (Math.acos(dp) + Math.acos(dq));
};

dwv.math.computeSides = function (dist, gradX, gradY, greyscale) {
  // Returns 2 2D arrays, containing inside and outside greyscale values.
  // These greyscale values are the intensity just a little bit along the
  // gradient vector, in either direction, from the supplied point. These
  // values are used when using active-learning Intelligent Scissors

  var sides = {};
  sides.inside = [];
  sides.outside = [];

  var guv = {x: -1, y: -1}; // Current gradient unit vector

  for (var y = 0; y < gradX.length; y++) {
    sides.inside[y] = [];
    sides.outside[y] = [];

    for (var x = 0; x < gradX[y].length; x++) {
      dwv.math.gradUnitVector(gradX, gradY, x, y, guv);

      //(x, y) rotated 90 = (y, -x)

      var ix = Math.round(x + dist * guv.y);
      var iy = Math.round(y - dist * guv.x);
      var ox = Math.round(x - dist * guv.y);
      var oy = Math.round(y + dist * guv.x);

      ix = Math.max(Math.min(ix, gradX[y].length - 1), 0);
      ox = Math.max(Math.min(ox, gradX[y].length - 1), 0);
      iy = Math.max(Math.min(iy, gradX.length - 1), 0);
      oy = Math.max(Math.min(oy, gradX.length - 1), 0);

      sides.inside[y][x] = greyscale[iy][ix];
      sides.outside[y][x] = greyscale[oy][ox];
    }
  }

  return sides;
};

dwv.math.gaussianBlur = function (buffer, out) {
  // Smooth values over to fill in gaps in the mapping
  out[0] = 0.4 * buffer[0] + 0.5 * buffer[1] + 0.1 * buffer[1];
  out[1] = 0.25 * buffer[0] + 0.4 * buffer[1] + 0.25 * buffer[2] +
    0.1 * buffer[3];

  for (var i = 2; i < buffer.length - 2; i++) {
    out[i] = 0.05 * buffer[i - 2] + 0.25 * buffer[i - 1] +
      0.4 * buffer[i] + 0.25 * buffer[i + 1] + 0.05 * buffer[i + 2];
  }

  var len = buffer.length;
  out[len - 2] = 0.25 * buffer[len - 1] + 0.4 * buffer[len - 2] +
    0.25 * buffer[len - 3] + 0.1 * buffer[len - 4];
  out[len - 1] = 0.4 * buffer[len - 1] + 0.5 * buffer[len - 2] +
    0.1 * buffer[len - 3];
};


/**
 * Scissors
 *
 * Ref: Eric N. Mortensen, William A. Barrett, Interactive Segmentation with
 *   Intelligent Scissors, Graphical Models and Image Processing, Volume 60,
 *   Issue 5, September 1998, Pages 349-384, ISSN 1077-3169,
 *   DOI: 10.1006/gmip.1998.0480.
 *
 * {@link http://www.sciencedirect.com/science/article/B6WG4-45JB8WN-9/2/6fe59d8089fd1892c2bfb82283065579}
 *
 * Highly inspired from {@link http://code.google.com/p/livewire-javascript/}
 *
 * @class
 */
dwv.math.Scissors = function () {
  this.width = -1;
  this.height = -1;

  this.curPoint = null; // Corrent point we're searching on.
  this.searchGranBits = 8; // Bits of resolution for BucketQueue.
  this.searchGran = 1 << this.earchGranBits; //bits.
  this.pointsPerPost = 500;

  // Precomputed image data. All in ranges 0 >= x >= 1 and all inverted (1 - x).
  this.greyscale = null; // Greyscale of image
  this.laplace = null; // Laplace zero-crossings (either 0 or 1).
  this.gradient = null; // Gradient magnitudes.
  this.gradX = null; // X-differences.
  this.gradY = null; // Y-differences.

  // Matrix mapping point => parent along shortest-path to root.
  this.parents = null;

  this.working = false; // Currently computing shortest paths?

  // Begin Training:
  this.trained = false;
  this.trainingPoints = null;

  this.edgeWidth = 2;
  this.trainingLength = 32;

  this.edgeGran = 256;
  this.edgeTraining = null;

  this.gradPointsNeeded = 32;
  this.gradGran = 1024;
  this.gradTraining = null;

  this.insideGran = 256;
  this.insideTraining = null;

  this.outsideGran = 256;
  this.outsideTraining = null;
  // End Training
}; // Scissors class

// Begin training methods //
dwv.math.Scissors.prototype.getTrainingIdx = function (granularity, value) {
  return Math.round((granularity - 1) * value);
};

dwv.math.Scissors.prototype.getTrainedEdge = function (edge) {
  return this.edgeTraining[this.getTrainingIdx(this.edgeGran, edge)];
};

dwv.math.Scissors.prototype.getTrainedGrad = function (grad) {
  return this.gradTraining[this.getTrainingIdx(this.gradGran, grad)];
};

dwv.math.Scissors.prototype.getTrainedInside = function (inside) {
  return this.insideTraining[this.getTrainingIdx(this.insideGran, inside)];
};

dwv.math.Scissors.prototype.getTrainedOutside = function (outside) {
  return this.outsideTraining[this.getTrainingIdx(this.outsideGran, outside)];
};
// End training methods //

dwv.math.Scissors.prototype.setWorking = function (working) {
  // Sets working flag
  this.working = working;
};

dwv.math.Scissors.prototype.setDimensions = function (width, height) {
  this.width = width;
  this.height = height;
};

dwv.math.Scissors.prototype.setData = function (data) {
  if (this.width === -1 || this.height === -1) {
    // The width and height should have already been set
    throw new Error('Dimensions have not been set.');
  }

  this.greyscale = dwv.math.computeGreyscale(data, this.width, this.height);
  this.laplace = dwv.math.computeLaplace(this.greyscale);
  this.gradient = dwv.math.computeGradient(this.greyscale);
  this.gradX = dwv.math.computeGradX(this.greyscale);
  this.gradY = dwv.math.computeGradY(this.greyscale);

  var sides = dwv.math.computeSides(
    this.edgeWidth, this.gradX, this.gradY, this.greyscale);
  this.inside = sides.inside;
  this.outside = sides.outside;
  this.edgeTraining = [];
  this.gradTraining = [];
  this.insideTraining = [];
  this.outsideTraining = [];
};

dwv.math.Scissors.prototype.findTrainingPoints = function (p) {
  // Grab the last handful of points for training
  var points = [];

  if (this.parents !== null) {
    for (var i = 0; i < this.trainingLength && p; i++) {
      points.push(p);
      p = this.parents[p.y][p.x];
    }
  }

  return points;
};

dwv.math.Scissors.prototype.resetTraining = function () {
  this.trained = false; // Training is ignored with this flag set
};

dwv.math.Scissors.prototype.doTraining = function (p) {
  // Compute training weights and measures
  this.trainingPoints = this.findTrainingPoints(p);

  if (this.trainingPoints.length < 8) {
    return; // Not enough points, I think. It might crash if length = 0.
  }

  var buffer = [];
  this.calculateTraining(
    buffer, this.edgeGran, this.greyscale, this.edgeTraining);
  this.calculateTraining(
    buffer, this.gradGran, this.gradient, this.gradTraining);
  this.calculateTraining(
    buffer, this.insideGran, this.inside, this.insideTraining);
  this.calculateTraining(
    buffer, this.outsideGran, this.outside, this.outsideTraining);

  if (this.trainingPoints.length < this.gradPointsNeeded) {
    // If we have two few training points, the gradient weight map might not
    // be smooth enough, so average with normal weights.
    this.addInStaticGrad(this.trainingPoints.length, this.gradPointsNeeded);
  }

  this.trained = true;
};

dwv.math.Scissors.prototype.calculateTraining = function (
  buffer, granularity, input, output) {
  var i = 0;
  // Build a map of raw-weights to trained-weights by favoring input values
  buffer.length = granularity;
  for (i = 0; i < granularity; i++) {
    buffer[i] = 0;
  }

  var maxVal = 1;
  for (i = 0; i < this.trainingPoints.length; i++) {
    var p = this.trainingPoints[i];
    var idx = this.getTrainingIdx(granularity, input[p.y][p.x]);
    buffer[idx] += 1;

    maxVal = Math.max(maxVal, buffer[idx]);
  }

  // Invert and scale.
  for (i = 0; i < granularity; i++) {
    buffer[i] = 1 - buffer[i] / maxVal;
  }

  // Blur it, as suggested. Gets rid of static.
  dwv.math.gaussianBlur(buffer, output);
};

dwv.math.Scissors.prototype.addInStaticGrad = function (have, need) {
  // Average gradient raw-weights to trained-weights map with standard weight
  // map so that we don't end up with something to spiky
  for (var i = 0; i < this.gradGran; i++) {
    this.gradTraining[i] = Math.min(
      this.gradTraining[i],
      1 - i * (need - have) / (need * this.gradGran)
    );
  }
};

dwv.math.Scissors.prototype.gradDirection = function (px, py, qx, qy) {
  return dwv.math.gradDirection(this.gradX, this.gradY, px, py, qx, qy);
};

dwv.math.Scissors.prototype.dist = function (px, py, qx, qy) {
  // The grand culmunation of most of the code: the weighted distance function
  var grad = this.gradient[qy][qx];

  if (px === qx || py === qy) {
    // The distance is Euclidean-ish; non-diagonal edges should be shorter
    grad *= Math.SQRT1_2;
  }

  var lap = this.laplace[qy][qx];
  var dir = this.gradDirection(px, py, qx, qy);

  if (this.trained) {
    // Apply training magic
    var gradT = this.getTrainedGrad(grad);
    var edgeT = this.getTrainedEdge(this.greyscale[py][px]);
    var insideT = this.getTrainedInside(this.inside[py][px]);
    var outsideT = this.getTrainedOutside(this.outside[py][px]);

    return 0.3 * gradT + 0.3 * lap + 0.1 * (dir + edgeT + insideT + outsideT);
  } else {
    // Normal weights
    return 0.43 * grad + 0.43 * lap + 0.11 * dir;
  }
};

dwv.math.Scissors.prototype.adj = function (p) {
  var list = [];

  var sx = Math.max(p.x - 1, 0);
  var sy = Math.max(p.y - 1, 0);
  var ex = Math.min(p.x + 1, this.greyscale[0].length - 1);
  var ey = Math.min(p.y + 1, this.greyscale.length - 1);

  var idx = 0;
  for (var y = sy; y <= ey; y++) {
    for (var x = sx; x <= ex; x++) {
      if (x !== p.x || y !== p.y) {
        list[idx++] = {x: x, y: y};
      }
    }
  }

  return list;
};

dwv.math.Scissors.prototype.setPoint = function (sp) {
  this.setWorking(true);

  this.curPoint = sp;

  var x = 0;
  var y = 0;

  this.visited = [];
  for (y = 0; y < this.height; y++) {
    this.visited[y] = [];
    for (x = 0; x < this.width; x++) {
      this.visited[y][x] = false;
    }
  }

  this.parents = [];
  for (y = 0; y < this.height; y++) {
    this.parents[y] = [];
  }

  this.cost = [];
  for (y = 0; y < this.height; y++) {
    this.cost[y] = [];
    for (x = 0; x < this.width; x++) {
      this.cost[y][x] = Number.MAX_VALUE;
    }
  }

  this.pq = new dwv.math.BucketQueue(this.searchGranBits, function (p) {
    return Math.round(this.searchGran * this.costArr[p.y][p.x]);
  });
  this.pq.searchGran = this.searchGran;
  this.pq.costArr = this.cost;

  this.pq.push(sp);
  this.cost[sp.y][sp.x] = 0;
};

dwv.math.Scissors.prototype.doWork = function () {
  if (!this.working) {
    return;
  }

  this.timeout = null;

  var pointCount = 0;
  var newPoints = [];
  while (!this.pq.isEmpty() && pointCount < this.pointsPerPost) {
    var p = this.pq.pop();
    newPoints.push(p);
    newPoints.push(this.parents[p.y][p.x]);

    this.visited[p.y][p.x] = true;

    var adjList = this.adj(p);
    for (var i = 0; i < adjList.length; i++) {
      var q = adjList[i];

      var pqCost = this.cost[p.y][p.x] + this.dist(p.x, p.y, q.x, q.y);

      if (pqCost < this.cost[q.y][q.x]) {
        if (this.cost[q.y][q.x] !== Number.MAX_VALUE) {
          // Already in PQ, must remove it so we can re-add it.
          this.pq.remove(q);
        }

        this.cost[q.y][q.x] = pqCost;
        this.parents[q.y][q.x] = p;
        this.pq.push(q);
      }
    }

    pointCount++;
  }

  return newPoints;
};

// namespaces
var dwv = dwv || {};
dwv.math = dwv.math || {};

/**
 * Simple statistics
 *
 * @class
 * @param {number} min The minimum value.
 * @param {number} max The maximum value.
 * @param {number} mean The mean value.
 * @param {number} stdDev The standard deviation.
 */
dwv.math.SimpleStats = function (min, max, mean, stdDev) {
  /**
   * Get the minimum value.
   *
   * @returns {number} The minimum value.
   */
  this.getMin = function () {
    return min;
  };
  /**
   * Get the maximum value.
   *
   * @returns {number} The maximum value.
   */
  this.getMax = function () {
    return max;
  };
  /**
   * Get the mean value.
   *
   * @returns {number} The mean value.
   */
  this.getMean = function () {
    return mean;
  };
  /**
   * Get the standard deviation.
   *
   * @returns {number} The standard deviation.
   */
  this.getStdDev = function () {
    return stdDev;
  };
};

/**
 * Check for Stats equality.
 *
 * @param {object} rhs The other Stats object to compare to.
 * @returns {boolean} True if both Stats object are equal.
 */
dwv.math.SimpleStats.prototype.equals = function (rhs) {
  return rhs !== null &&
    this.getMin() === rhs.getMin() &&
    this.getMax() === rhs.getMax() &&
    this.getMean() === rhs.getMean() &&
    this.getStdDev() === rhs.getStdDev();
};

/**
 * Get the stats as an object
 *
 * @returns {object} An object representation of the stats.
 */
dwv.math.SimpleStats.prototype.asObject = function () {
  return {
    min: this.getMin(),
    max: this.getMax(),
    mean: this.getMean(),
    stdDev: this.getStdDev()
  };
};

dwv.math.FullStats = function (min, max, mean, stdDev, median, p25, p75) {
  dwv.math.SimpleStats.call(this, min, max, mean, stdDev);
  /**
   * Get the median value.
   *
   * @returns {number} The median value.
   */
  this.getMedian = function () {
    return median;
  };
  /**
   * Get the 25th persentile value.
   *
   * @returns {number} The 25th persentile value.
   */
  this.getP25 = function () {
    return p25;
  };
  /**
   * Get the 75th persentile value.
   *
   * @returns {number} The 75th persentile value.
   */
  this.getP75 = function () {
    return p75;
  };
};

// inherit from simple stats
dwv.math.FullStats.prototype = Object.create(dwv.math.SimpleStats.prototype);
Object.defineProperty(dwv.math.FullStats.prototype, 'constructor', {
  value: dwv.math.FullStats,
  enumerable: false, // so that it does not appear in 'for in' loop
  writable: true
});

/**
 * Get the minimum, maximum, mean and standard deviation
 * of an array of values.
 * Note: could use {@link https://github.com/tmcw/simple-statistics}.
 *
 * @param {Array} array The array of values to extract stats from.
 * @param {Array} flags A list of stat values to calculate.
 * @returns {dwv.math.Stats} A stats object.
 */
dwv.math.getStats = function (array, flags) {
  if (dwv.math.includesFullStatsFlags(flags)) {
    return dwv.math.getFullStats(array);
  } else {
    return dwv.math.getSimpleStats(array);
  }
};

/**
 * Does the input flag list contain a full stat element?
 *
 * @param {Array} flags A list of stat values to calculate.
 * @returns {boolean} True if one of the flags is a full start flag.
 */
dwv.math.includesFullStatsFlags = function (flags) {
  return typeof flags !== 'undefined' &&
    flags !== null &&
    flags.includes('median', 'p25', 'p75');
};

/**
 * Get simple stats: minimum, maximum, mean and standard deviation
 * of an array of values.
 *
 * @param {Array} array The array of values to extract stats from.
 * @returns {dwv.math.SimpleStats} A simple stats object.
 */
dwv.math.getSimpleStats = function (array) {
  var min = array[0];
  var max = min;
  var sum = 0;
  var sumSqr = 0;
  var val = 0;
  var length = array.length;
  for (var i = 0; i < length; ++i) {
    val = array[i];
    if (val < min) {
      min = val;
    } else if (val > max) {
      max = val;
    }
    sum += val;
    sumSqr += val * val;
  }

  var mean = sum / length;
  // see http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance
  var variance = sumSqr / length - mean * mean;
  var stdDev = Math.sqrt(variance);

  return new dwv.math.SimpleStats(min, max, mean, stdDev);
};

/**
 * Get full stats: minimum, maximum, mean, standard deviation, median, 25%
 * and 75% percentile of an array of values.
 *
 * @param {Array} array The array of values to extract stats from.
 * @returns {dwv.math.FullStats} A full stats object.
 */
dwv.math.getFullStats = function (array) {
  // get simple stats
  var simpleStats = dwv.math.getSimpleStats(array);

  // sort array... can get slow...
  array.sort(function (a, b) {
    return a - b;
  });

  var median = dwv.math.getPercentile(array, 0.5);
  var p25 = dwv.math.getPercentile(array, 0.25);
  var p75 = dwv.math.getPercentile(array, 0.75);

  return new dwv.math.FullStats(
    simpleStats.getMin(),
    simpleStats.getMax(),
    simpleStats.getMean(),
    simpleStats.getStdDev(),
    median,
    p25,
    p75
  );
};

/**
 * Get an arrays' percentile. Uses linear interpolation for percentiles
 * that lie between data points.
 * see https://en.wikipedia.org/wiki/Percentile (second variant interpolation)
 *
 * @param {Array} array The sorted array of values.
 * @param {number} ratio The percentile ratio [0-1].
 * @returns {number} The percentile,
 */
dwv.math.getPercentile = function (array, ratio) {
  // check input
  if (array.length === 0) {
    throw new Error('Empty array provided for percentile calculation.');
  }
  if (ratio < 0 || ratio > 1) {
    throw new Error(
      'Invalid ratio provided for percentile calculation: ' + ratio);
  }
  // return min for ratio=0 amd max for ratio=1
  if (ratio === 0) {
    return array[0];
  } else if (ratio === 1) {
    return array[array.length - 1];
  }
  // general case: interpolate between indices if needed
  var i = (array.length - 1) * ratio;
  var i0 = Math.floor(i);
  var v0 = array[i0];
  var v1 = array[i0 + 1];
  return v0 + (v1 - v0) * (i - i0);
};

/**
 * Unique ID generator.
 * See {@link http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript}
 * and this {@link http://stackoverflow.com/a/13403498 answer}.
 *
 * @returns {string} A unique ID.
 */
dwv.math.guid = function () {
  return Math.random().toString(36).substring(2, 15);
};

// namespaces
var dwv = dwv || {};
dwv.math = dwv.math || {};

/**
 * Immutable 3D vector.
 *
 * @class
 * @param {number} x The X component of the vector.
 * @param {number} y The Y component of the vector.
 * @param {number} z The Z component of the vector.
 */
dwv.math.Vector3D = function (x, y, z) {
  /**
   * Get the X component of the vector.
   *
   * @returns {number} The X component of the vector.
   */
  this.getX = function () {
    return x;
  };
  /**
   * Get the Y component of the vector.
   *
   * @returns {number} The Y component of the vector.
   */
  this.getY = function () {
    return y;
  };
  /**
   * Get the Z component of the vector.
   *
   * @returns {number} The Z component of the vector.
   */
  this.getZ = function () {
    return z;
  };
}; // Vector3D class

/**
 * Check for Vector3D equality.
 *
 * @param {object} rhs The other vector to compare to.
 * @returns {boolean} True if both vectors are equal.
 */
dwv.math.Vector3D.prototype.equals = function (rhs) {
  return rhs !== null &&
    this.getX() === rhs.getX() &&
    this.getY() === rhs.getY() &&
    this.getZ() === rhs.getZ();
};

/**
 * Get a string representation of the Vector3D.
 *
 * @returns {string} The vector as a string.
 */
dwv.math.Vector3D.prototype.toString = function () {
  return '(' + this.getX() +
    ', ' + this.getY() +
    ', ' + this.getZ() + ')';
};

/**
 * Get the norm of the vector.
 *
 * @returns {number} The norm.
 */
dwv.math.Vector3D.prototype.norm = function () {
  return Math.sqrt(
    (this.getX() * this.getX()) +
    (this.getY() * this.getY()) +
    (this.getZ() * this.getZ())
  );
};

/**
 * Get the cross product with another Vector3D, ie the
 * vector that is perpendicular to both a and b.
 * If both vectors are parallel, the cross product is a zero vector.
 *
 * @see https://en.wikipedia.org/wiki/Cross_product
 * @param {dwv.math.Vector3D} vector3D The input vector.
 * @returns {dwv.math.Vector3D} The result vector.
 */
dwv.math.Vector3D.prototype.crossProduct = function (vector3D) {
  return new dwv.math.Vector3D(
    (this.getY() * vector3D.getZ()) - (vector3D.getY() * this.getZ()),
    (this.getZ() * vector3D.getX()) - (vector3D.getZ() * this.getX()),
    (this.getX() * vector3D.getY()) - (vector3D.getX() * this.getY()));
};

/**
 * Get the dot product with another Vector3D.
 *
 * @see https://en.wikipedia.org/wiki/Dot_product
 * @param {dwv.math.Vector3D} vector3D The input vector.
 * @returns {number} The dot product.
 */
dwv.math.Vector3D.prototype.dotProduct = function (vector3D) {
  return (this.getX() * vector3D.getX()) +
    (this.getY() * vector3D.getY()) +
    (this.getZ() * vector3D.getZ());
};

// namespaces
var dwv = dwv || {};
/** @namespace */
dwv.tool = dwv.tool || {};
/** @namespace */
dwv.tool.draw = dwv.tool.draw || {};
/**
 * The Konva namespace.
 *
 * @external Konva
 * @see https://konvajs.org/
 */
var Konva = Konva || {};

/**
 * Default draw label text.
 */
dwv.tool.draw.defaultArrowLabelText = '';

/**
 * Arrow factory.
 *
 * @class
 */
dwv.tool.draw.ArrowFactory = function () {
  /**
   * Get the name of the shape group.
   *
   * @returns {string} The name.
   */
  this.getGroupName = function () {
    return 'line-group';
  };
  /**
   * Get the number of points needed to build the shape.
   *
   * @returns {number} The number of points.
   */
  this.getNPoints = function () {
    return 2;
  };
  /**
   * Get the timeout between point storage.
   *
   * @returns {number} The timeout in milliseconds.
   */
  this.getTimeout = function () {
    return 0;
  };
};

/**
 * Is the input group a group of this factory?
 *
 * @param {object} group The group to test.
 * @returns {boolean} True if the group is from this fcatory.
 */
dwv.tool.draw.ArrowFactory.prototype.isFactoryGroup = function (group) {
  return this.getGroupName() === group.name();
};

/**
 * Create an arrow shape to be displayed.
 *
 * @param {Array} points The points from which to extract the line.
 * @param {object} style The drawing style.
 * @param {object} _viewController The associated view controller.
 * @returns {object} The Konva object.
 */
dwv.tool.draw.ArrowFactory.prototype.create = function (
  points, style, _viewController) {
  // physical shape
  var line = new dwv.math.Line(points[0], points[1]);
  // draw shape
  var kshape = new Konva.Line({
    points: [line.getBegin().getX(),
      line.getBegin().getY(),
      line.getEnd().getX(),
      line.getEnd().getY()],
    stroke: style.getLineColour(),
    strokeWidth: style.getStrokeWidth(),
    strokeScaleEnabled: false,
    name: 'shape'
  });
  // larger hitfunc
  var linePerp0 = dwv.math.getPerpendicularLine(
    line, points[0], style.scale(10));
  var linePerp1 = dwv.math.getPerpendicularLine(
    line, points[1], style.scale(10));
  kshape.hitFunc(function (context) {
    context.beginPath();
    context.moveTo(linePerp0.getBegin().getX(), linePerp0.getBegin().getY());
    context.lineTo(linePerp0.getEnd().getX(), linePerp0.getEnd().getY());
    context.lineTo(linePerp1.getEnd().getX(), linePerp1.getEnd().getY());
    context.lineTo(linePerp1.getBegin().getX(), linePerp1.getBegin().getY());
    context.closePath();
    context.fillStrokeShape(this);
  });
  // triangle
  var beginTy = new dwv.math.Point2D(
    line.getBegin().getX(),
    line.getBegin().getY() - 10);
  var verticalLine = new dwv.math.Line(line.getBegin(), beginTy);
  var angle = dwv.math.getAngle(line, verticalLine);
  var angleRad = angle * Math.PI / 180;
  var radius = 5 * style.getScaledStrokeWidth();
  var kpoly = new Konva.RegularPolygon({
    x: line.getBegin().getX() + radius * Math.sin(angleRad),
    y: line.getBegin().getY() + radius * Math.cos(angleRad),
    sides: 3,
    radius: radius,
    rotation: -angle,
    fill: style.getLineColour(),
    strokeWidth: style.getStrokeWidth(),
    strokeScaleEnabled: false,
    name: 'shape-triangle'
  });
  // quantification
  var ktext = new Konva.Text({
    fontSize: style.getFontSize(),
    fontFamily: style.getFontFamily(),
    fill: style.getLineColour(),
    padding: style.getTextPadding(),
    shadowColor: style.getShadowLineColour(),
    shadowOffset: style.getShadowOffset(),
    name: 'text'
  });
  var textExpr = '';
  if (typeof dwv.tool.draw.arrowLabelText !== 'undefined') {
    textExpr = dwv.tool.draw.arrowLabelText;
  } else {
    textExpr = dwv.tool.draw.defaultArrowLabelText;
  }
  ktext.setText(textExpr);
  // meta data
  ktext.meta = {
    textExpr: textExpr,
    quantification: {}
  };
  // label
  var dX = line.getBegin().getX() > line.getEnd().getX() ? 0 : -1;
  var dY = line.getBegin().getY() > line.getEnd().getY() ? -1 : 0;
  var klabel = new Konva.Label({
    x: line.getEnd().getX() + dX * ktext.width(),
    y: line.getEnd().getY() + dY * style.applyZoomScale(15).y,
    scale: style.applyZoomScale(1),
    visible: textExpr.length !== 0,
    name: 'label'
  });
  klabel.add(ktext);
  klabel.add(new Konva.Tag({
    fill: style.getLineColour(),
    opacity: style.getTagOpacity()
  }));

  // return group
  var group = new Konva.Group();
  group.name(this.getGroupName());
  group.add(klabel);
  group.add(kpoly);
  group.add(kshape);
  group.visible(true); // dont inherit
  return group;
};

/**
 * Get anchors to update an arrow shape.
 *
 * @param {object} shape The associated shape.
 * @param {object} style The application style.
 * @returns {Array} A list of anchors.
 */
dwv.tool.draw.ArrowFactory.prototype.getAnchors = function (shape, style) {
  var points = shape.points();

  var anchors = [];
  anchors.push(dwv.tool.draw.getDefaultAnchor(
    points[0] + shape.x(), points[1] + shape.y(), 'begin', style
  ));
  anchors.push(dwv.tool.draw.getDefaultAnchor(
    points[2] + shape.x(), points[3] + shape.y(), 'end', style
  ));
  return anchors;
};

/**
 * Update an arrow shape.
 * Warning: do NOT use 'this' here, this method is passed
 *   as is to the change command.
 *
 * @param {object} anchor The active anchor.
 * @param {object} style The app style.
 * @param {object} _viewController The associated view controller.
 */
dwv.tool.draw.ArrowFactory.prototype.update = function (
  anchor, style, _viewController) {
  // parent group
  var group = anchor.getParent();
  // associated shape
  var kline = group.getChildren(function (node) {
    return node.name() === 'shape';
  })[0];
    // associated triangle shape
  var ktriangle = group.getChildren(function (node) {
    return node.name() === 'shape-triangle';
  })[0];
    // associated label
  var klabel = group.getChildren(function (node) {
    return node.name() === 'label';
  })[0];
    // find special points
  var begin = group.getChildren(function (node) {
    return node.id() === 'begin';
  })[0];
  var end = group.getChildren(function (node) {
    return node.id() === 'end';
  })[0];
    // update special points
  switch (anchor.id()) {
  case 'begin':
    begin.x(anchor.x());
    begin.y(anchor.y());
    break;
  case 'end':
    end.x(anchor.x());
    end.y(anchor.y());
    break;
  }
  // update shape and compensate for possible drag
  // note: shape.position() and shape.size() won't work...
  var bx = begin.x() - kline.x();
  var by = begin.y() - kline.y();
  var ex = end.x() - kline.x();
  var ey = end.y() - kline.y();
  kline.points([bx, by, ex, ey]);
  // new line
  var p2d0 = new dwv.math.Point2D(begin.x(), begin.y());
  var p2d1 = new dwv.math.Point2D(end.x(), end.y());
  var line = new dwv.math.Line(p2d0, p2d1);
  // larger hitfunc
  var p2b = new dwv.math.Point2D(bx, by);
  var p2e = new dwv.math.Point2D(ex, ey);
  var linePerp0 = dwv.math.getPerpendicularLine(line, p2b, 10);
  var linePerp1 = dwv.math.getPerpendicularLine(line, p2e, 10);
  kline.hitFunc(function (context) {
    context.beginPath();
    context.moveTo(linePerp0.getBegin().getX(), linePerp0.getBegin().getY());
    context.lineTo(linePerp0.getEnd().getX(), linePerp0.getEnd().getY());
    context.lineTo(linePerp1.getEnd().getX(), linePerp1.getEnd().getY());
    context.lineTo(linePerp1.getBegin().getX(), linePerp1.getBegin().getY());
    context.closePath();
    context.fillStrokeShape(this);
  });
  // udate triangle
  var beginTy = new dwv.math.Point2D(
    line.getBegin().getX(),
    line.getBegin().getY() - 10);
  var verticalLine = new dwv.math.Line(line.getBegin(), beginTy);
  var angle = dwv.math.getAngle(line, verticalLine);
  var angleRad = angle * Math.PI / 180;
  ktriangle.x(line.getBegin().getX() + ktriangle.radius() * Math.sin(angleRad));
  ktriangle.y(line.getBegin().getY() + ktriangle.radius() * Math.cos(angleRad));
  ktriangle.rotation(-angle);

  // update text
  var ktext = klabel.getText();
  ktext.setText(ktext.meta.textExpr);
  // update position
  var dX = line.getBegin().getX() > line.getEnd().getX() ? 0 : -1;
  var dY = line.getBegin().getY() > line.getEnd().getY() ? -1 : 0;
  var textPos = {
    x: line.getEnd().getX() + dX * ktext.width(),
    y: line.getEnd().getY() + dY * style.applyZoomScale(15).y
  };
  klabel.position(textPos);
};

// namespaces
var dwv = dwv || {};
dwv.tool = dwv.tool || {};
dwv.tool.draw = dwv.tool.draw || {};
/**
 * The Konva namespace.
 *
 * @external Konva
 * @see https://konvajs.org/
 */
var Konva = Konva || {};

/**
 * Default draw label text.
 */
dwv.tool.draw.defaultCircleLabelText = '{surface}';

/**
 * Circle factory.
 *
 * @class
 */
dwv.tool.draw.CircleFactory = function () {
  /**
   * Get the name of the shape group.
   *
   * @returns {string} The name.
   */
  this.getGroupName = function () {
    return 'circle-group';
  };
  /**
   * Get the number of points needed to build the shape.
   *
   * @returns {number} The number of points.
   */
  this.getNPoints = function () {
    return 2;
  };
  /**
   * Get the timeout between point storage.
   *
   * @returns {number} The timeout in milliseconds.
   */
  this.getTimeout = function () {
    return 0;
  };
};

/**
 * Is the input group a group of this factory?
 *
 * @param {object} group The group to test.
 * @returns {boolean} True if the group is from this fcatory.
 */
dwv.tool.draw.CircleFactory.prototype.isFactoryGroup = function (group) {
  return this.getGroupName() === group.name();
};

/**
 * Create a circle shape to be displayed.
 *
 * @param {Array} points The points from which to extract the circle.
 * @param {object} style The drawing style.
 * @param {object} viewController The associated view controller.
 * @returns {object} The Konva group.
 */
dwv.tool.draw.CircleFactory.prototype.create = function (
  points, style, viewController) {
  // calculate radius
  var a = Math.abs(points[0].getX() - points[1].getX());
  var b = Math.abs(points[0].getY() - points[1].getY());
  var radius = Math.round(Math.sqrt(a * a + b * b));
  // physical shape
  var circle = new dwv.math.Circle(points[0], radius);
  // draw shape
  var kshape = new Konva.Circle({
    x: circle.getCenter().getX(),
    y: circle.getCenter().getY(),
    radius: circle.getRadius(),
    stroke: style.getLineColour(),
    strokeWidth: style.getStrokeWidth(),
    strokeScaleEnabled: false,
    name: 'shape'
  });
  // quantification
  var ktext = new Konva.Text({
    fontSize: style.getFontSize(),
    fontFamily: style.getFontFamily(),
    fill: style.getLineColour(),
    padding: style.getTextPadding(),
    shadowColor: style.getShadowLineColour(),
    shadowOffset: style.getShadowOffset(),
    name: 'text'
  });
  var textExpr = '';
  if (typeof dwv.tool.draw.circleLabelText !== 'undefined') {
    textExpr = dwv.tool.draw.circleLabelText;
  } else {
    textExpr = dwv.tool.draw.defaultCircleLabelText;
  }
  var quant = circle.quantify(
    viewController,
    dwv.utils.getFlags(textExpr));
  ktext.setText(dwv.utils.replaceFlags(textExpr, quant));
  // meta data
  ktext.meta = {
    textExpr: textExpr,
    quantification: quant
  };
  // label
  var klabel = new Konva.Label({
    x: circle.getCenter().getX(),
    y: circle.getCenter().getY(),
    scale: style.applyZoomScale(1),
    visible: textExpr.length !== 0,
    name: 'label'
  });
  klabel.add(ktext);
  klabel.add(new Konva.Tag({
    fill: style.getLineColour(),
    opacity: style.getTagOpacity()
  }));

  // debug shadow
  var kshadow;
  if (dwv.tool.draw.debug) {
    kshadow = dwv.tool.draw.getShadowCircle(circle);
  }

  // return group
  var group = new Konva.Group();
  group.name(this.getGroupName());
  if (kshadow) {
    group.add(kshadow);
  }
  group.add(klabel);
  group.add(kshape);
  group.visible(true); // dont inherit
  return group;
};

/**
 * Get anchors to update a circle shape.
 *
 * @param {object} shape The associated shape.
 * @param {object} style The application style.
 * @returns {Array} A list of anchors.
 */
dwv.tool.draw.CircleFactory.prototype.getAnchors = function (shape, style) {
  var centerX = shape.x();
  var centerY = shape.y();
  var radius = shape.radius();

  var anchors = [];
  anchors.push(dwv.tool.draw.getDefaultAnchor(
    centerX - radius, centerY, 'left', style
  ));
  anchors.push(dwv.tool.draw.getDefaultAnchor(
    centerX + radius, centerY, 'right', style
  ));
  anchors.push(dwv.tool.draw.getDefaultAnchor(
    centerX, centerY - radius, 'bottom', style
  ));
  anchors.push(dwv.tool.draw.getDefaultAnchor(
    centerX, centerY + radius, 'top', style
  ));
  return anchors;
};

/**
 * Update a circle shape.
 * Warning: do NOT use 'this' here, this method is passed
 *   as is to the change command.
 *
 * @param {object} anchor The active anchor.
 * @param {object} _style The app style.
 * @param {object} viewController The associated view controller.
 */
dwv.tool.draw.CircleFactory.prototype.update = function (
  anchor, _style, viewController) {
  // parent group
  var group = anchor.getParent();
  // associated shape
  var kcircle = group.getChildren(function (node) {
    return node.name() === 'shape';
  })[0];
  // associated label
  var klabel = group.getChildren(function (node) {
    return node.name() === 'label';
  })[0];
  // find special points
  var left = group.getChildren(function (node) {
    return node.id() === 'left';
  })[0];
  var right = group.getChildren(function (node) {
    return node.id() === 'right';
  })[0];
  var bottom = group.getChildren(function (node) {
    return node.id() === 'bottom';
  })[0];
  var top = group.getChildren(function (node) {
    return node.id() === 'top';
  })[0];
  // debug shadow
  var kshadow;
  if (dwv.tool.draw.debug) {
    kshadow = group.getChildren(function (node) {
      return node.name() === 'shadow';
    })[0];
  }

  // circle center
  var center = {
    x: kcircle.x(),
    y: kcircle.y()
  };

  var radius;

  // update 'self' (undo case) and special points
  switch (anchor.id()) {
  case 'left':
    radius = center.x - anchor.x();
    // force y
    left.y(right.y());
    // update others
    right.x(center.x + radius);
    bottom.y(center.y - radius);
    top.y(center.y + radius);
    break;
  case 'right':
    radius = anchor.x() - center.x;
    // force y
    right.y(left.y());
    // update others
    left.x(center.x - radius);
    bottom.y(center.y - radius);
    top.y(center.y + radius);
    break;
  case 'bottom':
    radius = center.y - anchor.y();
    // force x
    bottom.x(top.x());
    // update others
    left.x(center.x - radius);
    right.x(center.x + radius);
    top.y(center.y + radius);
    break;
  case 'top':
    radius = anchor.y() - center.y;
    // force x
    top.x(bottom.x());
    // update others
    left.x(center.x - radius);
    right.x(center.x + radius);
    bottom.y(center.y - radius);
    break;
  default :
    dwv.logger.error('Unhandled anchor id: ' + anchor.id());
    break;
  }

  // update shape: just update the radius
  kcircle.radius(Math.abs(radius));
  // new circle
  var centerPoint = new dwv.math.Point2D(
    group.x() + center.x,
    group.y() + center.y
  );
  var circle = new dwv.math.Circle(centerPoint, radius);

  // debug shadow
  if (kshadow) {
    // remove previous
    kshadow.destroy();
    // add new
    group.add(dwv.tool.draw.getShadowCircle(circle, group));
  }

  // update label position
  var textPos = {x: center.x, y: center.y};
  klabel.position(textPos);

  // update quantification
  dwv.tool.draw.updateCircleQuantification(group, viewController);
};

/**
 * Update the quantification of a Circle.
 *
 * @param {object} group The group with the shape.
 * @param {object} viewController The associated view controller.
 */
dwv.tool.draw.CircleFactory.prototype.updateQuantification = function (
  group, viewController) {
  dwv.tool.draw.updateCircleQuantification(group, viewController);
};

/**
 * Update the quantification of a Circle (as a static
 *   function to be used in update).
 *
 * @param {object} group The group with the shape.
 * @param {object} viewController The associated view controller.
 */
dwv.tool.draw.updateCircleQuantification = function (
  group, viewController) {
  // associated shape
  var kcircle = group.getChildren(function (node) {
    return node.name() === 'shape';
  })[0];
  // associated label
  var klabel = group.getChildren(function (node) {
    return node.name() === 'label';
  })[0];

  // positions: add possible group offset
  var centerPoint = new dwv.math.Point2D(
    group.x() + kcircle.x(),
    group.y() + kcircle.y()
  );
  // circle
  var circle = new dwv.math.Circle(centerPoint, kcircle.radius());

  // update text
  var ktext = klabel.getText();
  var quantification = circle.quantify(
    viewController,
    dwv.utils.getFlags(ktext.meta.textExpr));
  ktext.setText(dwv.utils.replaceFlags(ktext.meta.textExpr, quantification));
  // update meta
  ktext.meta.quantification = quantification;
};

/**
 * Get the debug shadow.
 *
 * @param {dwv.math.Circle} circle The circle to shadow.
 * @param {object} group The associated group.
 * @returns {object} The shadow konva group.
 */
dwv.tool.draw.getShadowCircle = function (circle, group) {
  // possible group offset
  var offsetX = 0;
  var offsetY = 0;
  if (typeof group !== 'undefined') {
    offsetX = group.x();
    offsetY = group.y();
  }
  var kshadow = new Konva.Group();
  kshadow.name('shadow');
  var regions = circle.getRound();
  for (var i = 0; i < regions.length; ++i) {
    var region = regions[i];
    var minX = region[0][0];
    var minY = region[0][1];
    var maxX = region[1][0];
    var pixelLine = new Konva.Rect({
      x: minX - offsetX,
      y: minY - offsetY,
      width: maxX - minX,
      height: 1,
      fill: 'grey',
      strokeWidth: 0,
      strokeScaleEnabled: false,
      opacity: 0.3,
      name: 'shadow-element'
    });
    kshadow.add(pixelLine);
  }
  return kshadow;
};

// namespaces
var dwv = dwv || {};
dwv.tool = dwv.tool || {};
dwv.tool.draw = dwv.tool.draw || {};
/**
 * The Konva namespace.
 *
 * @external Konva
 * @see https://konvajs.org/
 */
var Konva = Konva || {};

/**
 * Debug flag.
 */
dwv.tool.draw.debug = false;

/**
 * Drawing tool.
 *
 * This tool is responsible for the draw layer group structure. The layout is:
 *
 * drawLayer
 * |_ positionGroup: name="position-group", id="#2-0#_#3-1""
 *    |_ shapeGroup: name="{shape name}-group", id="#"
 *       |_ shape: name="shape"
 *       |_ label: name="label"
 *       |_ extra: line tick, protractor arc...
 *
 * Discussion:
 * - posGroup > shapeGroup
 *    pro: slice/frame display: 1 loop
 *    cons: multi-slice shape splitted in positionGroups
 * - shapeGroup > posGroup
 *    pros: more logical
 *    cons: slice/frame display: 2 loops
 *
 * @class
 * @param {dwv.App} app The associated application.
 */
dwv.tool.Draw = function (app) {
  /**
   * Closure to self: to be used by event handlers.
   *
   * @private
   * @type {dwv.tool.Draw }
   */
  var self = this;
  /**
   * Interaction start flag.
   *
   * @private
   * @type {boolean}
   */
  var started = false;

  /**
   * Shape factory list
   *
   * @type {object}
   */
  this.shapeFactoryList = null;

  /**
   * Current shape factory.
   *
   * @type {object}
   * @private
   */
  var currentFactory = null;

  /**
   * Draw command.
   *
   * @private
   * @type {object}
   */
  var command = null;
  /**
   * Current shape group.
   *
   * @private
   * @type {object}
   */
  var tmpShapeGroup = null;

  /**
   * Shape name.
   *
   * @type {string}
   */
  this.shapeName = 0;

  /**
   * List of points.
   *
   * @private
   * @type {Array}
   */
  var points = [];

  /**
   * Last selected point.
   *
   * @private
   * @type {object}
   */
  var lastPoint = null;

  /**
   * Active shape, ie shape with mouse over.
   *
   * @private
   * @type {object}
   */
  var activeShapeGroup;

  /**
   * Original mouse cursor.
   *
   * @private
   * @type {string}
   */
  var originalCursor;

  /**
   * Mouse cursor.
   *
   * @private
   * @type {string}
   */
  var mouseOverCursor = 'pointer';

  /**
   * Scroll wheel handler.
   *
   * @type {dwv.tool.ScrollWheel}
   */
  var scrollWhell = new dwv.tool.ScrollWheel(app);

  /**
   * Shape editor.
   *
   * @private
   * @type {object}
   */
  var shapeEditor = new dwv.tool.ShapeEditor(app);

  // associate the event listeners of the editor
  //  with those of the draw tool
  shapeEditor.setDrawEventCallback(fireEvent);

  /**
   * Trash draw: a cross.
   *
   * @private
   * @type {object}
   */
  var trash = new Konva.Group();

  // first line of the cross
  var trashLine1 = new Konva.Line({
    points: [-10, -10, 10, 10],
    stroke: 'red'
  });
    // second line of the cross
  var trashLine2 = new Konva.Line({
    points: [10, -10, -10, 10],
    stroke: 'red'
  });
  trash.width(20);
  trash.height(20);
  trash.add(trashLine1);
  trash.add(trashLine2);

  /**
   * Drawing style.
   *
   * @type {dwv.gui.Style}
   */
  this.style = app.getStyle();

  /**
   * Event listeners.
   *
   * @private
   */
  var listeners = {};

  /**
   * Handle mouse down event.
   *
   * @param {object} event The mouse down event.
   */
  this.mousedown = function (event) {
    // exit if a draw was started (handle at mouse move or up)
    if (started) {
      return;
    }

    var layerDetails = dwv.gui.getLayerDetailsFromEvent(event);
    var layerGroup = app.getLayerGroupByDivId(layerDetails.groupDivId);
    var drawLayer = layerGroup.getActiveDrawLayer();

    // determine if the click happened in an existing shape
    var stage = drawLayer.getKonvaStage();
    var kshape = stage.getIntersection({
      x: event._x,
      y: event._y
    });

    // update scale
    self.style.setZoomScale(stage.scale());

    if (kshape) {
      var group = kshape.getParent();
      var selectedShape = group.find('.shape')[0];
      // reset editor if click on other shape
      // (and avoid anchors mouse down)
      if (selectedShape && selectedShape !== shapeEditor.getShape()) {
        shapeEditor.disable();
        shapeEditor.setShape(selectedShape);
        var viewController =
          layerGroup.getActiveViewLayer().getViewController();
        shapeEditor.setViewController(viewController);
        shapeEditor.enable();
      }
    } else {
      // disable edition
      shapeEditor.disable();
      shapeEditor.setShape(null);
      shapeEditor.setViewController(null);
      // start storing points
      started = true;
      // set factory
      currentFactory = new self.shapeFactoryList[self.shapeName]();
      // clear array
      points = [];
      // store point
      var viewLayer = layerGroup.getActiveViewLayer();
      var pos = viewLayer.displayToPlanePos(event._x, event._y);
      lastPoint = new dwv.math.Point2D(pos.x, pos.y);
      points.push(lastPoint);
    }
  };

  /**
   * Handle mouse move event.
   *
   * @param {object} event The mouse move event.
   */
  this.mousemove = function (event) {
    // exit if not started draw
    if (!started) {
      return;
    }

    var layerDetails = dwv.gui.getLayerDetailsFromEvent(event);
    var layerGroup = app.getLayerGroupByDivId(layerDetails.groupDivId);
    var viewLayer = layerGroup.getActiveViewLayer();
    var pos = viewLayer.displayToPlanePos(event._x, event._y);

    // draw line to current pos
    if (Math.abs(pos.x - lastPoint.getX()) > 0 ||
      Math.abs(pos.y - lastPoint.getY()) > 0) {
      // clear last added point from the list (but not the first one)
      // if it was marked as temporary
      if (points.length !== 1 &&
        typeof points[points.length - 1].tmp !== 'undefined') {
        points.pop();
      }
      // current point
      lastPoint = new dwv.math.Point2D(pos.x, pos.y);
      // mark it as temporary
      lastPoint.tmp = true;
      // add it to the list
      points.push(lastPoint);
      // update points
      onNewPoints(points, layerGroup);
    }
  };

  /**
   * Handle mouse up event.
   *
   * @param {object} event The mouse up event.
   */
  this.mouseup = function (event) {
    // exit if not started draw
    if (!started) {
      return;
    }
    // exit if no points
    if (points.length === 0) {
      dwv.logger.warn('Draw mouseup but no points...');
      return;
    }

    // do we have all the needed points
    if (points.length === currentFactory.getNPoints()) {
      // store points
      var layerDetails = dwv.gui.getLayerDetailsFromEvent(event);
      var layerGroup = app.getLayerGroupByDivId(layerDetails.groupDivId);
      onFinalPoints(points, layerGroup);
      // reset flag
      started = false;
    } else {
      // remove temporary flag
      if (typeof points[points.length - 1].tmp !== 'undefined') {
        delete points[points.length - 1].tmp;
      }
    }
  };

  /**
   * Handle double click event: some tools use it to finish interaction.
   *
   * @param {object} event The double click event.
   */
  this.dblclick = function (event) {
    // only end by double click undefined NPoints
    if (typeof currentFactory.getNPoints() !== 'undefined') {
      return;
    }
    // exit if not started draw
    if (!started) {
      return;
    }
    // exit if no points
    if (points.length === 0) {
      dwv.logger.warn('Draw dblclick but no points...');
      return;
    }

    // store points
    var layerDetails = dwv.gui.getLayerDetailsFromEvent(event);
    var layerGroup = app.getLayerGroupByDivId(layerDetails.groupDivId);
    onFinalPoints(points, layerGroup);
    // reset flag
    started = false;
  };

  /**
   * Handle mouse out event.
   *
   * @param {object} event The mouse out event.
   */
  this.mouseout = function (event) {
    self.mouseup(event);
  };

  /**
   * Handle touch start event.
   *
   * @param {object} event The touch start event.
   */
  this.touchstart = function (event) {
    self.mousedown(event);
  };

  /**
   * Handle touch move event.
   *
   * @param {object} event The touch move event.
   */
  this.touchmove = function (event) {
    // exit if not started draw
    if (!started) {
      return;
    }

    var layerDetails = dwv.gui.getLayerDetailsFromEvent(event);
    var layerGroup = app.getLayerGroupByDivId(layerDetails.groupDivId);
    var viewLayer = layerGroup.getActiveViewLayer();
    var pos = viewLayer.displayToPlanePos(event._x, event._y);

    if (Math.abs(pos.x - lastPoint.getX()) > 0 ||
      Math.abs(pos.y - lastPoint.getY()) > 0) {
      // clear last added point from the list (but not the first one)
      if (points.length !== 1) {
        points.pop();
      }
      // current point
      lastPoint = new dwv.math.Point2D(pos.x, pos.y);
      // add current one to the list
      points.push(lastPoint);
      // allow for anchor points
      if (points.length < currentFactory.getNPoints()) {
        clearTimeout(this.timer);
        this.timer = setTimeout(function () {
          points.push(lastPoint);
        }, currentFactory.getTimeout());
      }
      // update points
      onNewPoints(points, layerGroup);
    }
  };

  /**
   * Handle touch end event.
   *
   * @param {object} event The touch end event.
   */
  this.touchend = function (event) {
    self.dblclick(event);
  };

  /**
   * Handle mouse wheel event.
   *
   * @param {object} event The mouse wheel event.
   */
  this.wheel = function (event) {
    scrollWhell.wheel(event);
  };

  /**
   * Handle key down event.
   *
   * @param {object} event The key down event.
   */
  this.keydown = function (event) {
    // call app handler if we are not in the middle of a draw
    if (!started) {
      event.context = 'dwv.tool.Draw';
      app.onKeydown(event);
    }
    var konvaLayer;

    // press delete or backspace key
    if ((event.key === 'Delete' ||
      event.key === 'Backspace') &&
      shapeEditor.isActive()) {
      // get shape
      var shapeGroup = shapeEditor.getShape().getParent();
      konvaLayer = shapeGroup.getLayer();
      var shapeDisplayName = dwv.tool.GetShapeDisplayName(
        shapeGroup.getChildren(dwv.draw.isNodeNameShape)[0]);
      // delete command
      var delcmd = new dwv.tool.DeleteGroupCommand(shapeGroup,
        shapeDisplayName, konvaLayer);
      delcmd.onExecute = fireEvent;
      delcmd.onUndo = fireEvent;
      delcmd.execute();
      app.addToUndoStack(delcmd);
    }

    // escape key: exit shape creation
    if (event.key === 'Escape' && tmpShapeGroup !== null) {
      konvaLayer = tmpShapeGroup.getLayer();
      // reset temporary shape group
      tmpShapeGroup.destroy();
      tmpShapeGroup = null;
      // reset flag and points
      started = false;
      points = [];
      // redraw
      konvaLayer.draw();
    }
  };

  /**
   * Update the current draw with new points.
   *
   * @param {Array} tmpPoints The array of new points.
   * @param {dwv.gui.LayerGroup} layerGroup The origin layer group.
   */
  function onNewPoints(tmpPoints, layerGroup) {
    var drawLayer = layerGroup.getActiveDrawLayer();
    var konvaLayer = drawLayer.getKonvaLayer();

    // remove temporary shape draw
    if (tmpShapeGroup) {
      tmpShapeGroup.destroy();
      tmpShapeGroup = null;
    }

    // create shape group
    var viewController =
      layerGroup.getActiveViewLayer().getViewController();
    tmpShapeGroup = currentFactory.create(
      tmpPoints, self.style, viewController);
    // do not listen during creation
    var shape = tmpShapeGroup.getChildren(dwv.draw.isNodeNameShape)[0];
    shape.listening(false);
    konvaLayer.listening(false);
    // draw shape
    konvaLayer.add(tmpShapeGroup);
    konvaLayer.draw();
  }

  /**
   * Create the final shape from a point list.
   *
   * @param {Array} finalPoints The array of points.
   * @param {dwv.gui.LayerGroup} layerGroup The origin layer group.
   */
  function onFinalPoints(finalPoints, layerGroup) {
    var drawLayer = layerGroup.getActiveDrawLayer();
    var konvaLayer = drawLayer.getKonvaLayer();

    // reset temporary shape group
    if (tmpShapeGroup) {
      tmpShapeGroup.destroy();
      tmpShapeGroup = null;
    }

    var viewController =
      layerGroup.getActiveViewLayer().getViewController();
    var drawController =
      layerGroup.getActiveDrawLayer().getDrawController();

    // create final shape
    var finalShapeGroup = currentFactory.create(
      finalPoints, self.style, viewController);
    finalShapeGroup.id(dwv.math.guid());

    // get the position group
    var posGroup = drawController.getCurrentPosGroup();
    // add shape group to position group
    posGroup.add(finalShapeGroup);

    // re-activate layer
    konvaLayer.listening(true);
    // draw shape command
    command = new dwv.tool.DrawGroupCommand(
      finalShapeGroup, self.shapeName, konvaLayer);
    command.onExecute = fireEvent;
    command.onUndo = fireEvent;
    // execute it
    command.execute();
    // save it in undo stack
    app.addToUndoStack(command);

    // activate shape listeners
    self.setShapeOn(finalShapeGroup, layerGroup);
  }

  /**
   * Activate the tool.
   *
   * @param {boolean} flag The flag to activate or not.
   */
  this.activate = function (flag) {
    // reset shape display properties
    shapeEditor.disable();
    shapeEditor.setShape(null);
    shapeEditor.setViewController(null);
    // get the current draw layer
    var layerGroup = app.getActiveLayerGroup();
    activateCurrentPositionShapes(flag, layerGroup);
    // listen to app change to update the draw layer
    if (flag) {
      // store cursor
      originalCursor = document.body.style.cursor;
      // TODO: merge with drawController.activateDrawLayer?
      app.addEventListener('positionchange', function () {
        updateDrawLayer(layerGroup);
      });
      // same for colour
      this.setFeatures({lineColour: this.style.getLineColour()});
    } else {
      // reset shape and cursor
      resetActiveShapeGroup();
      // reset local var
      originalCursor = undefined;
      // remove listeners
      app.removeEventListener('positionchange', function () {
        updateDrawLayer(layerGroup);
      });
    }
  };

  /**
   * Update the draw layer.
   *
   * @param {dwv.gui.LayerGroup} layerGroup The origin layer group.
   */
  function updateDrawLayer(layerGroup) {
    // activate the shape at current position
    activateCurrentPositionShapes(true, layerGroup);
  }

  /**
   * Activate shapes at current position.
   *
   * @param {boolean} visible Set the draw layer visible or not.
   * @param {dwv.gui.LayerGroup} layerGroup The origin layer group.
   */
  function activateCurrentPositionShapes(visible, layerGroup) {
    var drawController =
      layerGroup.getActiveDrawLayer().getDrawController();

    // get shape groups at the current position
    var shapeGroups =
      drawController.getCurrentPosGroup().getChildren();

    // set shape display properties
    if (visible) {
      // activate shape listeners
      shapeGroups.forEach(function (group) {
        self.setShapeOn(group, layerGroup);
      });
    } else {
      // de-activate shape listeners
      shapeGroups.forEach(function (group) {
        setShapeOff(group);
      });
    }
    // draw
    var drawLayer = layerGroup.getActiveDrawLayer();
    var konvaLayer = drawLayer.getKonvaLayer();
    if (shapeGroups.length !== 0) {
      konvaLayer.listening(true);
    }
    konvaLayer.draw();
  }

  /**
   * Set shape group off properties.
   *
   * @param {object} shapeGroup The shape group to set off.
   */
  function setShapeOff(shapeGroup) {
    // mouse styling
    shapeGroup.off('mouseover');
    shapeGroup.off('mouseout');
    // drag
    shapeGroup.draggable(false);
    shapeGroup.off('dragstart.draw');
    shapeGroup.off('dragmove.draw');
    shapeGroup.off('dragend.draw');
    shapeGroup.off('dblclick');
  }

  /**
   * Get the real position from an event.
   * TODO: use layer method?
   *
   * @param {object} index The input index as {x,y}.
   * @param {dwv.gui.LayerGroup} layerGroup The origin layer group.
   * @returns {object} The real position in the image as {x,y}.
   * @private
   */
  function getRealPosition(index, layerGroup) {
    var drawLayer = layerGroup.getActiveDrawLayer();
    var stage = drawLayer.getKonvaStage();
    return {
      x: stage.offset().x + index.x / stage.scale().x,
      y: stage.offset().y + index.y / stage.scale().y
    };
  }

  /**
   * Reset the active shape group and mouse cursor to their original state.
   */
  function resetActiveShapeGroup() {
    if (typeof originalCursor !== 'undefined') {
      document.body.style.cursor = originalCursor;
    }
    if (typeof activeShapeGroup !== 'undefined') {
      activeShapeGroup.opacity(1);
      var colour = self.style.getLineColour();
      activeShapeGroup.getChildren(dwv.draw.canNodeChangeColour).forEach(
        function (ashape) {
          ashape.stroke(colour);
        }
      );
    }
  }

  /**
   * Set shape group on properties.
   *
   * @param {object} shapeGroup The shape group to set on.
   * @param {dwv.gui.LayerGroup} layerGroup The origin layer group.
   */
  this.setShapeOn = function (shapeGroup, layerGroup) {
    // adapt shape and cursor when mouse over
    var mouseOnShape = function () {
      document.body.style.cursor = mouseOverCursor;
      shapeGroup.opacity(0.75);
    };
    // mouse over event hanlding
    shapeGroup.on('mouseover', function () {
      // save local vars
      activeShapeGroup = shapeGroup;
      // adapt shape
      mouseOnShape();
    });
    // mouse out event hanlding
    shapeGroup.on('mouseout', function () {
      // reset shape
      resetActiveShapeGroup();
      // reset local vars
      activeShapeGroup = undefined;
    });

    var drawLayer = layerGroup.getActiveDrawLayer();
    var konvaLayer = drawLayer.getKonvaLayer();

    // make it draggable
    shapeGroup.draggable(true);
    // cache drag start position
    var dragStartPos = {x: shapeGroup.x(), y: shapeGroup.y()};

    // command name based on shape type
    var shapeDisplayName = dwv.tool.GetShapeDisplayName(
      shapeGroup.getChildren(dwv.draw.isNodeNameShape)[0]);

    var colour = null;

    // drag start event handling
    shapeGroup.on('dragstart.draw', function (/*event*/) {
      // store colour
      colour = shapeGroup.getChildren(dwv.draw.isNodeNameShape)[0].stroke();
      // display trash
      var drawLayer = layerGroup.getActiveDrawLayer();
      var stage = drawLayer.getKonvaStage();
      var scale = stage.scale();
      var invscale = {x: 1 / scale.x, y: 1 / scale.y};
      trash.x(stage.offset().x + (stage.width() / (2 * scale.x)));
      trash.y(stage.offset().y + (stage.height() / (15 * scale.y)));
      trash.scale(invscale);
      konvaLayer.add(trash);
      // deactivate anchors to avoid events on null shape
      shapeEditor.setAnchorsActive(false);
      // draw
      konvaLayer.draw();
    });
    // drag move event handling
    shapeGroup.on('dragmove.draw', function (event) {
      var drawLayer = layerGroup.getActiveDrawLayer();
      // validate the group position
      dwv.tool.validateGroupPosition(drawLayer.getBaseSize(), this);
      // get appropriate factory
      var factory;
      var keys = Object.keys(self.shapeFactoryList);
      for (var i = 0; i < keys.length; ++i) {
        factory = new self.shapeFactoryList[keys[i]];
        if (factory.isFactoryGroup(shapeGroup)) {
          // stop at first find
          break;
        }
      }
      if (typeof factory === 'undefined') {
        throw new Error('Cannot find factory to update quantification.');
      }
      // update quantification if possible
      if (typeof factory.updateQuantification !== 'undefined') {
        var vc = layerGroup.getActiveViewLayer().getViewController();
        factory.updateQuantification(this, vc);
      }
      // highlight trash when on it
      var offset = dwv.gui.getEventOffset(event.evt)[0];
      var eventPos = getRealPosition(offset, layerGroup);
      var trashHalfWidth = trash.width() * trash.scaleX() / 2;
      var trashHalfHeight = trash.height() * trash.scaleY() / 2;
      if (Math.abs(eventPos.x - trash.x()) < trashHalfWidth &&
        Math.abs(eventPos.y - trash.y()) < trashHalfHeight) {
        trash.getChildren().forEach(function (tshape) {
          tshape.stroke('orange');
        });
        // change the group shapes colour
        shapeGroup.getChildren(dwv.draw.canNodeChangeColour).forEach(
          function (ashape) {
            ashape.stroke('red');
          });
      } else {
        trash.getChildren().forEach(function (tshape) {
          tshape.stroke('red');
        });
        // reset the group shapes colour
        shapeGroup.getChildren(dwv.draw.canNodeChangeColour).forEach(
          function (ashape) {
            if (typeof ashape.stroke !== 'undefined') {
              ashape.stroke(colour);
            }
          });
      }
      // draw
      konvaLayer.draw();
    });
    // drag end event handling
    shapeGroup.on('dragend.draw', function (event) {
      // remove trash
      trash.remove();
      // activate(false) will also trigger a dragend.draw
      if (typeof event === 'undefined' ||
        typeof event.evt === 'undefined') {
        return;
      }
      var pos = {x: this.x(), y: this.y()};
      // delete case
      var offset = dwv.gui.getEventOffset(event.evt)[0];
      var eventPos = getRealPosition(offset, layerGroup);
      var trashHalfWidth = trash.width() * trash.scaleX() / 2;
      var trashHalfHeight = trash.height() * trash.scaleY() / 2;
      if (Math.abs(eventPos.x - trash.x()) < trashHalfWidth &&
        Math.abs(eventPos.y - trash.y()) < trashHalfHeight) {
        // compensate for the drag translation
        this.x(dragStartPos.x);
        this.y(dragStartPos.y);
        // disable editor
        shapeEditor.disable();
        shapeEditor.setShape(null);
        shapeEditor.setViewController(null);
        // reset colour
        shapeGroup.getChildren(dwv.draw.canNodeChangeColour).forEach(
          function (ashape) {
            ashape.stroke(colour);
          });
        // reset cursor
        document.body.style.cursor = originalCursor;
        // delete command
        var delcmd = new dwv.tool.DeleteGroupCommand(this,
          shapeDisplayName, konvaLayer);
        delcmd.onExecute = fireEvent;
        delcmd.onUndo = fireEvent;
        delcmd.execute();
        app.addToUndoStack(delcmd);
      } else {
        // save drag move
        var translation = {x: pos.x - dragStartPos.x,
          y: pos.y - dragStartPos.y};
        if (translation.x !== 0 || translation.y !== 0) {
          var mvcmd = new dwv.tool.MoveGroupCommand(this,
            shapeDisplayName, translation, konvaLayer);
          mvcmd.onExecute = fireEvent;
          mvcmd.onUndo = fireEvent;
          app.addToUndoStack(mvcmd);

          // the move is handled by Konva, trigger an event manually
          fireEvent({
            type: 'drawmove',
            id: this.id()
          });
        }
        // reset anchors
        shapeEditor.setAnchorsActive(true);
        shapeEditor.resetAnchors();
      }
      // draw
      konvaLayer.draw();
      // reset start position
      dragStartPos = {x: this.x(), y: this.y()};
    });
    // double click handling: update label
    shapeGroup.on('dblclick', function () {
      // get the label object for this shape
      var label = this.findOne('Label');
      // should just be one
      if (typeof label === 'undefined') {
        throw new Error('Could not find the shape label.');
      }
      var ktext = label.getText();
      // id for event
      var groupId = this.id();

      var onSaveCallback = function (meta) {
        // store meta
        ktext.meta = meta;
        // update text expression
        ktext.setText(dwv.utils.replaceFlags(
          ktext.meta.textExpr, ktext.meta.quantification));
        label.setVisible(ktext.meta.textExpr.length !== 0);

        // trigger event
        fireEvent({
          type: 'drawchange',
          id: groupId
        });
        // draw
        konvaLayer.draw();
      };

      // call client dialog if defined
      if (typeof dwv.openRoiDialog !== 'undefined') {
        dwv.openRoiDialog(ktext.meta, onSaveCallback);
      } else {
        // simple prompt for the text expression
        var textExpr = dwv.prompt('Label', ktext.meta.textExpr);
        if (textExpr !== null) {
          ktext.meta.textExpr = textExpr;
          onSaveCallback(ktext.meta);
        }
      }
    });
  };

  /**
   * Set the tool configuration options.
   *
   * @param {object} options The list of shape names amd classes.
   */
  this.setOptions = function (options) {
    // save the options as the shape factory list
    this.shapeFactoryList = options;
    // pass them to the editor
    shapeEditor.setFactoryList(options);
  };

  /**
   * Get the type of tool options: here 'factory' since the shape
   * list contains factories to create each possible shape.
   *
   * @returns {string} The type.
   */
  this.getOptionsType = function () {
    return 'factory';
  };

  /**
   * Set the tool live features: shape colour and shape name.
   *
   * @param {object} features The list of features.
   */
  this.setFeatures = function (features) {
    if (typeof features.shapeColour !== 'undefined') {
      this.style.setLineColour(features.shapeColour);
    }
    if (typeof features.shapeName !== 'undefined') {
      // check if we have it
      if (!this.hasShape(features.shapeName)) {
        throw new Error('Unknown shape: \'' + features.shapeName + '\'');
      }
      this.shapeName = features.shapeName;
    }
    if (typeof features.mouseOverCursor !== 'undefined') {
      mouseOverCursor = features.mouseOverCursor;
    }
  };

  /**
   * Initialise the tool.
   */
  this.init = function () {
    // does nothing
  };

  /**
   * Get the list of event names that this tool can fire.
   *
   * @returns {Array} The list of event names.
   */
  this.getEventNames = function () {
    return [
      'drawcreate', 'drawchange', 'drawmove', 'drawdelete', 'drawlabelchange'
    ];
  };

  /**
   * Add an event listener on the app.
   *
   * @param {string} type The event type.
   * @param {object} listener The method associated with the provided
   *   event type.
   */
  this.addEventListener = function (type, listener) {
    if (typeof listeners[type] === 'undefined') {
      listeners[type] = [];
    }
    listeners[type].push(listener);
  };

  /**
   * Remove an event listener from the app.
   *
   * @param {string} type The event type.
   * @param {object} listener The method associated with the provided
   *   event type.
   */
  this.removeEventListener = function (type, listener) {
    if (typeof listeners[type] === 'undefined') {
      return;
    }
    for (var i = 0; i < listeners[type].length; ++i) {
      if (listeners[type][i] === listener) {
        listeners[type].splice(i, 1);
      }
    }
  };

  // Private Methods -----------------------------------------------------------

  /**
   * Fire an event: call all associated listeners.
   *
   * @param {object} event The event to fire.
   * @private
   */
  function fireEvent(event) {
    if (typeof listeners[event.type] === 'undefined') {
      return;
    }
    for (var i = 0; i < listeners[event.type].length; ++i) {
      listeners[event.type][i](event);
    }
  }

}; // Draw class

/**
 * Check if the shape is in the shape list.
 *
 * @param {string} name The name of the shape.
 * @returns {boolean} True if there is a factory for the shape.
 */
dwv.tool.Draw.prototype.hasShape = function (name) {
  return this.shapeFactoryList[name];
};

/**
 * Get the minimum position in a groups' anchors.
 *
 * @param {object} group The group that contains anchors.
 * @returns {object|undefined} The minimum position as {x,y}.
 */
dwv.tool.getAnchorMin = function (group) {
  var anchors = group.find('.anchor');
  if (anchors.length === 0) {
    return undefined;
  }
  var minX = anchors[0].x();
  var minY = anchors[0].y();
  for (var i = 0; i < anchors.length; ++i) {
    minX = Math.min(minX, anchors[i].x());
    minY = Math.min(minY, anchors[i].y());
  }

  return {x: minX, y: minY};
};

/**
 * Bound a node position.
 *
 * @param {object} node The node to bound the position.
 * @param {object} min The minimum position as {x,y}.
 * @param {object} max The maximum position as {x,y}.
 * @returns {boolean} True if the position was corrected.
 */
dwv.tool.boundNodePosition = function (node, min, max) {
  var changed = false;
  if (node.x() < min.x) {
    node.x(min.x);
    changed = true;
  } else if (node.x() > max.x) {
    node.x(max.x);
    changed = true;
  }
  if (node.y() < min.y) {
    node.y(min.y);
    changed = true;
  } else if (node.y() > max.y) {
    node.y(max.y);
    changed = true;
  }
  return changed;
};

/**
 * Validate a group position.
 *
 * @param {object} stageSize The stage size {x,y}.
 * @param {object} group The group to evaluate.
 * @returns {boolean} True if the position was corrected.
 */
dwv.tool.validateGroupPosition = function (stageSize, group) {
  // if anchors get mixed, width/height can be negative
  var shape = group.getChildren(dwv.draw.isNodeNameShape)[0];
  var anchorMin = dwv.tool.getAnchorMin(group);
  // handle no anchor: when dragging the label, the editor does
  //   not activate
  if (typeof anchorMin === 'undefined') {
    return null;
  }

  var min = {
    x: -anchorMin.x,
    y: -anchorMin.y
  };
  var max = {
    x: stageSize.x -
      (anchorMin.x + Math.abs(shape.width())),
    y: stageSize.y -
      (anchorMin.y + Math.abs(shape.height()))
  };

  return dwv.tool.boundNodePosition(group, min, max);
};

/**
 * Validate an anchor position.
 *
 * @param {object} stageSize The stage size {x,y}.
 * @param {object} anchor The anchor to evaluate.
 * @returns {boolean} True if the position was corrected.
 */
dwv.tool.validateAnchorPosition = function (stageSize, anchor) {
  var group = anchor.getParent();

  var min = {
    x: -group.x(),
    y: -group.y()
  };
  var max = {
    x: stageSize.x - group.x(),
    y: stageSize.y - group.y()
  };

  return dwv.tool.boundNodePosition(anchor, min, max);
};

// namespaces
var dwv = dwv || {};
dwv.tool = dwv.tool || {};
/**
 * The Konva namespace.
 *
 * @external Konva
 * @see https://konvajs.org/
 */
var Konva = Konva || {};

/**
 * Get the display name of the input shape.
 *
 * @param {object} shape The Konva shape.
 * @returns {string} The display name.
 */
dwv.tool.GetShapeDisplayName = function (shape) {
  var displayName = 'shape';
  if (shape instanceof Konva.Line) {
    if (shape.points().length === 4) {
      displayName = 'line';
    } else if (shape.points().length === 6) {
      displayName = 'protractor';
    } else {
      displayName = 'roi';
    }
  } else if (shape instanceof Konva.Rect) {
    displayName = 'rectangle';
  } else if (shape instanceof Konva.Ellipse) {
    displayName = 'ellipse';
  }
  // return
  return displayName;
};

/**
 * Draw group command.
 *
 * @param {object} group The group draw.
 * @param {string} name The shape display name.
 * @param {object} layer The layer where to draw the group.
 * @param {boolean} silent Whether to send a creation event or not.
 * @class
 */
dwv.tool.DrawGroupCommand = function (group, name, layer, silent) {
  var isSilent = (typeof silent === 'undefined') ? false : silent;

  // group parent
  var parent = group.getParent();

  /**
   * Get the command name.
   *
   * @returns {string} The command name.
   */
  this.getName = function () {
    return 'Draw-' + name;
  };
  /**
   * Execute the command.
   *
   * @fires dwv.tool.DrawGroupCommand#drawcreate
   */
  this.execute = function () {
    // add the group to the parent (in case of undo/redo)
    parent.add(group);
    // draw
    layer.draw();
    // callback
    if (!isSilent) {
      /**
       * Draw create event.
       *
       * @event dwv.tool.DrawGroupCommand#drawcreate
       * @type {object}
       * @property {number} id The id of the create draw.
       */
      this.onExecute({
        type: 'drawcreate',
        id: group.id()
      });
    }
  };
  /**
   * Undo the command.
   *
   * @fires dwv.tool.DeleteGroupCommand#drawdelete
   */
  this.undo = function () {
    // remove the group from the parent layer
    group.remove();
    // draw
    layer.draw();
    // callback
    this.onUndo({
      type: 'drawdelete',
      id: group.id()
    });
  };
}; // DrawGroupCommand class

/**
 * Handle an execute event.
 *
 * @param {object} _event The execute event with type and id.
 */
dwv.tool.DrawGroupCommand.prototype.onExecute = function (_event) {
  // default does nothing.
};
/**
 * Handle an undo event.
 *
 * @param {object} _event The undo event with type and id.
 */
dwv.tool.DrawGroupCommand.prototype.onUndo = function (_event) {
  // default does nothing.
};

/**
 * Move group command.
 *
 * @param {object} group The group draw.
 * @param {string} name The shape display name.
 * @param {object} translation A 2D translation to move the group by.
 * @param {object} layer The layer where to move the group.
 * @class
 */
dwv.tool.MoveGroupCommand = function (group, name, translation, layer) {
  /**
   * Get the command name.
   *
   * @returns {string} The command name.
   */
  this.getName = function () {
    return 'Move-' + name;
  };

  /**
   * Execute the command.
   *
   * @fires dwv.tool.MoveGroupCommand#drawmove
   */
  this.execute = function () {
    // translate group
    group.move(translation);
    // draw
    layer.draw();
    // callback
    /**
     * Draw move event.
     *
     * @event dwv.tool.MoveGroupCommand#drawmove
     * @type {object}
     * @property {number} id The id of the create draw.
     */
    this.onExecute({
      type: 'drawmove',
      id: group.id()
    });
  };
  /**
   * Undo the command.
   *
   * @fires dwv.tool.MoveGroupCommand#drawmove
   */
  this.undo = function () {
    // invert translate group
    var minusTrans = {x: -translation.x, y: -translation.y};
    group.move(minusTrans);
    // draw
    layer.draw();
    // callback
    this.onUndo({
      type: 'drawmove',
      id: group.id()
    });
  };
}; // MoveGroupCommand class

/**
 * Handle an execute event.
 *
 * @param {object} _event The execute event with type and id.
 */
dwv.tool.MoveGroupCommand.prototype.onExecute = function (_event) {
  // default does nothing.
};
/**
 * Handle an undo event.
 *
 * @param {object} _event The undo event with type and id.
 */
dwv.tool.MoveGroupCommand.prototype.onUndo = function (_event) {
  // default does nothing.
};

/**
 * Change group command.
 *
 * @param {string} name The shape display name.
 * @param {object} func The change function.
 * @param {object} startAnchor The anchor that starts the change.
 * @param {object} endAnchor The anchor that ends the change.
 * @param {object} layer The layer where to change the group.
 * @param {object} viewController The associated viewController.
 * @param {object} style The app style.
 * @class
 */
dwv.tool.ChangeGroupCommand = function (
  name, func, startAnchor, endAnchor, layer, viewController, style) {
  /**
   * Get the command name.
   *
   * @returns {string} The command name.
   */
  this.getName = function () {
    return 'Change-' + name;
  };

  /**
   * Execute the command.
   *
   * @fires dwv.tool.ChangeGroupCommand#drawchange
   */
  this.execute = function () {
    // change shape
    func(endAnchor, style, viewController);
    // draw
    layer.draw();
    // callback
    /**
     * Draw change event.
     *
     * @event dwv.tool.ChangeGroupCommand#drawchange
     * @type {object}
     */
    this.onExecute({
      type: 'drawchange',
      id: endAnchor.getParent().id()
    });
  };
  /**
   * Undo the command.
   *
   * @fires dwv.tool.ChangeGroupCommand#drawchange
   */
  this.undo = function () {
    // invert change shape
    func(startAnchor, style, viewController);
    // draw
    layer.draw();
    // callback
    this.onUndo({
      type: 'drawchange',
      id: startAnchor.getParent().id()
    });
  };
}; // ChangeGroupCommand class

/**
 * Handle an execute event.
 *
 * @param {object} _event The execute event with type and id.
 */
dwv.tool.ChangeGroupCommand.prototype.onExecute = function (_event) {
  // default does nothing.
};
/**
 * Handle an undo event.
 *
 * @param {object} _event The undo event with type and id.
 */
dwv.tool.ChangeGroupCommand.prototype.onUndo = function (_event) {
  // default does nothing.
};

/**
 * Delete group command.
 *
 * @param {object} group The group draw.
 * @param {string} name The shape display name.
 * @param {object} layer The layer where to delete the group.
 * @class
 */
dwv.tool.DeleteGroupCommand = function (group, name, layer) {
  // group parent
  var parent = group.getParent();

  /**
   * Get the command name.
   *
   * @returns {string} The command name.
   */
  this.getName = function () {
    return 'Delete-' + name;
  };
  /**
   * Execute the command.
   *
   * @fires dwv.tool.DeleteGroupCommand#drawdelete
   */
  this.execute = function () {
    // remove the group from its parent
    group.remove();
    // draw
    layer.draw();
    // callback
    /**
     * Draw delete event.
     *
     * @event dwv.tool.DeleteGroupCommand#drawdelete
     * @type {object}
     * @property {number} id The id of the create draw.
     */
    this.onExecute({
      type: 'drawdelete',
      id: group.id()
    });
  };
  /**
   * Undo the command.
   *
   * @fires dwv.tool.DrawGroupCommand#drawcreate
   */
  this.undo = function () {
    // add the group to its parent
    parent.add(group);
    // draw
    layer.draw();
    // callback
    this.onUndo({
      type: 'drawcreate',
      id: group.id()
    });
  };
}; // DeleteGroupCommand class

/**
 * Handle an execute event.
 *
 * @param {object} _event The execute event with type and id.
 */
dwv.tool.DeleteGroupCommand.prototype.onExecute = function (_event) {
  // default does nothing.
};
/**
 * Handle an undo event.
 *
 * @param {object} _event The undo event with type and id.
 */
dwv.tool.DeleteGroupCommand.prototype.onUndo = function (_event) {
  // default does nothing.
};

// namespaces
var dwv = dwv || {};
dwv.tool = dwv.tool || {};
dwv.tool.draw = dwv.tool.draw || {};
/**
 * The Konva namespace.
 *
 * @external Konva
 * @see https://konvajs.org/
 */
var Konva = Konva || {};

/**
 * Get the default anchor shape.
 *
 * @param {number} x The X position.
 * @param {number} y The Y position.
 * @param {string} id The shape id.
 * @param {object} style The application style.
 * @returns {object} The default anchor shape.
 */
dwv.tool.draw.getDefaultAnchor = function (x, y, id, style) {
  var radius = style.applyZoomScale(3);
  return new Konva.Ellipse({
    x: x,
    y: y,
    stroke: '#999',
    fill: 'rgba(100,100,100,0.7',
    strokeWidth: style.getStrokeWidth(),
    strokeScaleEnabled: false,
    radius: {
      x: Math.abs(radius.x),
      y: Math.abs(radius.y)
    },
    name: 'anchor',
    id: id,
    dragOnTop: false,
    draggable: true,
    visible: false
  });
};

/**
 * Shape editor.
 *
 * @param {object} app The associated application.
 * @class
 */
dwv.tool.ShapeEditor = function (app) {
  /**
   * Shape factory list
   *
   * @type {object}
   * @private
   */
  var shapeFactoryList = null;
  /**
   * Current shape factory.
   *
   * @type {object}
   * @private
   */
  var currentFactory = null;
  /**
   * Edited shape.
   *
   * @private
   * @type {object}
   */
  var shape = null;
  /**
   * Edited view controller. Used for quantification update.
   *
   * @private
   * @type {object}
   */
  var viewController = null;
  /**
   * Active flag.
   *
   * @private
   * @type {boolean}
   */
  var isActive = false;
  /**
   * Draw event callback.
   *
   * @private
   * @type {Function}
   */
  var drawEventCallback = null;

  /**
   * Set the tool options.
   *
   * @param {Array} list The list of shape classes.
   */
  this.setFactoryList = function (list) {
    shapeFactoryList = list;
  };

  /**
   * Set the shape to edit.
   *
   * @param {object} inshape The shape to edit.
   */
  this.setShape = function (inshape) {
    shape = inshape;
    if (shape) {
      // remove old anchors
      removeAnchors();
      // find a factory for the input shape
      var group = shape.getParent();
      var keys = Object.keys(shapeFactoryList);
      currentFactory = null;
      for (var i = 0; i < keys.length; ++i) {
        var factory = new shapeFactoryList[keys[i]];
        if (factory.isFactoryGroup(group)) {
          currentFactory = factory;
          // stop at first find
          break;
        }
      }
      if (currentFactory === null) {
        throw new Error('Could not find a factory to update shape.');
      }
      // add new anchors
      addAnchors();
    }
  };

  /**
   * Set the associated image.
   *
   * @param {object} vc The associated view controller.
   */
  this.setViewController = function (vc) {
    viewController = vc;
  };

  /**
   * Get the edited shape.
   *
   * @returns {object} The edited shape.
   */
  this.getShape = function () {
    return shape;
  };

  /**
   * Get the active flag.
   *
   * @returns {boolean} The active flag.
   */
  this.isActive = function () {
    return isActive;
  };

  /**
   * Set the draw event callback.
   *
   * @param {object} callback The callback.
   */
  this.setDrawEventCallback = function (callback) {
    drawEventCallback = callback;
  };

  /**
   * Enable the editor. Redraws the layer.
   */
  this.enable = function () {
    isActive = true;
    if (shape) {
      setAnchorsVisible(true);
      if (shape.getLayer()) {
        shape.getLayer().draw();
      }
    }
  };

  /**
   * Disable the editor. Redraws the layer.
   */
  this.disable = function () {
    isActive = false;
    if (shape) {
      setAnchorsVisible(false);
      if (shape.getLayer()) {
        shape.getLayer().draw();
      }
    }
  };

  /**
   * Reset the anchors.
   */
  this.resetAnchors = function () {
    // remove previous controls
    removeAnchors();
    // add anchors
    addAnchors();
    // set them visible
    setAnchorsVisible(true);
  };

  /**
   * Apply a function on all anchors.
   *
   * @param {object} func A f(shape) function.
   * @private
   */
  function applyFuncToAnchors(func) {
    if (shape && shape.getParent()) {
      var anchors = shape.getParent().find('.anchor');
      anchors.forEach(func);
    }
  }

  /**
   * Set anchors visibility.
   *
   * @param {boolean} flag The visible flag.
   * @private
   */
  function setAnchorsVisible(flag) {
    applyFuncToAnchors(function (anchor) {
      anchor.visible(flag);
    });
  }

  /**
   * Set anchors active.
   *
   * @param {boolean} flag The active (on/off) flag.
   */
  this.setAnchorsActive = function (flag) {
    var func = null;
    if (flag) {
      func = function (anchor) {
        setAnchorOn(anchor);
      };
    } else {
      func = function (anchor) {
        setAnchorOff(anchor);
      };
    }
    applyFuncToAnchors(func);
  };

  /**
   * Remove anchors.
   *
   * @private
   */
  function removeAnchors() {
    applyFuncToAnchors(function (anchor) {
      anchor.remove();
    });
  }

  /**
   * Add the shape anchors.
   *
   * @private
   */
  function addAnchors() {
    // exit if no shape or no layer
    if (!shape || !shape.getLayer()) {
      return;
    }
    // get shape group
    var group = shape.getParent();

    // activate and add anchors to group
    var anchors = currentFactory.getAnchors(shape, app.getStyle());
    for (var i = 0; i < anchors.length; ++i) {
      // set anchor on
      setAnchorOn(anchors[i]);
      // add the anchor to the group
      group.add(anchors[i]);
    }
  }

  /**
   * Get a simple clone of the input anchor.
   *
   * @param {object} anchor The anchor to clone.
   * @returns {object} A clone of the input anchor.
   * @private
   */
  function getClone(anchor) {
    // create closure to properties
    var parent = anchor.getParent();
    var id = anchor.id();
    var x = anchor.x();
    var y = anchor.y();
    // create clone object
    var clone = {};
    clone.getParent = function () {
      return parent;
    };
    clone.id = function () {
      return id;
    };
    clone.x = function () {
      return x;
    };
    clone.y = function () {
      return y;
    };
    return clone;
  }

  /**
   * Set the anchor on listeners.
   *
   * @param {object} anchor The anchor to set on.
   * @private
   */
  function setAnchorOn(anchor) {
    var startAnchor = null;

    // command name based on shape type
    var shapeDisplayName = dwv.tool.GetShapeDisplayName(shape);

    // drag start listener
    anchor.on('dragstart.edit', function (evt) {
      startAnchor = getClone(this);
      // prevent bubbling upwards
      evt.cancelBubble = true;
    });
    // drag move listener
    anchor.on('dragmove.edit', function (evt) {
      var layerDetails = dwv.gui.getLayerDetailsFromEvent(evt.evt);
      var layerGroup = app.getLayerGroupByDivId(layerDetails.groupDivId);
      var drawLayer = layerGroup.getActiveDrawLayer();
      // validate the anchor position
      dwv.tool.validateAnchorPosition(drawLayer.getBaseSize(), this);
      // update shape
      currentFactory.update(this, app.getStyle(), viewController);
      // redraw
      if (this.getLayer()) {
        this.getLayer().draw();
      } else {
        dwv.logger.warn('No layer to draw the anchor!');
      }
      // prevent bubbling upwards
      evt.cancelBubble = true;
    });
    // drag end listener
    anchor.on('dragend.edit', function (evt) {
      var endAnchor = getClone(this);
      // store the change command
      var chgcmd = new dwv.tool.ChangeGroupCommand(
        shapeDisplayName,
        currentFactory.update,
        startAnchor,
        endAnchor,
        this.getLayer(),
        viewController,
        app.getStyle()
      );
      chgcmd.onExecute = drawEventCallback;
      chgcmd.onUndo = drawEventCallback;
      chgcmd.execute();
      app.addToUndoStack(chgcmd);
      // reset start anchor
      startAnchor = endAnchor;
      // prevent bubbling upwards
      evt.cancelBubble = true;
    });
    // mouse down listener
    anchor.on('mousedown touchstart', function () {
      this.moveToTop();
    });
    // mouse over styling
    anchor.on('mouseover.edit', function () {
      // style is handled by the group
      this.stroke('#ddd');
      if (this.getLayer()) {
        this.getLayer().draw();
      } else {
        dwv.logger.warn('No layer to draw the anchor!');
      }
    });
    // mouse out styling
    anchor.on('mouseout.edit', function () {
      // style is handled by the group
      this.stroke('#999');
      if (this.getLayer()) {
        this.getLayer().draw();
      } else {
        dwv.logger.warn('No layer to draw the anchor!');
      }
    });
  }

  /**
   * Set the anchor off listeners.
   *
   * @param {object} anchor The anchor to set off.
   * @private
   */
  function setAnchorOff(anchor) {
    anchor.off('dragstart.edit');
    anchor.off('dragmove.edit');
    anchor.off('dragend.edit');
    anchor.off('mousedown touchstart');
    anchor.off('mouseover.edit');
    anchor.off('mouseout.edit');
  }
};

// namespaces
var dwv = dwv || {};
dwv.tool = dwv.tool || {};
dwv.tool.draw = dwv.tool.draw || {};
/**
 * The Konva namespace.
 *
 * @external Konva
 * @see https://konvajs.org/
 */
var Konva = Konva || {};

/**
 * Default draw label text.
 */
dwv.tool.draw.defaultEllipseLabelText = '{surface}';

/**
 * Ellipse factory.
 *
 * @class
 */
dwv.tool.draw.EllipseFactory = function () {
  /**
   * Get the name of the shape group.
   *
   * @returns {string} The name.
   */
  this.getGroupName = function () {
    return 'ellipse-group';
  };
  /**
   * Get the number of points needed to build the shape.
   *
   * @returns {number} The number of points.
   */
  this.getNPoints = function () {
    return 2;
  };
  /**
   * Get the timeout between point storage.
   *
   * @returns {number} The timeout in milliseconds.
   */
  this.getTimeout = function () {
    return 0;
  };
};

/**
 * Is the input group a group of this factory?
 *
 * @param {object} group The group to test.
 * @returns {boolean} True if the group is from this fcatory.
 */
dwv.tool.draw.EllipseFactory.prototype.isFactoryGroup = function (group) {
  return this.getGroupName() === group.name();
};

/**
 * Create an ellipse shape to be displayed.
 *
 * @param {Array} points The points from which to extract the ellipse.
 * @param {object} style The drawing style.
 * @param {object} viewController The associated view controller.
 * @returns {object} The Konva group.
 */
dwv.tool.draw.EllipseFactory.prototype.create = function (
  points, style, viewController) {
  // calculate radius
  var a = Math.abs(points[0].getX() - points[1].getX());
  var b = Math.abs(points[0].getY() - points[1].getY());
  // physical shape
  var ellipse = new dwv.math.Ellipse(points[0], a, b);
  // draw shape
  var kshape = new Konva.Ellipse({
    x: ellipse.getCenter().getX(),
    y: ellipse.getCenter().getY(),
    radius: {x: ellipse.getA(), y: ellipse.getB()},
    stroke: style.getLineColour(),
    strokeWidth: style.getStrokeWidth(),
    strokeScaleEnabled: false,
    name: 'shape'
  });
  // quantification
  var ktext = new Konva.Text({
    fontSize: style.getFontSize(),
    fontFamily: style.getFontFamily(),
    fill: style.getLineColour(),
    padding: style.getTextPadding(),
    shadowColor: style.getShadowLineColour(),
    shadowOffset: style.getShadowOffset(),
    name: 'text'
  });
  var textExpr = '';
  if (typeof dwv.tool.draw.ellipseLabelText !== 'undefined') {
    textExpr = dwv.tool.draw.ellipseLabelText;
  } else {
    textExpr = dwv.tool.draw.defaultEllipseLabelText;
  }
  var quant = ellipse.quantify(
    viewController,
    dwv.utils.getFlags(textExpr));
  ktext.setText(dwv.utils.replaceFlags(textExpr, quant));
  // meta data
  ktext.meta = {
    textExpr: textExpr,
    quantification: quant
  };
  // label
  var klabel = new Konva.Label({
    x: ellipse.getCenter().getX(),
    y: ellipse.getCenter().getY(),
    scale: style.applyZoomScale(1),
    visible: textExpr.length !== 0,
    name: 'label'
  });
  klabel.add(ktext);
  klabel.add(new Konva.Tag({
    fill: style.getLineColour(),
    opacity: style.getTagOpacity()
  }));

  // debug shadow
  var kshadow;
  if (dwv.tool.draw.debug) {
    kshadow = dwv.tool.draw.getShadowEllipse(ellipse);
  }

  // return group
  var group = new Konva.Group();
  group.name(this.getGroupName());
  if (kshadow) {
    group.add(kshadow);
  }
  group.add(klabel);
  group.add(kshape);
  group.visible(true); // dont inherit
  return group;
};

/**
 * Get anchors to update an ellipse shape.
 *
 * @param {object} shape The associated shape.
 * @param {object} style The application style.
 * @returns {Array} A list of anchors.
 */
dwv.tool.draw.EllipseFactory.prototype.getAnchors = function (shape, style) {
  var ellipseX = shape.x();
  var ellipseY = shape.y();
  var radius = shape.radius();

  var anchors = [];
  anchors.push(dwv.tool.draw.getDefaultAnchor(
    ellipseX - radius.x, ellipseY - radius.y, 'topLeft', style
  ));
  anchors.push(dwv.tool.draw.getDefaultAnchor(
    ellipseX + radius.x, ellipseY - radius.y, 'topRight', style
  ));
  anchors.push(dwv.tool.draw.getDefaultAnchor(
    ellipseX + radius.x, ellipseY + radius.y, 'bottomRight', style
  ));
  anchors.push(dwv.tool.draw.getDefaultAnchor(
    ellipseX - radius.x, ellipseY + radius.y, 'bottomLeft', style
  ));
  return anchors;
};

/**
 * Update an ellipse shape.
 * Warning: do NOT use 'this' here, this method is passed
 *   as is to the change command.
 *
 * @param {object} anchor The active anchor.
 * @param {object} _style The app style.
 * @param {object} viewController The associated view controller.
 */
dwv.tool.draw.EllipseFactory.prototype.update = function (
  anchor, _style, viewController) {
  // parent group
  var group = anchor.getParent();
  // associated shape
  var kellipse = group.getChildren(function (node) {
    return node.name() === 'shape';
  })[0];
    // associated label
  var klabel = group.getChildren(function (node) {
    return node.name() === 'label';
  })[0];
    // find special points
  var topLeft = group.getChildren(function (node) {
    return node.id() === 'topLeft';
  })[0];
  var topRight = group.getChildren(function (node) {
    return node.id() === 'topRight';
  })[0];
  var bottomRight = group.getChildren(function (node) {
    return node.id() === 'bottomRight';
  })[0];
  var bottomLeft = group.getChildren(function (node) {
    return node.id() === 'bottomLeft';
  })[0];
  // debug shadow
  var kshadow;
  if (dwv.tool.draw.debug) {
    kshadow = group.getChildren(function (node) {
      return node.name() === 'shadow';
    })[0];
  }

  // update 'self' (undo case) and special points
  switch (anchor.id()) {
  case 'topLeft':
    topLeft.x(anchor.x());
    topLeft.y(anchor.y());
    topRight.y(anchor.y());
    bottomLeft.x(anchor.x());
    break;
  case 'topRight':
    topRight.x(anchor.x());
    topRight.y(anchor.y());
    topLeft.y(anchor.y());
    bottomRight.x(anchor.x());
    break;
  case 'bottomRight':
    bottomRight.x(anchor.x());
    bottomRight.y(anchor.y());
    bottomLeft.y(anchor.y());
    topRight.x(anchor.x());
    break;
  case 'bottomLeft':
    bottomLeft.x(anchor.x());
    bottomLeft.y(anchor.y());
    bottomRight.y(anchor.y());
    topLeft.x(anchor.x());
    break;
  default :
    dwv.logger.error('Unhandled anchor id: ' + anchor.id());
    break;
  }
  // update shape
  var radiusX = (topRight.x() - topLeft.x()) / 2;
  var radiusY = (bottomRight.y() - topRight.y()) / 2;
  var center = {
    x: topLeft.x() + radiusX,
    y: topRight.y() + radiusY
  };
  kellipse.position(center);
  var radiusAbs = {x: Math.abs(radiusX), y: Math.abs(radiusY)};
  if (radiusAbs) {
    kellipse.radius(radiusAbs);
  }
  // new ellipse
  var centerPoint = new dwv.math.Point2D(
    group.x() + center.x,
    group.y() + center.y
  );
  var ellipse = new dwv.math.Ellipse(centerPoint, radiusAbs.x, radiusAbs.y);

  // debug shadow
  if (kshadow) {
    // remove previous
    kshadow.destroy();
    // add new
    group.add(dwv.tool.draw.getShadowEllipse(ellipse, group));
  }

  // update label position
  var textPos = {x: center.x, y: center.y};
  klabel.position(textPos);

  // update quantification
  dwv.tool.draw.updateEllipseQuantification(group, viewController);
};

/**
 * Update the quantification of an Ellipse.
 *
 * @param {object} group The group with the shape.
 * @param {object} viewController The associated view controller.
 */
dwv.tool.draw.EllipseFactory.prototype.updateQuantification = function (
  group, viewController) {
  dwv.tool.draw.updateEllipseQuantification(group, viewController);
};

/**
 * Update the quantification of an Ellipse (as a static
 *   function to be used in update).
 *
 * @param {object} group The group with the shape.
 * @param {object} viewController The associated view controller.
 */
dwv.tool.draw.updateEllipseQuantification = function (
  group, viewController) {
  // associated shape
  var kellipse = group.getChildren(function (node) {
    return node.name() === 'shape';
  })[0];
  // associated label
  var klabel = group.getChildren(function (node) {
    return node.name() === 'label';
  })[0];

  // positions: add possible group offset
  var centerPoint = new dwv.math.Point2D(
    group.x() + kellipse.x(),
    group.y() + kellipse.y()
  );
  // circle
  var ellipse = new dwv.math.Ellipse(
    centerPoint, kellipse.radius().x, kellipse.radius().y);

  // update text
  var ktext = klabel.getText();
  var quantification = ellipse.quantify(
    viewController,
    dwv.utils.getFlags(ktext.meta.textExpr));
  ktext.setText(dwv.utils.replaceFlags(ktext.meta.textExpr, quantification));
  // update meta
  ktext.meta.quantification = quantification;
};

/**
 * Get the debug shadow.
 *
 * @param {dwv.math.Ellipse} ellipse The ellipse to shadow.
 * @param {object} group The associated group.
 * @returns {object} The shadow konva group.
 */
dwv.tool.draw.getShadowEllipse = function (ellipse, group) {
  // possible group offset
  var offsetX = 0;
  var offsetY = 0;
  if (typeof group !== 'undefined') {
    offsetX = group.x();
    offsetY = group.y();
  }
  var kshadow = new Konva.Group();
  kshadow.name('shadow');
  var regions = ellipse.getRound();
  for (var i = 0; i < regions.length; ++i) {
    var region = regions[i];
    var minX = region[0][0];
    var minY = region[0][1];
    var maxX = region[1][0];
    var pixelLine = new Konva.Rect({
      x: minX - offsetX,
      y: minY - offsetY,
      width: maxX - minX,
      height: 1,
      fill: 'grey',
      strokeWidth: 0,
      strokeScaleEnabled: false,
      opacity: 0.3,
      name: 'shadow-element'
    });
    kshadow.add(pixelLine);
  }
  return kshadow;
};

// namespaces
var dwv = dwv || {};
dwv.tool = dwv.tool || {};
/** @namespace */
dwv.tool.filter = dwv.tool.filter || {};

/**
 * Filter tool.
 *
 * @class
 * @param {dwv.App} app The associated app.
 */
dwv.tool.Filter = function (app) {
  /**
   * Filter list
   *
   * @type {object}
   */
  this.filterList = null;
  /**
   * Selected filter.
   *
   * @type {object}
   */
  this.selectedFilter = 0;
  /**
   * Listener handler.
   *
   * @type {object}
   * @private
   */
  var listenerHandler = new dwv.utils.ListenerHandler();

  /**
   * Activate the tool.
   *
   * @param {boolean} bool Flag to activate or not.
   */
  this.activate = function (bool) {
    // setup event listening
    for (var key in this.filterList) {
      if (bool) {
        this.filterList[key].addEventListener('filterrun', fireEvent);
        this.filterList[key].addEventListener('filter-undo', fireEvent);
      } else {
        this.filterList[key].removeEventListener('filterrun', fireEvent);
        this.filterList[key].removeEventListener('filter-undo', fireEvent);
      }
    }
  };

  /**
   * Set the tool options.
   *
   * @param {object} options The list of filter names amd classes.
   */
  this.setOptions = function (options) {
    this.filterList = {};
    // try to instanciate filters from the options
    for (var key in options) {
      this.filterList[key] = new options[key](app);
    }
  };

  /**
   * Get the type of tool options: here 'instance' since the filter
   * list contains instances of each possible filter.
   *
   * @returns {string} The type.
   */
  this.getOptionsType = function () {
    return 'instance';
  };

  /**
   * Initialise the filter. Called once the image is loaded.
   */
  this.init = function () {
    // setup event listening
    for (var key in this.filterList) {
      this.filterList[key].init();
    }
  };

  /**
   * Handle keydown event.
   *
   * @param {object} event The keydown event.
   */
  this.keydown = function (event) {
    event.context = 'dwv.tool.Filter';
    app.onKeydown(event);
  };

  /**
   * Get the list of event names that this tool can fire.
   *
   * @returns {Array} The list of event names.
   */
  this.getEventNames = function () {
    return ['filterrun', 'filterundo'];
  };

  /**
   * Add an event listener to this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type, will be called with the fired event.
   */
  this.addEventListener = function (type, callback) {
    listenerHandler.add(type, callback);
  };
  /**
   * Remove an event listener from this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type.
   */
  this.removeEventListener = function (type, callback) {
    listenerHandler.remove(type, callback);
  };
  /**
   * Fire an event: call all associated listeners with the input event object.
   *
   * @param {object} event The event to fire.
   * @private
   */
  function fireEvent(event) {
    listenerHandler.fireEvent(event);
  }

}; // class dwv.tool.Filter

/**
 * Get the selected filter.
 *
 * @returns {object} The selected filter.
 */
dwv.tool.Filter.prototype.getSelectedFilter = function () {
  return this.selectedFilter;
};

/**
 * Set the tool live features: filter name.
 *
 * @param {object} features The list of features.
 */
dwv.tool.Filter.prototype.setFeatures = function (features) {
  if (typeof features.filterName !== 'undefined') {
    // check if we have it
    if (!this.hasFilter(features.filterName)) {
      throw new Error('Unknown filter: \'' + features.filterName + '\'');
    }
    // de-activate last selected
    if (this.selectedFilter) {
      this.selectedFilter.activate(false);
    }
    // enable new one
    this.selectedFilter = this.filterList[features.filterName];
    // activate the selected filter
    this.selectedFilter.activate(true);
  }
  if (typeof features.run !== 'undefined' && features.run) {
    var args = {};
    if (typeof features.runArgs !== 'undefined') {
      args = features.runArgs;
    }
    this.getSelectedFilter().run(args);
  }
};

/**
 * Get the list of filters.
 *
 * @returns {Array} The list of filter objects.
 */
dwv.tool.Filter.prototype.getFilterList = function () {
  return this.filterList;
};

/**
 * Check if a filter is in the filter list.
 *
 * @param {string} name The name to check.
 * @returns {string} The filter list element for the given name.
 */
dwv.tool.Filter.prototype.hasFilter = function (name) {
  return this.filterList[name];
};

/**
 * Threshold filter tool.
 *
 * @class
 * @param {dwv.App} app The associated application.
 */
dwv.tool.filter.Threshold = function (app) {
  /**
   * Associated filter.
   *
   * @type {object}
   * @private
   */
  var filter = new dwv.image.filter.Threshold();
  /**
   * Flag to know wether to reset the image or not.
   *
   * @type {boolean}
   * @private
   */
  var resetImage = true;
  /**
   * Listener handler.
   *
   * @type {object}
   * @private
   */
  var listenerHandler = new dwv.utils.ListenerHandler();

  /**
   * Activate the filter.
   *
   * @param {boolean} bool Flag to activate or not.
   */
  this.activate = function (bool) {
    // reset the image when the tool is activated
    if (bool) {
      resetImage = true;
    }
  };

  /**
   * Initialise the filter. Called once the image is loaded.
   */
  this.init = function () {
    // does nothing
  };

  /**
   * Run the filter.
   *
   * @param {*} args The filter arguments.
   */
  this.run = function (args) {
    filter.setMin(args.min);
    filter.setMax(args.max);
    // reset the image if asked
    if (resetImage) {
      filter.setOriginalImage(app.getLastImage());
      resetImage = false;
    }
    var command = new dwv.tool.RunFilterCommand(filter, app);
    command.onExecute = fireEvent;
    command.onUndo = fireEvent;
    command.execute();
    // save command in undo stack
    app.addToUndoStack(command);
  };

  /**
   * Add an event listener to this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *  event type, will be called with the fired event.
   */
  this.addEventListener = function (type, callback) {
    listenerHandler.add(type, callback);
  };
  /**
   * Remove an event listener from this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type.
   */
  this.removeEventListener = function (type, callback) {
    listenerHandler.remove(type, callback);
  };
  /**
   * Fire an event: call all associated listeners with the input event object.
   *
   * @param {object} event The event to fire.
   * @private
   */
  function fireEvent(event) {
    listenerHandler.fireEvent(event);
  }

}; // class dwv.tool.filter.Threshold


/**
 * Sharpen filter tool.
 *
 * @class
 * @param {dwv.App} app The associated application.
 */
dwv.tool.filter.Sharpen = function (app) {
  /**
   * Listener handler.
   *
   * @type {object}
   * @private
   */
  var listenerHandler = new dwv.utils.ListenerHandler();

  /**
   * Activate the filter.
   *
   * @param {boolean} _bool Flag to activate or not.
   */
  this.activate = function (_bool) {
    // does nothing
  };

  /**
   * Initialise the filter. Called once the image is loaded.
   */
  this.init = function () {
    // does nothing
  };

  /**
   * Run the filter.
   *
   * @param {*} _args The filter arguments.
   */
  this.run = function (_args) {
    var filter = new dwv.image.filter.Sharpen();
    filter.setOriginalImage(app.getLastImage());
    var command = new dwv.tool.RunFilterCommand(filter, app);
    command.onExecute = fireEvent;
    command.onUndo = fireEvent;
    command.execute();
    // save command in undo stack
    app.addToUndoStack(command);
  };

  /**
   * Add an event listener to this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *    event type, will be called with the fired event.
   */
  this.addEventListener = function (type, callback) {
    listenerHandler.add(type, callback);
  };
  /**
   * Remove an event listener from this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type.
   */
  this.removeEventListener = function (type, callback) {
    listenerHandler.remove(type, callback);
  };
  /**
   * Fire an event: call all associated listeners with the input event object.
   *
   * @param {object} event The event to fire.
   * @private
   */
  function fireEvent(event) {
    listenerHandler.fireEvent(event);
  }

}; // dwv.tool.filter.Sharpen

/**
 * Sobel filter tool.
 *
 * @class
 * @param {dwv.App} app The associated application.
 */
dwv.tool.filter.Sobel = function (app) {
  /**
   * Listener handler.
   *
   * @type {object}
   * @private
   */
  var listenerHandler = new dwv.utils.ListenerHandler();

  /**
   * Activate the filter.
   *
   * @param {boolean} _bool Flag to activate or not.
   */
  this.activate = function (_bool) {
    // does nothing
  };

  /**
   * Initialise the filter. Called once the image is loaded.
   */
  this.init = function () {
    // does nothing
  };

  /**
   * Run the filter.
   *
   * @param {*} _args The filter arguments.
   */
  dwv.tool.filter.Sobel.prototype.run = function (_args) {
    var filter = new dwv.image.filter.Sobel();
    filter.setOriginalImage(app.getLastImage());
    var command = new dwv.tool.RunFilterCommand(filter, app);
    command.onExecute = fireEvent;
    command.onUndo = fireEvent;
    command.execute();
    // save command in undo stack
    app.addToUndoStack(command);
  };

  /**
   * Add an event listener to this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *  event type, will be called with the fired event.
   */
  this.addEventListener = function (type, callback) {
    listenerHandler.add(type, callback);
  };
  /**
   * Remove an event listener from this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type.
   */
  this.removeEventListener = function (type, callback) {
    listenerHandler.remove(type, callback);
  };
  /**
   * Fire an event: call all associated listeners with the input event object.
   *
   * @param {object} event The event to fire.
   * @private
   */
  function fireEvent(event) {
    listenerHandler.fireEvent(event);
  }

}; // class dwv.tool.filter.Sobel

/**
 * Run filter command.
 *
 * @class
 * @param {object} filter The filter to run.
 * @param {dwv.App} app The associated application.
 */
dwv.tool.RunFilterCommand = function (filter, app) {

  /**
   * Get the command name.
   *
   * @returns {string} The command name.
   */
  this.getName = function () {
    return 'Filter-' + filter.getName();
  };

  /**
   * Execute the command.
   *
   * @fires dwv.tool.RunFilterCommand#filterrun
   */
  this.execute = function () {
    // run filter and set app image
    app.setLastImage(filter.update());
    // update display
    app.render(0); //todo: fix
    /**
     * Filter run event.
     *
     * @event dwv.tool.RunFilterCommand#filterrun
     * @type {object}
     * @property {string} type The event type: filterrun.
     * @property {number} id The id of the run command.
     */
    var event = {
      type: 'filterrun',
      id: this.getName()
    };
    // callback
    this.onExecute(event);
  };

  /**
   * Undo the command.
   *
   * @fires dwv.tool.RunFilterCommand#filterundo
   */
  this.undo = function () {
    // reset the image
    app.setLastImage(filter.getOriginalImage());
    // update display
    app.render(0); //todo: fix
    /**
     * Filter undo event.
     *
     * @event dwv.tool.RunFilterCommand#filterundo
     * @type {object}
     * @property {string} type The event type: filterundo.
     * @property {number} id The id of the undone run command.
     */
    var event = {
      type: 'filterundo',
      id: this.getName()
    }; // callback
    this.onUndo(event);
  };

}; // RunFilterCommand class

/**
 * Handle an execute event.
 *
 * @param {object} _event The execute event with type and id.
 */
dwv.tool.RunFilterCommand.prototype.onExecute = function (_event) {
  // default does nothing.
};
/**
 * Handle an undo event.
 *
 * @param {object} _event The undo event with type and id.
 */
dwv.tool.RunFilterCommand.prototype.onUndo = function (_event) {
  // default does nothing.
};

// namespaces
var dwv = dwv || {};
dwv.tool = dwv.tool || {};
/**
 * The magic wand namespace.
 *
 * @external MagicWand
 * @see https://github.com/Tamersoul/magic-wand-js
 */
var MagicWand = MagicWand || {};

/**
 * Floodfill painting tool.
 *
 * @class
 * @param {dwv.App} app The associated application.
 */
dwv.tool.Floodfill = function (app) {
  /**
   * Original variables from external library. Used as in the lib example.
   *
   * @private
   * @type {number}
   */
  var blurRadius = 5;
  /**
   * Original variables from external library. Used as in the lib example.
   *
   * @private
   * @type {number}
   */
  var simplifyTolerant = 0;
  /**
   * Original variables from external library. Used as in the lib example.
   *
   * @private
   * @type {number}
   */
  var simplifyCount = 2000;
  /**
   * Canvas info
   *
   * @private
   * @type {object}
   */
  var imageInfo = null;
  /**
   * Object created by MagicWand lib containing border points
   *
   * @private
   * @type {object}
   */
  var mask = null;
  /**
   * threshold default tolerance of the tool border
   *
   * @private
   * @type {number}
   */
  var initialthreshold = 10;
  /**
   * threshold tolerance of the tool border
   *
   * @private
   * @type {number}
   */
  var currentthreshold = null;
  /**
   * Closure to self: to be used by event handlers.
   *
   * @private
   * @type {dwv.tool.Floodfill}
   */
  var self = this;
  /**
   * Interaction start flag.
   *
   * @type {boolean}
   */
  this.started = false;
  /**
   * Draw command.
   *
   * @private
   * @type {object}
   */
  var command = null;
  /**
   * Current shape group.
   *
   * @private
   * @type {object}
   */
  var shapeGroup = null;
  /**
   * Coordinates of the fist mousedown event.
   *
   * @private
   * @type {object}
   */
  var initialpoint;
  /**
   * Floodfill border.
   *
   * @private
   * @type {object}
   */
  var border = null;
  /**
   * List of parent points.
   *
   * @private
   * @type {Array}
   */
  var parentPoints = [];
  /**
   * Assistant variable to paint border on all slices.
   *
   * @private
   * @type {boolean}
   */
  var extender = false;
  /**
   * Timeout for painting on mousemove.
   *
   * @private
   */
  var painterTimeout;
  /**
   * Drawing style.
   *
   * @type {dwv.gui.Style}
   */
  this.style = new dwv.gui.Style();

  /**
   * Listener handler.
   *
   * @type {object}
   * @private
   */
  var listenerHandler = new dwv.utils.ListenerHandler();

  /**
   * Set extend option for painting border on all slices.
   *
   * @param {boolean} bool The option to set
   */
  this.setExtend = function (bool) {
    extender = bool;
  };

  /**
   * Get extend option for painting border on all slices.
   *
   * @returns {boolean} The actual value of of the variable to use Floodfill
   *   on museup.
   */
  this.getExtend = function () {
    return extender;
  };

  /**
   * Get (x, y) coordinates referenced to the canvas
   *
   * @param {object} event The original event.
   * @returns {object} The coordinates as a {x,y}.
   * @private
   */
  var getCoord = function (event) {
    var layerDetails = dwv.gui.getLayerDetailsFromEvent(event);
    var layerGroup = app.getLayerGroupByDivId(layerDetails.groupDivId);
    var viewLayer = layerGroup.getActiveViewLayer();
    var index = viewLayer.displayToPlaneIndex(event._x, event._y);
    return {
      x: index.get(0),
      y: index.get(1)
    };
  };

  /**
   * Calculate border.
   *
   * @private
   * @param {object} points The input points.
   * @param {number} threshold The threshold of the floodfill.
   * @param {boolean} simple Return first points or a list.
   * @returns {Array} The parent points.
   */
  var calcBorder = function (points, threshold, simple) {

    parentPoints = [];
    var image = {
      data: imageInfo.data,
      width: imageInfo.width,
      height: imageInfo.height,
      bytes: 4
    };

    mask = MagicWand.floodFill(image, points.x, points.y, threshold);
    mask = MagicWand.gaussBlurOnlyBorder(mask, blurRadius);

    var cs = MagicWand.traceContours(mask);
    cs = MagicWand.simplifyContours(cs, simplifyTolerant, simplifyCount);

    if (cs.length > 0 && cs[0].points[0].x) {
      if (simple) {
        return cs[0].points;
      }
      for (var j = 0, icsl = cs[0].points.length; j < icsl; j++) {
        parentPoints.push(new dwv.math.Point2D(
          cs[0].points[j].x,
          cs[0].points[j].y
        ));
      }
      return parentPoints;
    } else {
      return false;
    }
  };

  /**
   * Paint Floodfill.
   *
   * @private
   * @param {object} point The start point.
   * @param {number} threshold The border threshold.
   * @param {object} layerGroup The origin layer group.
   * @returns {boolean} False if no border.
   */
  var paintBorder = function (point, threshold, layerGroup) {
    // Calculate the border
    border = calcBorder(point, threshold);
    // Paint the border
    if (border) {
      var factory = new dwv.tool.draw.RoiFactory();
      shapeGroup = factory.create(border, self.style);
      shapeGroup.id(dwv.math.guid());

      var drawLayer = layerGroup.getActiveDrawLayer();
      var drawController = drawLayer.getDrawController();

      // get the position group
      var posGroup = drawController.getCurrentPosGroup();
      // add shape group to position group
      posGroup.add(shapeGroup);

      // draw shape command
      command = new dwv.tool.DrawGroupCommand(shapeGroup, 'floodfill',
        drawLayer.getKonvaLayer());
      command.onExecute = fireEvent;
      command.onUndo = fireEvent;
      // // draw
      command.execute();
      // save it in undo stack
      app.addToUndoStack(command);

      return true;
    } else {
      return false;
    }
  };

  /**
   * Create Floodfill in all the prev and next slices while border is found
   *
   * @param {number} ini The first slice to extend to.
   * @param {number} end The last slice to extend to.
   * @param {object} layerGroup The origin layer group.
   */
  this.extend = function (ini, end, layerGroup) {
    //avoid errors
    if (!initialpoint) {
      throw '\'initialpoint\' not found. User must click before use extend!';
    }
    // remove previous draw
    if (shapeGroup) {
      shapeGroup.destroy();
    }

    var viewController =
      layerGroup.getActiveViewLayer().getViewController();

    var pos = viewController.getCurrentIndex();
    var imageSize = viewController.getImageSize();
    var threshold = currentthreshold || initialthreshold;

    // Iterate over the next images and paint border on each slice.
    for (var i = pos.get(2),
      len = end
        ? end : imageSize.get(2);
      i < len; i++) {
      if (!paintBorder(initialpoint, threshold, layerGroup)) {
        break;
      }
      viewController.incrementIndex(2);
    }
    viewController.setCurrentPosition(pos);

    // Iterate over the prev images and paint border on each slice.
    for (var j = pos.get(2), jl = ini ? ini : 0; j > jl; j--) {
      if (!paintBorder(initialpoint, threshold, layerGroup)) {
        break;
      }
      viewController.decrementIndex(2);
    }
    viewController.setCurrentPosition(pos);
  };

  /**
   * Modify tolerance threshold and redraw ROI.
   *
   * @param {number} modifyThreshold The new threshold.
   * @param {shape} shape The shape to update.
   */
  this.modifyThreshold = function (modifyThreshold, shape) {

    if (!shape && shapeGroup) {
      shape = shapeGroup.getChildren(function (node) {
        return node.name() === 'shape';
      })[0];
    } else {
      throw 'No shape found';
    }

    clearTimeout(painterTimeout);
    painterTimeout = setTimeout(function () {
      border = calcBorder(initialpoint, modifyThreshold, true);
      if (!border) {
        return false;
      }
      var arr = [];
      for (var i = 0, bl = border.length; i < bl; ++i) {
        arr.push(border[i].x);
        arr.push(border[i].y);
      }
      shape.setPoints(arr);
      var shapeLayer = shape.getLayer();
      shapeLayer.draw();
      self.onThresholdChange(modifyThreshold);
    }, 100);
  };

  /**
   * Event fired when threshold change
   *
   * @param {number} _value Current threshold
   */
  this.onThresholdChange = function (_value) {
    // Defaults do nothing
  };

  /**
   * Handle mouse down event.
   *
   * @param {object} event The mouse down event.
   */
  this.mousedown = function (event) {
    var layerDetails = dwv.gui.getLayerDetailsFromEvent(event);
    var layerGroup = app.getLayerGroupByDivId(layerDetails.groupDivId);
    var viewLayer = layerGroup.getActiveViewLayer();
    var drawLayer = layerGroup.getActiveDrawLayer();

    imageInfo = viewLayer.getImageData();
    if (!imageInfo) {
      dwv.logger.error('No image found');
      return;
    }

    // update zoom scale
    self.style.setZoomScale(
      drawLayer.getKonvaLayer().getAbsoluteScale());

    self.started = true;
    initialpoint = getCoord(event);
    paintBorder(initialpoint, initialthreshold, layerGroup);
    self.onThresholdChange(initialthreshold);
  };

  /**
   * Handle mouse move event.
   *
   * @param {object} event The mouse move event.
   */
  this.mousemove = function (event) {
    if (!self.started) {
      return;
    }
    var movedpoint = getCoord(event);
    currentthreshold = Math.round(Math.sqrt(
      Math.pow((initialpoint.x - movedpoint.x), 2) +
      Math.pow((initialpoint.y - movedpoint.y), 2)) / 2);
    currentthreshold = currentthreshold < initialthreshold
      ? initialthreshold : currentthreshold - initialthreshold;
    self.modifyThreshold(currentthreshold);
  };

  /**
   * Handle mouse up event.
   *
   * @param {object} _event The mouse up event.
   */
  this.mouseup = function (_event) {
    self.started = false;
    if (extender) {
      var layerDetails = dwv.gui.getLayerDetailsFromEvent(event);
      var layerGroup = app.getLayerGroupByDivId(layerDetails.groupDivId);
      self.extend(layerGroup);
    }
  };

  /**
   * Handle mouse out event.
   *
   * @param {object} event The mouse out event.
   */
  this.mouseout = function (event) {
    self.mouseup(event);
  };

  /**
   * Handle touch start event.
   *
   * @param {object} event The touch start event.
   */
  this.touchstart = function (event) {
    // treat as mouse down
    self.mousedown(event);
  };

  /**
   * Handle touch move event.
   *
   * @param {object} event The touch move event.
   */
  this.touchmove = function (event) {
    // treat as mouse move
    self.mousemove(event);
  };

  /**
   * Handle touch end event.
   *
   * @param {object} event The touch end event.
   */
  this.touchend = function (event) {
    // treat as mouse up
    self.mouseup(event);
  };

  /**
   * Handle key down event.
   *
   * @param {object} event The key down event.
   */
  this.keydown = function (event) {
    event.context = 'dwv.tool.Floodfill';
    app.onKeydown(event);
  };

  /**
   * Activate the tool.
   *
   * @param {boolean} bool The flag to activate or not.
   */
  this.activate = function (bool) {
    if (bool) {
      // init with the app window scale
      this.style.setBaseScale(app.getBaseScale());
      // set the default to the first in the list
      this.setFeatures({shapeColour: this.style.getLineColour()});
    }
  };

  /**
   * Initialise the tool.
   */
  this.init = function () {
    // does nothing
  };

  /**
   * Get the list of event names that this tool can fire.
   *
   * @returns {Array} The list of event names.
   */
  this.getEventNames = function () {
    return ['drawcreate', 'drawchange', 'drawmove', 'drawdelete'];
  };

  /**
   * Add an event listener to this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type, will be called with the fired event.
   */
  this.addEventListener = function (type, callback) {
    listenerHandler.add(type, callback);
  };
  /**
   * Remove an event listener from this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type.
   */
  this.removeEventListener = function (type, callback) {
    listenerHandler.remove(type, callback);
  };
  /**
   * Fire an event: call all associated listeners with the input event object.
   *
   * @param {object} event The event to fire.
   * @private
   */
  function fireEvent(event) {
    listenerHandler.fireEvent(event);
  }

}; // Floodfill class

/**
 * Set the tool live features: shape colour.
 *
 * @param {object} features The list of features.
 */
dwv.tool.Floodfill.prototype.setFeatures = function (features) {
  if (typeof features.shapeColour !== 'undefined') {
    this.style.setLineColour(features.shapeColour);
  }
};

// namespaces
var dwv = dwv || {};
dwv.tool = dwv.tool || {};
dwv.tool.draw = dwv.tool.draw || {};
/**
 * The Konva namespace.
 *
 * @external Konva
 * @see https://konvajs.org/
 */
var Konva = Konva || {};

/**
 * Default draw label text.
 */
dwv.tool.draw.defaultFreeHandLabelText = '';

/**
 * FreeHand factory.
 *
 * @class
 */
dwv.tool.draw.FreeHandFactory = function () {
  /**
   * Get the name of the shape group.
   *
   * @returns {string} The name.
   */
  this.getGroupName = function () {
    return 'freeHand-group';
  };
  /**
   * Get the number of points needed to build the shape.
   *
   * @returns {number|undefined} The number of points.
   */
  this.getNPoints = function () {
    // undefined to end with double click
    return undefined;
  };
  /**
   * Get the timeout between point storage.
   *
   * @returns {number} The timeout in milliseconds.
   */
  this.getTimeout = function () {
    return 25;
  };
};

/**
 * Is the input group a group of this factory?
 *
 * @param {object} group The group to test.
 * @returns {boolean} True if the group is from this fcatory.
 */
dwv.tool.draw.FreeHandFactory.prototype.isFactoryGroup = function (group) {
  return this.getGroupName() === group.name();
};

/**
 * Create a roi shape to be displayed.
 *
 * @param {Array} points The points from which to extract the line.
 * @param {object} style The drawing style.
 * @param {object} _viewController The associated view controller.
 * @returns {object} The Konva group.
 */
dwv.tool.draw.FreeHandFactory.prototype.create = function (
  points, style, _viewController) {
  // points stored the Konvajs way
  var arr = [];
  for (var i = 0; i < points.length; ++i) {
    arr.push(points[i].getX());
    arr.push(points[i].getY());
  }
  // draw shape
  var kshape = new Konva.Line({
    points: arr,
    stroke: style.getLineColour(),
    strokeWidth: style.getStrokeWidth(),
    strokeScaleEnabled: false,
    name: 'shape',
    tension: 0.5
  });

  // text
  var ktext = new Konva.Text({
    fontSize: style.getFontSize(),
    fontFamily: style.getFontFamily(),
    fill: style.getLineColour(),
    name: 'text'
  });
  var textExpr = '';
  if (typeof dwv.tool.draw.freeHandLabelText !== 'undefined') {
    textExpr = dwv.tool.draw.freeHandLabelText;
  } else {
    textExpr = dwv.tool.draw.defaultFreeHandLabelText;
  }
  ktext.setText(textExpr);
  // meta data
  ktext.meta = {
    textExpr: textExpr,
    quantification: {}
  };

  // label
  var klabel = new Konva.Label({
    x: points[0].getX(),
    y: points[0].getY() + style.scale(10),
    scale: style.applyZoomScale(1),
    visible: textExpr.length !== 0,
    name: 'label'
  });
  klabel.add(ktext);
  klabel.add(new Konva.Tag({
    fill: style.getLineColour(),
    opacity: style.getTagOpacity()
  }));

  // return group
  var group = new Konva.Group();
  group.name(this.getGroupName());
  group.add(klabel);
  group.add(kshape);
  group.visible(true); // dont inherit
  return group;
};

/**
 * Get anchors to update a free hand shape.
 *
 * @param {object} shape The associated shape.
 * @param {object} style The application style.
 * @returns {Array} A list of anchors.
 */
dwv.tool.draw.FreeHandFactory.prototype.getAnchors = function (shape, style) {
  var points = shape.points();

  var anchors = [];
  for (var i = 0; i < points.length; i = i + 2) {
    var px = points[i] + shape.x();
    var py = points[i + 1] + shape.y();
    var name = i;
    anchors.push(dwv.tool.draw.getDefaultAnchor(
      px, py, name, style
    ));
  }
  return anchors;
};

/**
 * Update a FreeHand shape.
 * Warning: do NOT use 'this' here, this method is passed
 *   as is to the change command.
 *
 * @param {object} anchor The active anchor.
 * @param {object} style The app style.
 * @param {object} _viewController The associated view controller.
 */
dwv.tool.draw.FreeHandFactory.prototype.update = function (
  anchor, style, _viewController) {
  // parent group
  var group = anchor.getParent();
  // associated shape
  var kline = group.getChildren(function (node) {
    return node.name() === 'shape';
  })[0];
    // associated label
  var klabel = group.getChildren(function (node) {
    return node.name() === 'label';
  })[0];

  // update self
  var point = group.getChildren(function (node) {
    return node.id() === anchor.id();
  })[0];
  point.x(anchor.x());
  point.y(anchor.y());
  // update the roi point and compensate for possible drag
  // (the anchor id is the index of the point in the list)
  var points = kline.points();
  points[anchor.id()] = anchor.x() - kline.x();
  points[anchor.id() + 1] = anchor.y() - kline.y();
  // concat to make Konva think it is a new array
  kline.points(points.concat());

  // update text
  var ktext = klabel.getText();
  ktext.setText(ktext.meta.textExpr);
  // update position
  var textPos = {
    x: points[0] + kline.x(),
    y: points[1] + kline.y() + style.scale(10)
  };
  klabel.position(textPos);
};

// namespaces
var dwv = dwv || {};
dwv.tool = dwv.tool || {};

/**
 * Livewire painting tool.
 *
 * @class
 * @param {dwv.App} app The associated application.
 */
dwv.tool.Livewire = function (app) {
  /**
   * Closure to self: to be used by event handlers.
   *
   * @private
   * @type {dwv.tool.Livewire}
   */
  var self = this;
  /**
   * Interaction start flag.
   *
   * @type {boolean}
   */
  this.started = false;

  /**
   * Draw command.
   *
   * @private
   * @type {object}
   */
  var command = null;
  /**
   * Current shape group.
   *
   * @private
   * @type {object}
   */
  var shapeGroup = null;
  /**
   * Drawing style.
   *
   * @type {dwv.gui.Style}
   */
  this.style = new dwv.gui.Style();

  /**
   * Path storage. Paths are stored in reverse order.
   *
   * @private
   * @type {dwv.math.Path}
   */
  var path = new dwv.math.Path();
  /**
   * Current path storage. Paths are stored in reverse order.
   *
   * @private
   * @type {dwv.math.Path}
   */
  var currentPath = new dwv.math.Path();
  /**
   * List of parent points.
   *
   * @private
   * @type {Array}
   */
  var parentPoints = [];
  /**
   * Tolerance.
   *
   * @private
   * @type {number}
   */
  var tolerance = 5;

  /**
   * Listener handler.
   *
   * @type {object}
   * @private
   */
  var listenerHandler = new dwv.utils.ListenerHandler();

  /**
   * Clear the parent points list.
   *
   * @param {object} imageSize The image size.
   * @private
   */
  function clearParentPoints(imageSize) {
    var nrows = imageSize.get(1);
    for (var i = 0; i < nrows; ++i) {
      parentPoints[i] = [];
    }
  }

  /**
   * Clear the stored paths.
   *
   * @private
   */
  function clearPaths() {
    path = new dwv.math.Path();
    currentPath = new dwv.math.Path();
  }

  /**
   * Scissor representation.
   *
   * @private
   * @type {dwv.math.Scissors}
   */
  var scissors = new dwv.math.Scissors();

  /**
   * Finish a livewire (roi) shape.
   */
  function finishShape() {
    // fire creation event (was not propagated during draw)
    fireEvent({
      type: 'drawcreate',
      id: shapeGroup.id()
    });
    // listen
    command.onExecute = fireEvent;
    command.onUndo = fireEvent;
    // save command in undo stack
    app.addToUndoStack(command);
    // set flag
    self.started = false;
  }

  /**
   * Handle mouse down event.
   *
   * @param {object} event The mouse down event.
   */
  this.mousedown = function (event) {
    var layerDetails = dwv.gui.getLayerDetailsFromEvent(event);
    var layerGroup = app.getLayerGroupByDivId(layerDetails.groupDivId);
    var viewLayer = layerGroup.getActiveViewLayer();
    var imageSize = viewLayer.getViewController().getImageSize();
    var index = viewLayer.displayToPlaneIndex(event._x, event._y);

    // first time
    if (!self.started) {
      self.started = true;
      self.x0 = index.get(0);
      self.y0 = index.get(1);
      // clear vars
      clearPaths();
      clearParentPoints(imageSize);
      shapeGroup = null;
      // update zoom scale
      var drawLayer = layerGroup.getActiveDrawLayer();
      self.style.setZoomScale(
        drawLayer.getKonvaLayer().getAbsoluteScale());
      // do the training from the first point
      var p = {x: index.get(0), y: index.get(1)};
      scissors.doTraining(p);
      // add the initial point to the path
      var p0 = new dwv.math.Point2D(index.get(0), index.get(1));
      path.addPoint(p0);
      path.addControlPoint(p0);
    } else {
      // final point: at 'tolerance' of the initial point
      if ((Math.abs(index.get(0) - self.x0) < tolerance) &&
        (Math.abs(index.get(1) - self.y0) < tolerance)) {
        // finish
        finishShape();
      } else {
        // anchor point
        path = currentPath;
        clearParentPoints(imageSize);
        var pn = {x: index.get(0), y: index.get(1)};
        scissors.doTraining(pn);
        path.addControlPoint(currentPath.getPoint(0));
      }
    }
  };

  /**
   * Handle mouse move event.
   *
   * @param {object} event The mouse move event.
   */
  this.mousemove = function (event) {
    if (!self.started) {
      return;
    }
    var layerDetails = dwv.gui.getLayerDetailsFromEvent(event);
    var layerGroup = app.getLayerGroupByDivId(layerDetails.groupDivId);
    var viewLayer = layerGroup.getActiveViewLayer();
    var index = viewLayer.displayToPlaneIndex(event._x, event._y);

    // set the point to find the path to
    var p = {x: index.get(0), y: index.get(1)};
    scissors.setPoint(p);
    // do the work
    var results = 0;
    var stop = false;
    while (!parentPoints[p.y][p.x] && !stop) {
      results = scissors.doWork();

      if (results.length === 0) {
        stop = true;
      } else {
        // fill parents
        for (var i = 0; i < results.length - 1; i += 2) {
          var _p = results[i];
          var _q = results[i + 1];
          parentPoints[_p.y][_p.x] = _q;
        }
      }
    }

    // get the path
    currentPath = new dwv.math.Path();
    stop = false;
    while (p && !stop) {
      currentPath.addPoint(new dwv.math.Point2D(p.x, p.y));
      if (!parentPoints[p.y]) {
        stop = true;
      } else {
        if (!parentPoints[p.y][p.x]) {
          stop = true;
        } else {
          p = parentPoints[p.y][p.x];
        }
      }
    }
    currentPath.appenPath(path);

    // remove previous draw
    if (shapeGroup) {
      shapeGroup.destroy();
    }
    // create shape
    var factory = new dwv.tool.draw.RoiFactory();
    shapeGroup = factory.create(currentPath.pointArray, self.style);
    shapeGroup.id(dwv.math.guid());

    var drawLayer = layerGroup.getActiveDrawLayer();
    var drawController = drawLayer.getDrawController();

    // get the position group
    var posGroup = drawController.getCurrentPosGroup();
    // add shape group to position group
    posGroup.add(shapeGroup);

    // draw shape command
    command = new dwv.tool.DrawGroupCommand(shapeGroup, 'livewire',
      drawLayer.getKonvaLayer());
    // draw
    command.execute();
  };

  /**
   * Handle mouse up event.
   *
   * @param {object} _event The mouse up event.
   */
  this.mouseup = function (_event) {
    // nothing to do
  };

  /**
   * Handle mouse out event.
   *
   * @param {object} event The mouse out event.
   */
  this.mouseout = function (event) {
    // treat as mouse up
    self.mouseup(event);
  };

  /**
   * Handle double click event.
   *
   * @param {object} _event The double click event.
   */
  this.dblclick = function (_event) {
    finishShape();
  };

  /**
   * Handle touch start event.
   *
   * @param {object} event The touch start event.
   */
  this.touchstart = function (event) {
    // treat as mouse down
    self.mousedown(event);
  };

  /**
   * Handle touch move event.
   *
   * @param {object} event The touch move event.
   */
  this.touchmove = function (event) {
    // treat as mouse move
    self.mousemove(event);
  };

  /**
   * Handle touch end event.
   *
   * @param {object} event The touch end event.
   */
  this.touchend = function (event) {
    // treat as mouse up
    self.mouseup(event);
  };

  /**
   * Handle key down event.
   *
   * @param {object} event The key down event.
   */
  this.keydown = function (event) {
    event.context = 'dwv.tool.Livewire';
    app.onKeydown(event);
  };

  /**
   * Activate the tool.
   *
   * @param {boolean} bool The flag to activate or not.
   */
  this.activate = function (bool) {
    // start scissors if displayed
    if (bool) {
      var layerGroup = app.getActiveLayerGroup();
      var viewLayer = layerGroup.getActiveViewLayer();

      //scissors = new dwv.math.Scissors();
      var imageSize = viewLayer.getViewController().getImageSize();
      scissors.setDimensions(
        imageSize.get(0),
        imageSize.get(1));
      scissors.setData(viewLayer.getImageData().data);

      // init with the app window scale
      this.style.setBaseScale(app.getBaseScale());
      // set the default to the first in the list
      this.setFeatures({shapeColour: this.style.getLineColour()});
    }
  };

  /**
   * Initialise the tool.
   */
  this.init = function () {
    // does nothing
  };

  /**
   * Get the list of event names that this tool can fire.
   *
   * @returns {Array} The list of event names.
   */
  this.getEventNames = function () {
    return ['drawcreate', 'drawchange', 'drawmove', 'drawdelete'];
  };

  /**
   * Add an event listener to this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *    event type, will be called with the fired event.
   */
  this.addEventListener = function (type, callback) {
    listenerHandler.add(type, callback);
  };
  /**
   * Remove an event listener from this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type.
   */
  this.removeEventListener = function (type, callback) {
    listenerHandler.remove(type, callback);
  };
  /**
   * Fire an event: call all associated listeners with the input event object.
   *
   * @param {object} event The event to fire.
   * @private
   */
  function fireEvent(event) {
    listenerHandler.fireEvent(event);
  }

}; // Livewire class

/**
 * Set the tool live features: shape colour.
 *
 * @param {object} features The list of features.
 */
dwv.tool.Livewire.prototype.setFeatures = function (features) {
  if (typeof features.shapeColour !== 'undefined') {
    this.style.setLineColour(features.shapeColour);
  }
};

// namespaces
var dwv = dwv || {};
dwv.tool = dwv.tool || {};

/**
 * Opacity class.
 *
 * @class
 * @param {dwv.App} app The associated application.
 * @example
 * // create the dwv app
 * var app = new dwv.App();
 * // initialise
 * app.init({
 *   dataViewConfigs: {'*': [{divId: 'layerGroup0'}]},
 *   tools: {Opacity: {}}
 * });
 * // activate tool
 * app.addEventListener('load', function () {
 *   app.setTool('Opacity');
 * });
 * // load dicom data
 * app.loadURLs([
 *   'https://raw.githubusercontent.com/ivmartel/dwv/master/tests/data/bbmri-53323851.dcm'
 * ]);
 */
dwv.tool.Opacity = function (app) {
  /**
   * Closure to self: to be used by event handlers.
   *
   * @private
   * @type {dwv.tool.Opacity}
   */
  var self = this;
  /**
   * Interaction start flag.
   *
   * @type {boolean}
   */
  this.started = false;

  /**
   * Scroll wheel handler.
   *
   * @type {dwv.tool.ScrollWheel}
   */
  var scrollWhell = new dwv.tool.ScrollWheel(app);

  /**
   * Handle mouse down event.
   *
   * @param {object} event The mouse down event.
   */
  this.mousedown = function (event) {
    // start flag
    self.started = true;
    // first position
    self.x0 = event._x;
    self.y0 = event._y;
  };

  /**
   * Handle mouse move event.
   *
   * @param {object} event The mouse move event.
   */
  this.mousemove = function (event) {
    if (!self.started) {
      return;
    }

    // difference to last X position
    var diffX = event._x - self.x0;
    var xMove = (Math.abs(diffX) > 15);
    // do not trigger for small moves
    if (xMove) {
      var layerDetails = dwv.gui.getLayerDetailsFromEvent(event);
      var layerGroup = app.getLayerGroupByDivId(layerDetails.groupDivId);
      var viewLayer = layerGroup.getActiveViewLayer();
      var op = viewLayer.getOpacity();
      viewLayer.setOpacity(op + (diffX / 200));
      viewLayer.draw();

      // reset origin point
      self.x0 = event._x;
    }
  };

  /**
   * Handle mouse up event.
   *
   * @param {object} _event The mouse up event.
   */
  this.mouseup = function (_event) {
    if (self.started) {
      // stop recording
      self.started = false;
    }
  };

  /**
   * Handle mouse out event.
   *
   * @param {object} event The mouse out event.
   */
  this.mouseout = function (event) {
    self.mouseup(event);
  };

  /**
   * Handle touch start event.
   *
   * @param {object} event The touch start event.
   */
  this.touchstart = function (event) {
    // call mouse equivalent
    self.mousedown(event);
  };

  /**
   * Handle touch move event.
   *
   * @param {object} event The touch move event.
   */
  this.touchmove = function (event) {
    // call mouse equivalent
    self.mousemove(event);
  };

  /**
   * Handle touch end event.
   *
   * @param {object} event The touch end event.
   */
  this.touchend = function (event) {
    // call mouse equivalent
    self.mouseup(event);
  };

  /**
   * Handle mouse wheel event.
   *
   * @param {object} event The mouse wheel event.
   */
  this.wheel = function (event) {
    scrollWhell.wheel(event);
  };

  /**
   * Handle key down event.
   *
   * @param {object} event The key down event.
   */
  this.keydown = function (event) {
    event.context = 'dwv.tool.Opacity';
    app.onKeydown(event);
  };

  /**
   * Activate the tool.
   *
   * @param {boolean} _bool The flag to activate or not.
   */
  this.activate = function (_bool) {
    // does nothing
  };

  /**
   * Initialise the tool.
   */
  this.init = function () {
    // does nothing
  };

}; // Opacity class

// namespaces
var dwv = dwv || {};
dwv.tool = dwv.tool || {};
dwv.tool.draw = dwv.tool.draw || {};
/**
 * The Konva namespace.
 *
 * @external Konva
 * @see https://konvajs.org/
 */
var Konva = Konva || {};

/**
 * Default draw label text.
 */
dwv.tool.draw.defaultProtractorLabelText = '{angle}';

/**
 * Protractor factory.
 *
 * @class
 */
dwv.tool.draw.ProtractorFactory = function () {
  /**
   * Get the name of the shape group.
   *
   * @returns {string} The name.
   */
  this.getGroupName = function () {
    return 'protractor-group';
  };
  /**
   * Get the number of points needed to build the shape.
   *
   * @returns {number} The number of points.
   */
  this.getNPoints = function () {
    return 3;
  };
  /**
   * Get the timeout between point storage.
   *
   * @returns {number} The timeout in milliseconds.
   */
  this.getTimeout = function () {
    return 500;
  };
};

/**
 * Is the input group a group of this factory?
 *
 * @param {object} group The group to test.
 * @returns {boolean} True if the group is from this fcatory.
 */
dwv.tool.draw.ProtractorFactory.prototype.isFactoryGroup = function (group) {
  return this.getGroupName() === group.name();
};

/**
 * Create a protractor shape to be displayed.
 *
 * @param {Array} points The points from which to extract the protractor.
 * @param {object} style The drawing style.
 * @param {object} _viewController The associated view controller.
 * @returns {object} The Konva group.
 */
dwv.tool.draw.ProtractorFactory.prototype.create = function (
  points, style, _viewController) {
  // physical shape
  var line0 = new dwv.math.Line(points[0], points[1]);
  // points stored the Konvajs way
  var pointsArray = [];
  for (var i = 0; i < points.length; ++i) {
    pointsArray.push(points[i].getX());
    pointsArray.push(points[i].getY());
  }
  // draw shape
  var kshape = new Konva.Line({
    points: pointsArray,
    stroke: style.getLineColour(),
    strokeWidth: style.getStrokeWidth(),
    strokeScaleEnabled: false,
    name: 'shape'
  });
  var group = new Konva.Group();
  group.name(this.getGroupName());
  // text and decoration
  if (points.length === 3) {
    var line1 = new dwv.math.Line(points[1], points[2]);
    // larger hitfunc
    kshape.hitFunc(function (context) {
      context.beginPath();
      context.moveTo(points[0].getX(), points[0].getY());
      context.lineTo(points[1].getX(), points[1].getY());
      context.lineTo(points[2].getX(), points[2].getY());
      context.closePath();
      context.fillStrokeShape(this);
    });
    // quantification
    var angle = dwv.math.getAngle(line0, line1);
    var inclination = line0.getInclination();
    if (angle > 180) {
      angle = 360 - angle;
      inclination += angle;
    }

    // quantification
    var ktext = new Konva.Text({
      fontSize: style.getFontSize(),
      fontFamily: style.getFontFamily(),
      fill: style.getLineColour(),
      padding: style.getTextPadding(),
      shadowColor: style.getShadowLineColour(),
      shadowOffset: style.getShadowOffset(),
      name: 'text'
    });
    var textExpr = '';
    if (typeof dwv.tool.draw.protractorLabelText !== 'undefined') {
      textExpr = dwv.tool.draw.protractorLabelText;
    } else {
      textExpr = dwv.tool.draw.defaultProtractorLabelText;
    }
    var quant = {
      angle: {
        value: angle,
        unit: dwv.i18n('unit.degree')
      }
    };
    ktext.setText(dwv.utils.replaceFlags(textExpr, quant));
    // meta data
    ktext.meta = {
      textExpr: textExpr,
      quantification: quant
    };

    // label
    var midX = (line0.getMidpoint().getX() + line1.getMidpoint().getX()) / 2;
    var midY = (line0.getMidpoint().getY() + line1.getMidpoint().getY()) / 2;
    var klabel = new Konva.Label({
      x: midX,
      y: midY - style.applyZoomScale(15).y,
      scale: style.applyZoomScale(1),
      visible: textExpr.length !== 0,
      name: 'label'
    });
    klabel.add(ktext);
    klabel.add(new Konva.Tag({
      fill: style.getLineColour(),
      opacity: style.getTagOpacity()
    }));

    // arc
    var radius = Math.min(line0.getLength(), line1.getLength()) * 33 / 100;
    var karc = new Konva.Arc({
      innerRadius: radius,
      outerRadius: radius,
      stroke: style.getLineColour(),
      strokeWidth: style.getStrokeWidth(),
      strokeScaleEnabled: false,
      angle: angle,
      rotation: -inclination,
      x: points[1].getX(),
      y: points[1].getY(),
      name: 'shape-arc'
    });
    // add to group
    group.add(klabel);
    group.add(karc);
  }
  // add shape to group
  group.add(kshape);
  group.visible(true); // dont inherit
  // return group
  return group;
};

/**
 * Get anchors to update a protractor shape.
 *
 * @param {object} shape The associated shape.
 * @param {object} style The application style.
 * @returns {Array} A list of anchors.
 */
dwv.tool.draw.ProtractorFactory.prototype.getAnchors = function (shape, style) {
  var points = shape.points();

  var anchors = [];
  anchors.push(dwv.tool.draw.getDefaultAnchor(
    points[0] + shape.x(), points[1] + shape.y(), 'begin', style
  ));
  anchors.push(dwv.tool.draw.getDefaultAnchor(
    points[2] + shape.x(), points[3] + shape.y(), 'mid', style
  ));
  anchors.push(dwv.tool.draw.getDefaultAnchor(
    points[4] + shape.x(), points[5] + shape.y(), 'end', style
  ));
  return anchors;
};

/**
 * Update a protractor shape.
 * Warning: do NOT use 'this' here, this method is passed
 *   as is to the change command.
 *
 * @param {object} anchor The active anchor.
 * @param {object} style The app style.
 * @param {object} _viewController The associated view controller.
 */
dwv.tool.draw.ProtractorFactory.prototype.update = function (
  anchor, style, _viewController) {
  // parent group
  var group = anchor.getParent();
  // associated shape
  var kline = group.getChildren(function (node) {
    return node.name() === 'shape';
  })[0];
    // associated label
  var klabel = group.getChildren(function (node) {
    return node.name() === 'label';
  })[0];
    // associated arc
  var karc = group.getChildren(function (node) {
    return node.name() === 'shape-arc';
  })[0];
    // find special points
  var begin = group.getChildren(function (node) {
    return node.id() === 'begin';
  })[0];
  var mid = group.getChildren(function (node) {
    return node.id() === 'mid';
  })[0];
  var end = group.getChildren(function (node) {
    return node.id() === 'end';
  })[0];
    // update special points
  switch (anchor.id()) {
  case 'begin':
    begin.x(anchor.x());
    begin.y(anchor.y());
    break;
  case 'mid':
    mid.x(anchor.x());
    mid.y(anchor.y());
    break;
  case 'end':
    end.x(anchor.x());
    end.y(anchor.y());
    break;
  }
  // update shape and compensate for possible drag
  // note: shape.position() and shape.size() won't work...
  var bx = begin.x() - kline.x();
  var by = begin.y() - kline.y();
  var mx = mid.x() - kline.x();
  var my = mid.y() - kline.y();
  var ex = end.x() - kline.x();
  var ey = end.y() - kline.y();
  kline.points([bx, by, mx, my, ex, ey]);
  // larger hitfunc
  kline.hitFunc(function (context) {
    context.beginPath();
    context.moveTo(bx, by);
    context.lineTo(mx, my);
    context.lineTo(ex, ey);
    context.closePath();
    context.fillStrokeShape(this);
  });
  // update text
  var p2d0 = new dwv.math.Point2D(begin.x(), begin.y());
  var p2d1 = new dwv.math.Point2D(mid.x(), mid.y());
  var p2d2 = new dwv.math.Point2D(end.x(), end.y());
  var line0 = new dwv.math.Line(p2d0, p2d1);
  var line1 = new dwv.math.Line(p2d1, p2d2);
  var angle = dwv.math.getAngle(line0, line1);
  var inclination = line0.getInclination();
  if (angle > 180) {
    angle = 360 - angle;
    inclination += angle;
  }

  // update text
  var ktext = klabel.getText();
  var quantification = {
    angle: {value: angle, unit: dwv.i18n('unit.degree')}
  };
  ktext.setText(dwv.utils.replaceFlags(ktext.meta.textExpr, quantification));
  // update meta
  ktext.meta.quantification = quantification;
  // update position
  var midX = (line0.getMidpoint().getX() + line1.getMidpoint().getX()) / 2;
  var midY = (line0.getMidpoint().getY() + line1.getMidpoint().getY()) / 2;
  var textPos = {
    x: midX,
    y: midY - style.applyZoomScale(15).y
  };
  klabel.position(textPos);

  // arc
  var radius = Math.min(line0.getLength(), line1.getLength()) * 33 / 100;
  karc.innerRadius(radius);
  karc.outerRadius(radius);
  karc.angle(angle);
  karc.rotation(-inclination);
  var arcPos = {x: mid.x(), y: mid.y()};
  karc.position(arcPos);
};

// namespaces
var dwv = dwv || {};
dwv.tool = dwv.tool || {};
dwv.tool.draw = dwv.tool.draw || {};
/**
 * The Konva namespace.
 *
 * @external Konva
 * @see https://konvajs.org/
 */
var Konva = Konva || {};

/**
 * Default draw label text.
 */
dwv.tool.draw.defaultRectangleLabelText = '{surface}';

/**
 * Rectangle factory.
 *
 * @class
 */
dwv.tool.draw.RectangleFactory = function () {
  /**
   * Get the name of the shape group.
   *
   * @returns {string} The name.
   */
  this.getGroupName = function () {
    return 'rectangle-group';
  };
  /**
   * Get the number of points needed to build the shape.
   *
   * @returns {number} The number of points.
   */
  this.getNPoints = function () {
    return 2;
  };
  /**
   * Get the timeout between point storage.
   *
   * @returns {number} The timeout in milliseconds.
   */
  this.getTimeout = function () {
    return 0;
  };
};

/**
 * Is the input group a group of this factory?
 *
 * @param {object} group The group to test.
 * @returns {boolean} True if the group is from this fcatory.
 */
dwv.tool.draw.RectangleFactory.prototype.isFactoryGroup = function (group) {
  return this.getGroupName() === group.name();
};

/**
 * Create a rectangle shape to be displayed.
 *
 * @param {Array} points The points from which to extract the rectangle.
 * @param {object} style The drawing style.
 * @param {object} viewController The associated view controller.
 * @returns {object} The Konva group.
 */
dwv.tool.draw.RectangleFactory.prototype.create = function (
  points, style, viewController) {
  // physical shape
  var rectangle = new dwv.math.Rectangle(points[0], points[1]);
  // draw shape
  var kshape = new Konva.Rect({
    x: rectangle.getBegin().getX(),
    y: rectangle.getBegin().getY(),
    width: rectangle.getWidth(),
    height: rectangle.getHeight(),
    stroke: style.getLineColour(),
    strokeWidth: style.getStrokeWidth(),
    strokeScaleEnabled: false,
    name: 'shape'
  });
  // label text
  var ktext = new Konva.Text({
    fontSize: style.getFontSize(),
    fontFamily: style.getFontFamily(),
    fill: style.getLineColour(),
    padding: style.getTextPadding(),
    shadowColor: style.getShadowLineColour(),
    shadowOffset: style.getShadowOffset(),
    name: 'text'
  });
  var textExpr = '';
  if (typeof dwv.tool.draw.rectangleLabelText !== 'undefined') {
    textExpr = dwv.tool.draw.rectangleLabelText;
  } else {
    textExpr = dwv.tool.draw.defaultRectangleLabelText;
  }
  var quant = rectangle.quantify(
    viewController,
    dwv.utils.getFlags(textExpr));
  ktext.setText(dwv.utils.replaceFlags(textExpr, quant));
  // meta data
  ktext.meta = {
    textExpr: textExpr,
    quantification: quant
  };
  // label
  var klabel = new Konva.Label({
    x: rectangle.getBegin().getX(),
    y: rectangle.getEnd().getY(),
    scale: style.applyZoomScale(1),
    visible: textExpr.length !== 0,
    name: 'label'
  });
  klabel.add(ktext);
  klabel.add(new Konva.Tag({
    fill: style.getLineColour(),
    opacity: style.getTagOpacity()
  }));

  // debug shadow
  var kshadow;
  if (dwv.tool.draw.debug) {
    kshadow = dwv.tool.draw.getShadowRectangle(rectangle);
  }

  // return group
  var group = new Konva.Group();
  group.name(this.getGroupName());
  if (kshadow) {
    group.add(kshadow);
  }
  group.add(klabel);
  group.add(kshape);
  group.visible(true); // dont inherit
  return group;
};

/**
 * Get anchors to update a rectangle shape.
 *
 * @param {object} shape The associated shape.
 * @param {object} style The application style.
 * @returns {Array} A list of anchors.
 */
dwv.tool.draw.RectangleFactory.prototype.getAnchors = function (shape, style) {
  var rectX = shape.x();
  var rectY = shape.y();
  var rectWidth = shape.width();
  var rectHeight = shape.height();

  var anchors = [];
  anchors.push(dwv.tool.draw.getDefaultAnchor(
    rectX, rectY, 'topLeft', style
  ));
  anchors.push(dwv.tool.draw.getDefaultAnchor(
    rectX + rectWidth, rectY, 'topRight', style
  ));
  anchors.push(dwv.tool.draw.getDefaultAnchor(
    rectX + rectWidth, rectY + rectHeight, 'bottomRight', style
  ));
  anchors.push(dwv.tool.draw.getDefaultAnchor(
    rectX, rectY + rectHeight, 'bottomLeft', style
  ));
  return anchors;
};

/**
 * Update a rectangle shape.
 * Warning: do NOT use 'this' here, this method is passed
 *   as is to the change command.
 *
 * @param {object} anchor The active anchor.
 * @param {object} style The app style.
 * @param {object} viewController The associated view controller.
 */
dwv.tool.draw.RectangleFactory.prototype.update = function (
  anchor, style, viewController) {
  // parent group
  var group = anchor.getParent();
  // associated shape
  var krect = group.getChildren(function (node) {
    return node.name() === 'shape';
  })[0];
  // associated label
  var klabel = group.getChildren(function (node) {
    return node.name() === 'label';
  })[0];
    // find special points
  var topLeft = group.getChildren(function (node) {
    return node.id() === 'topLeft';
  })[0];
  var topRight = group.getChildren(function (node) {
    return node.id() === 'topRight';
  })[0];
  var bottomRight = group.getChildren(function (node) {
    return node.id() === 'bottomRight';
  })[0];
  var bottomLeft = group.getChildren(function (node) {
    return node.id() === 'bottomLeft';
  })[0];
  // debug shadow
  var kshadow;
  if (dwv.tool.draw.debug) {
    kshadow = group.getChildren(function (node) {
      return node.name() === 'shadow';
    })[0];
  }

  // update 'self' (undo case) and special points
  switch (anchor.id()) {
  case 'topLeft':
    topLeft.x(anchor.x());
    topLeft.y(anchor.y());
    topRight.y(anchor.y());
    bottomLeft.x(anchor.x());
    break;
  case 'topRight':
    topRight.x(anchor.x());
    topRight.y(anchor.y());
    topLeft.y(anchor.y());
    bottomRight.x(anchor.x());
    break;
  case 'bottomRight':
    bottomRight.x(anchor.x());
    bottomRight.y(anchor.y());
    bottomLeft.y(anchor.y());
    topRight.x(anchor.x());
    break;
  case 'bottomLeft':
    bottomLeft.x(anchor.x());
    bottomLeft.y(anchor.y());
    bottomRight.y(anchor.y());
    topLeft.x(anchor.x());
    break;
  default :
    dwv.logger.error('Unhandled anchor id: ' + anchor.id());
    break;
  }
  // update shape
  krect.position(topLeft.position());
  var width = topRight.x() - topLeft.x();
  var height = bottomLeft.y() - topLeft.y();
  if (width && height) {
    krect.size({width: width, height: height});
  }
  // positions: add possible group offset
  var p2d0 = new dwv.math.Point2D(
    group.x() + topLeft.x(),
    group.y() + topLeft.y()
  );
  var p2d1 = new dwv.math.Point2D(
    group.x() + bottomRight.x(),
    group.y() + bottomRight.y()
  );
  // new rect
  var rect = new dwv.math.Rectangle(p2d0, p2d1);

  // debug shadow based on round (used in quantification)
  if (kshadow) {
    var round = rect.getRound();
    var rWidth = round.max.getX() - round.min.getX();
    var rHeight = round.max.getY() - round.min.getY();
    kshadow.position({
      x: round.min.getX() - group.x(),
      y: round.min.getY() - group.y()
    });
    kshadow.size({width: rWidth, height: rHeight});
  }

  // update label position
  var textPos = {
    x: rect.getBegin().getX() - group.x(),
    y: rect.getEnd().getY() - group.y()
  };
  klabel.position(textPos);

  // update quantification
  dwv.tool.draw.updateRectangleQuantification(group, viewController);
};

/**
 * Update the quantification of a Rectangle.
 *
 * @param {object} group The group with the shape.
 * @param {object} viewController The associated view controller.
 */
dwv.tool.draw.RectangleFactory.prototype.updateQuantification = function (
  group, viewController) {
  dwv.tool.draw.updateRectangleQuantification(group, viewController);
};

/**
 * Update the quantification of a Rectangle (as a static
 *   function to be used in update).
 *
 * @param {object} group The group with the shape.
 * @param {object} viewController The associated view controller.
 */
dwv.tool.draw.updateRectangleQuantification = function (
  group, viewController) {
  // associated shape
  var krect = group.getChildren(function (node) {
    return node.name() === 'shape';
  })[0];
  // associated label
  var klabel = group.getChildren(function (node) {
    return node.name() === 'label';
  })[0];

  // positions: add possible group offset
  var p2d0 = new dwv.math.Point2D(
    group.x() + krect.x(),
    group.y() + krect.y()
  );
  var p2d1 = new dwv.math.Point2D(
    p2d0.getX() + krect.width(),
    p2d0.getY() + krect.height()
  );
  // rectangle
  var rect = new dwv.math.Rectangle(p2d0, p2d1);

  // update text
  var ktext = klabel.getText();
  var quantification = rect.quantify(
    viewController,
    dwv.utils.getFlags(ktext.meta.textExpr));
  ktext.setText(dwv.utils.replaceFlags(ktext.meta.textExpr, quantification));
  // update meta
  ktext.meta.quantification = quantification;
};

/**
 * Get the debug shadow.
 *
 * @param {object} rectangle The rectangle to shadow.
 * @returns {object} The shadow konva shape.
 */
dwv.tool.draw.getShadowRectangle = function (rectangle) {
  var round = rectangle.getRound();
  var rWidth = round.max.getX() - round.min.getX();
  var rHeight = round.max.getY() - round.min.getY();
  return new Konva.Rect({
    x: round.min.getX(),
    y: round.min.getY(),
    width: rWidth,
    height: rHeight,
    fill: 'grey',
    strokeWidth: 0,
    strokeScaleEnabled: false,
    opacity: 0.3,
    name: 'shadow'
  });
};

// namespaces
var dwv = dwv || {};
dwv.tool = dwv.tool || {};
dwv.tool.draw = dwv.tool.draw || {};
/**
 * The Konva namespace.
 *
 * @external Konva
 * @see https://konvajs.org/
 */
var Konva = Konva || {};

/**
 * Default draw label text.
 */
dwv.tool.draw.defaultRoiLabelText = '';

/**
 * ROI factory.
 *
 * @class
 */
dwv.tool.draw.RoiFactory = function () {
  /**
   * Get the name of the shape group.
   *
   * @returns {string} The name.
   */
  this.getGroupName = function () {
    return 'roi-group';
  };
  /**
   * Get the number of points needed to build the shape.
   *
   * @returns {number|undefined} The number of points.
   */
  this.getNPoints = function () {
    // undefined to end with double click
    return undefined;
  };
  /**
   * Get the timeout between point storage.
   *
   * @returns {number} The timeout in milliseconds.
   */
  this.getTimeout = function () {
    return 100;
  };
};

/**
 * Is the input group a group of this factory?
 *
 * @param {object} group The group to test.
 * @returns {boolean} True if the group is from this fcatory.
 */
dwv.tool.draw.RoiFactory.prototype.isFactoryGroup = function (group) {
  return this.getGroupName() === group.name();
};

/**
 * Create a roi shape to be displayed.
 *
 * @param {Array} points The points from which to extract the line.
 * @param {object} style The drawing style.
 * @param {object} _viewController The associated view controller.
 * @returns {object} The Konva group.
 */
dwv.tool.draw.RoiFactory.prototype.create = function (
  points, style, _viewController) {
  // physical shape
  var roi = new dwv.math.ROI();
  // add input points to the ROI
  roi.addPoints(points);
  // points stored the Konvajs way
  var arr = [];
  for (var i = 0; i < roi.getLength(); ++i) {
    arr.push(roi.getPoint(i).getX());
    arr.push(roi.getPoint(i).getY());
  }
  // draw shape
  var kshape = new Konva.Line({
    points: arr,
    stroke: style.getLineColour(),
    strokeWidth: style.getStrokeWidth(),
    strokeScaleEnabled: false,
    name: 'shape',
    closed: true
  });

  // text
  var ktext = new Konva.Text({
    fontSize: style.getFontSize(),
    fontFamily: style.getFontFamily(),
    fill: style.getLineColour(),
    name: 'text'
  });
  var textExpr = '';
  if (typeof dwv.tool.draw.roiLabelText !== 'undefined') {
    textExpr = dwv.tool.draw.roiLabelText;
  } else {
    textExpr = dwv.tool.draw.defaultRoiLabelText;
  }
  ktext.setText(textExpr);
  // meta data
  ktext.meta = {
    textExpr: textExpr,
    quantification: {}
  };

  // label
  var klabel = new Konva.Label({
    x: roi.getPoint(0).getX(),
    y: roi.getPoint(0).getY() + style.scale(10),
    scale: style.applyZoomScale(1),
    visible: textExpr.length !== 0,
    name: 'label'
  });
  klabel.add(ktext);
  klabel.add(new Konva.Tag({
    fill: style.getLineColour(),
    opacity: style.getTagOpacity()
  }));

  // return group
  var group = new Konva.Group();
  group.name(this.getGroupName());
  group.add(klabel);
  group.add(kshape);
  group.visible(true); // dont inherit
  return group;
};

/**
 * Get anchors to update a roi shape.
 *
 * @param {object} shape The associated shape.
 * @param {object} style The application style.
 * @returns {Array} A list of anchors.
 */
dwv.tool.draw.RoiFactory.prototype.getAnchors = function (shape, style) {
  var points = shape.points();

  var anchors = [];
  for (var i = 0; i < points.length; i = i + 2) {
    var px = points[i] + shape.x();
    var py = points[i + 1] + shape.y();
    var name = i;
    anchors.push(dwv.tool.draw.getDefaultAnchor(
      px, py, name, style
    ));
  }
  return anchors;
};

/**
 * Update a roi shape.
 * Warning: do NOT use 'this' here, this method is passed
 *   as is to the change command.
 *
 * @param {object} anchor The active anchor.
 * @param {object} style The app style.
 * @param {object} _viewController The associated view controller.
 */
dwv.tool.draw.RoiFactory.prototype.update = function (
  anchor, style, _viewController) {
  // parent group
  var group = anchor.getParent();
  // associated shape
  var kroi = group.getChildren(function (node) {
    return node.name() === 'shape';
  })[0];
    // associated label
  var klabel = group.getChildren(function (node) {
    return node.name() === 'label';
  })[0];

  // update self
  var point = group.getChildren(function (node) {
    return node.id() === anchor.id();
  })[0];
  point.x(anchor.x());
  point.y(anchor.y());
  // update the roi point and compensate for possible drag
  // (the anchor id is the index of the point in the list)
  var points = kroi.points();
  points[anchor.id()] = anchor.x() - kroi.x();
  points[anchor.id() + 1] = anchor.y() - kroi.y();
  kroi.points(points);

  // update text
  var ktext = klabel.getText();
  ktext.setText(ktext.meta.textExpr);
  // update position
  var textPos = {
    x: points[0] + kroi.x(),
    y: points[1] + kroi.y() + style.scale(10)
  };
  klabel.position(textPos);

};

// namespaces
var dwv = dwv || {};
dwv.tool = dwv.tool || {};
dwv.tool.draw = dwv.tool.draw || {};
/**
 * The Konva namespace.
 *
 * @external Konva
 * @see https://konvajs.org/
 */
var Konva = Konva || {};

/**
 * Default draw label text.
 */
dwv.tool.draw.defaultRulerLabelText = '{length}';

/**
 * Ruler factory.
 *
 * @class
 */
dwv.tool.draw.RulerFactory = function () {
  /**
   * Get the name of the shape group.
   *
   * @returns {string} The name.
   */
  this.getGroupName = function () {
    return 'ruler-group';
  };
  /**
   * Get the number of points needed to build the shape.
   *
   * @returns {number} The number of points.
   */
  this.getNPoints = function () {
    return 2;
  };
  /**
   * Get the timeout between point storage.
   *
   * @returns {number} The timeout in milliseconds.
   */
  this.getTimeout = function () {
    return 0;
  };
};

/**
 * Is the input group a group of this factory?
 *
 * @param {object} group The group to test.
 * @returns {boolean} True if the group is from this fcatory.
 */
dwv.tool.draw.RulerFactory.prototype.isFactoryGroup = function (group) {
  return this.getGroupName() === group.name();
};

/**
 * Create a ruler shape to be displayed.
 *
 * @param {Array} points The points from which to extract the line.
 * @param {object} style The drawing style.
 * @param {object} viewController The associated view controller.
 * @returns {object} The Konva group.
 */
dwv.tool.draw.RulerFactory.prototype.create = function (
  points, style, viewController) {
  // physical shape
  var line = new dwv.math.Line(points[0], points[1]);
  // draw shape
  var kshape = new Konva.Line({
    points: [line.getBegin().getX(),
      line.getBegin().getY(),
      line.getEnd().getX(),
      line.getEnd().getY()],
    stroke: style.getLineColour(),
    strokeWidth: style.getStrokeWidth(),
    strokeScaleEnabled: false,
    name: 'shape'
  });

  var tickLen = style.scale(10);

  // tick begin
  var linePerp0 = dwv.math.getPerpendicularLine(line, points[0], tickLen);
  var ktick0 = new Konva.Line({
    points: [linePerp0.getBegin().getX(),
      linePerp0.getBegin().getY(),
      linePerp0.getEnd().getX(),
      linePerp0.getEnd().getY()],
    stroke: style.getLineColour(),
    strokeWidth: style.getStrokeWidth(),
    strokeScaleEnabled: false,
    name: 'shape-tick0'
  });

  // tick end
  var linePerp1 = dwv.math.getPerpendicularLine(line, points[1], tickLen);
  var ktick1 = new Konva.Line({
    points: [linePerp1.getBegin().getX(),
      linePerp1.getBegin().getY(),
      linePerp1.getEnd().getX(),
      linePerp1.getEnd().getY()],
    stroke: style.getLineColour(),
    strokeWidth: style.getStrokeWidth(),
    strokeScaleEnabled: false,
    name: 'shape-tick1'
  });

  // larger hitfunc
  kshape.hitFunc(function (context) {
    context.beginPath();
    context.moveTo(linePerp0.getBegin().getX(), linePerp0.getBegin().getY());
    context.lineTo(linePerp0.getEnd().getX(), linePerp0.getEnd().getY());
    context.lineTo(linePerp1.getEnd().getX(), linePerp1.getEnd().getY());
    context.lineTo(linePerp1.getBegin().getX(), linePerp1.getBegin().getY());
    context.closePath();
    context.fillStrokeShape(this);
  });

  // quantification
  var ktext = new Konva.Text({
    fontSize: style.getFontSize(),
    fontFamily: style.getFontFamily(),
    fill: style.getLineColour(),
    padding: style.getTextPadding(),
    shadowColor: style.getShadowLineColour(),
    shadowOffset: style.getShadowOffset(),
    name: 'text'
  });
  var textExpr = '';
  if (typeof dwv.tool.draw.rulerLabelText !== 'undefined') {
    textExpr = dwv.tool.draw.rulerLabelText;
  } else {
    textExpr = dwv.tool.draw.defaultRulerLabelText;
  }
  var quant = line.quantify(
    viewController,
    dwv.utils.getFlags(textExpr));
  ktext.setText(dwv.utils.replaceFlags(textExpr, quant));
  // meta data
  ktext.meta = {
    textExpr: textExpr,
    quantification: quant
  };

  // label
  var dX = line.getBegin().getX() > line.getEnd().getX() ? 0 : -1;
  var dY = line.getBegin().getY() > line.getEnd().getY() ? -1 : 0;
  var klabel = new Konva.Label({
    x: line.getEnd().getX() + dX * ktext.width(),
    y: line.getEnd().getY() + dY * style.applyZoomScale(15).y,
    scale: style.applyZoomScale(1),
    visible: textExpr.length !== 0,
    name: 'label'
  });
  klabel.add(ktext);
  klabel.add(new Konva.Tag({
    fill: style.getLineColour(),
    opacity: style.getTagOpacity()
  }));

  // return group
  var group = new Konva.Group();
  group.name(this.getGroupName());
  group.add(klabel);
  group.add(ktick0);
  group.add(ktick1);
  group.add(kshape);
  group.visible(true); // dont inherit
  return group;
};

/**
 * Get anchors to update a ruler shape.
 *
 * @param {object} shape The associated shape.
 * @param {object} style The application style.
 * @returns {Array} A list of anchors.
 */
dwv.tool.draw.RulerFactory.prototype.getAnchors = function (shape, style) {
  var points = shape.points();

  var anchors = [];
  anchors.push(dwv.tool.draw.getDefaultAnchor(
    points[0] + shape.x(), points[1] + shape.y(), 'begin', style
  ));
  anchors.push(dwv.tool.draw.getDefaultAnchor(
    points[2] + shape.x(), points[3] + shape.y(), 'end', style
  ));
  return anchors;
};

/**
 * Update a ruler shape.
 * Warning: do NOT use 'this' here, this method is passed
 *   as is to the change command.
 *
 * @param {object} anchor The active anchor.
 * @param {object} style The app style.
 * @param {object} viewController The associated view controller.
 */
dwv.tool.draw.RulerFactory.prototype.update = function (
  anchor, style, viewController) {
  // parent group
  var group = anchor.getParent();
  // associated shape
  var kline = group.getChildren(function (node) {
    return node.name() === 'shape';
  })[0];
    // associated tick0
  var ktick0 = group.getChildren(function (node) {
    return node.name() === 'shape-tick0';
  })[0];
    // associated tick1
  var ktick1 = group.getChildren(function (node) {
    return node.name() === 'shape-tick1';
  })[0];
    // associated label
  var klabel = group.getChildren(function (node) {
    return node.name() === 'label';
  })[0];
    // find special points
  var begin = group.getChildren(function (node) {
    return node.id() === 'begin';
  })[0];
  var end = group.getChildren(function (node) {
    return node.id() === 'end';
  })[0];
    // update special points
  switch (anchor.id()) {
  case 'begin':
    begin.x(anchor.x());
    begin.y(anchor.y());
    break;
  case 'end':
    end.x(anchor.x());
    end.y(anchor.y());
    break;
  }
  // update shape and compensate for possible drag
  // note: shape.position() and shape.size() won't work...
  var bx = begin.x() - kline.x();
  var by = begin.y() - kline.y();
  var ex = end.x() - kline.x();
  var ey = end.y() - kline.y();
  kline.points([bx, by, ex, ey]);
  // new line
  var p2d0 = new dwv.math.Point2D(begin.x(), begin.y());
  var p2d1 = new dwv.math.Point2D(end.x(), end.y());
  var line = new dwv.math.Line(p2d0, p2d1);
  // tick
  var p2b = new dwv.math.Point2D(bx, by);
  var p2e = new dwv.math.Point2D(ex, ey);
  var linePerp0 = dwv.math.getPerpendicularLine(line, p2b, style.scale(10));
  ktick0.points([linePerp0.getBegin().getX(),
    linePerp0.getBegin().getY(),
    linePerp0.getEnd().getX(),
    linePerp0.getEnd().getY()]);
  var linePerp1 = dwv.math.getPerpendicularLine(line, p2e, style.scale(10));
  ktick1.points([linePerp1.getBegin().getX(),
    linePerp1.getBegin().getY(),
    linePerp1.getEnd().getX(),
    linePerp1.getEnd().getY()]);
  // larger hitfunc
  kline.hitFunc(function (context) {
    context.beginPath();
    context.moveTo(linePerp0.getBegin().getX(), linePerp0.getBegin().getY());
    context.lineTo(linePerp0.getEnd().getX(), linePerp0.getEnd().getY());
    context.lineTo(linePerp1.getEnd().getX(), linePerp1.getEnd().getY());
    context.lineTo(linePerp1.getBegin().getX(), linePerp1.getBegin().getY());
    context.closePath();
    context.fillStrokeShape(this);
  });

  // update text
  var ktext = klabel.getText();
  var quantification = line.quantify(
    viewController,
    dwv.utils.getFlags(ktext.meta.textExpr));
  ktext.setText(dwv.utils.replaceFlags(ktext.meta.textExpr, quantification));
  // update meta
  ktext.meta.quantification = quantification;
  // update position
  var dX = line.getBegin().getX() > line.getEnd().getX() ? 0 : -1;
  var dY = line.getBegin().getY() > line.getEnd().getY() ? -1 : 0;
  var textPos = {
    x: line.getEnd().getX() + dX * ktext.width(),
    y: line.getEnd().getY() + dY * style.applyZoomScale(15).y
  };
  klabel.position(textPos);
};

// namespaces
var dwv = dwv || {};
dwv.tool = dwv.tool || {};

/**
 * Scroll class.
 *
 * @class
 * @param {dwv.App} app The associated application.
 * @example
 * // create the dwv app
 * var app = new dwv.App();
 * // initialise
 * app.init({
 *   dataViewConfigs: {'*': [{divId: 'layerGroup0'}]},
 *   tools: {Scroll: {}}
 * });
 * // activate tool
 * app.addEventListener('load', function () {
 *   app.setTool('Scroll');
 * });
 * // load dicom data
 * app.loadURLs([
 *   'https://raw.githubusercontent.com/ivmartel/dwv/master/tests/data/bbmri-53323851.dcm',
 *   'https://raw.githubusercontent.com/ivmartel/dwv/master/tests/data/bbmri-53323707.dcm',
 *   'https://raw.githubusercontent.com/ivmartel/dwv/master/tests/data/bbmri-53323563.dcm'
 * ]);
 * @example <caption>Example with slider</caption>
 * // create the dwv app
 * var app = new dwv.App();
 * // initialise
 * app.init({
 *   dataViewConfigs: {'*': [{divId: 'layerGroup0'}]},
 *   tools: {Scroll: {}}
 * });
 * // create range
 * var range = document.createElement('input');
 * range.type = 'range';
 * range.min = 0;
 * range.id = 'sliceRange';
 * document.body.appendChild(range);
 * // update app on slider change
 * range.oninput = function () {
 *   var lg = app.getLayerGroupByDivId('layerGroup0');
 *   var vc = lg.getActiveViewLayer().getViewController();
 *   var index = vc.getCurrentIndex();
 *   var values = index.getValues();
 *   values[2] = this.value;
 *   vc.setCurrentIndex(new dwv.math.Index(values));
 * }
 * // activate tool and update range max on load
 * app.addEventListener('load', function () {
 *   app.setTool('Scroll');
 *   var size = app.getImage(0).getGeometry().getSize();
 *   range.max = size.get(2) - 1;
 * });
 * // update slider on slice change (for ex via mouse wheel)
 * app.addEventListener('positionchange', function () {
 *   var lg = app.getLayerGroupByDivId('layerGroup0');
 *   var vc = lg.getActiveViewLayer().getViewController();
 *   range.value = vc.getCurrentIndex().get(2);
 * });
 * // load dicom data
 * app.loadURLs([
 *   'https://raw.githubusercontent.com/ivmartel/dwv/master/tests/data/bbmri-53323851.dcm',
 *   'https://raw.githubusercontent.com/ivmartel/dwv/master/tests/data/bbmri-53323707.dcm',
 *   'https://raw.githubusercontent.com/ivmartel/dwv/master/tests/data/bbmri-53323563.dcm'
 * ]);
 */
dwv.tool.Scroll = function (app) {
  /**
   * Closure to self: to be used by event handlers.
   *
   * @private
   * @type {dwv.tool.Scroll}
   */
  var self = this;
  /**
   * Interaction start flag.
   *
   * @type {boolean}
   */
  this.started = false;
  // touch timer ID (created by setTimeout)
  var touchTimerID = null;

  /**
   * Scroll wheel handler.
   *
   * @type {dwv.tool.ScrollWheel}
   */
  var scrollWhell = new dwv.tool.ScrollWheel(app);

  /**
   * Option to show or not a value tooltip on mousemove.
   *
   * @type {boolean}
   */
  var displayTooltip = false;

  /**
   * Handle mouse down event.
   *
   * @param {object} event The mouse down event.
   */
  this.mousedown = function (event) {
    // optional tooltip
    removeTooltipDiv();

    // stop viewer if playing
    var layerDetails = dwv.gui.getLayerDetailsFromEvent(event);
    var layerGroup = app.getLayerGroupByDivId(layerDetails.groupDivId);
    var viewLayer = layerGroup.getActiveViewLayer();
    var viewController = viewLayer.getViewController();
    if (viewController.isPlaying()) {
      viewController.stop();
    }
    // start flag
    self.started = true;
    // first position
    self.x0 = event._x;
    self.y0 = event._y;

    // update controller position
    var planePos = viewLayer.displayToPlanePos(event._x, event._y);
    var position = viewController.getPositionFromPlanePoint(
      planePos.x, planePos.y);
    viewController.setCurrentPosition(position);
  };

  /**
   * Handle mouse move event.
   *
   * @param {object} event The mouse move event.
   */
  this.mousemove = function (event) {
    if (!self.started) {
      // optional tooltip
      if (displayTooltip) {
        showTooltip(event);
      }
      return;
    }

    var layerDetails = dwv.gui.getLayerDetailsFromEvent(event);
    var layerGroup = app.getLayerGroupByDivId(layerDetails.groupDivId);
    var viewLayer = layerGroup.getActiveViewLayer();
    var viewController = viewLayer.getViewController();

    // difference to last Y position
    var diffY = event._y - self.y0;
    var yMove = (Math.abs(diffY) > 15);
    // do not trigger for small moves
    if (yMove && viewController.canScroll()) {
      // update view controller
      if (diffY > 0) {
        viewController.decrementScrollIndex();
      } else {
        viewController.incrementScrollIndex();
      }
    }

    // difference to last X position
    var diffX = event._x - self.x0;
    var xMove = (Math.abs(diffX) > 15);
    // do not trigger for small moves
    var imageSize = viewController.getImageSize();
    if (xMove && imageSize.moreThanOne(3)) {
      // update view controller
      if (diffX > 0) {
        viewController.incrementIndex(3);
      } else {
        viewController.decrementIndex(3);
      }
    }

    // reset origin point
    if (xMove) {
      self.x0 = event._x;
    }
    if (yMove) {
      self.y0 = event._y;
    }
  };

  /**
   * Handle mouse up event.
   *
   * @param {object} _event The mouse up event.
   */
  this.mouseup = function (_event) {
    if (self.started) {
      // stop recording
      self.started = false;
    }
  };

  /**
   * Handle mouse out event.
   *
   * @param {object} event The mouse out event.
   */
  this.mouseout = function (event) {
    self.mouseup(event);
    // remove possible tooltip div
    removeTooltipDiv();
  };

  /**
   * Handle touch start event.
   *
   * @param {object} event The touch start event.
   */
  this.touchstart = function (event) {
    // long touch triggers the dblclick
    touchTimerID = setTimeout(self.dblclick, 500);
    // call mouse equivalent
    self.mousedown(event);
  };

  /**
   * Handle touch move event.
   *
   * @param {object} event The touch move event.
   */
  this.touchmove = function (event) {
    // abort timer if move
    if (touchTimerID !== null) {
      clearTimeout(touchTimerID);
      touchTimerID = null;
    }
    // call mouse equivalent
    self.mousemove(event);
  };

  /**
   * Handle touch end event.
   *
   * @param {object} event The touch end event.
   */
  this.touchend = function (event) {
    // abort timer
    if (touchTimerID !== null) {
      clearTimeout(touchTimerID);
      touchTimerID = null;
    }
    // call mouse equivalent
    self.mouseup(event);
  };

  /**
   * Handle mouse wheel event.
   *
   * @param {object} event The mouse wheel event.
   */
  this.wheel = function (event) {
    scrollWhell.wheel(event);
  };

  /**
   * Handle key down event.
   *
   * @param {object} event The key down event.
   */
  this.keydown = function (event) {
    event.context = 'dwv.tool.Scroll';
    app.onKeydown(event);
  };

  /**
   * Handle double click.
   *
   * @param {object} event The key down event.
   */
  this.dblclick = function (event) {
    var layerDetails = dwv.gui.getLayerDetailsFromEvent(event);
    var layerGroup = app.getLayerGroupByDivId(layerDetails.groupDivId);
    var viewController =
      layerGroup.getActiveViewLayer().getViewController();
    viewController.play();
  };

  /**
   * Displays a tooltip in a temparary `span`.
   * Works with css to hide/show the span only on mouse hover.
   *
   * @param {object} event The mouse move event.
   */
  function showTooltip(event) {
    // remove previous div
    removeTooltipDiv();

    // get image value at position
    var layerDetails = dwv.gui.getLayerDetailsFromEvent(event);
    var layerGroup = app.getLayerGroupByDivId(layerDetails.groupDivId);
    var viewLayer = layerGroup.getActiveViewLayer();
    var viewController = viewLayer.getViewController();
    var planePos = viewLayer.displayToPlanePos(event._x, event._y);
    var position = viewController.getPositionFromPlanePoint(
      planePos.x, planePos.y);
    var value = viewController.getRescaledImageValue(position);

    // create
    if (typeof value !== 'undefined') {
      var span = document.createElement('span');
      span.id = 'scroll-tooltip';
      // place span in layer group to avoid upper layer opacity
      var layerDiv = document.getElementById(viewLayer.getId());
      layerDiv.parentElement.appendChild(span);
      // position tooltip
      span.style.left = (event._x + 10) + 'px';
      span.style.top = (event._y + 10) + 'px';
      var text = dwv.utils.precisionRound(value, 3);
      if (typeof viewController.getPixelUnit() !== 'undefined') {
        text += ' ' + viewController.getPixelUnit();
      }
      span.appendChild(document.createTextNode(text));
    }
  }

  /**
   * Remove the tooltip html div.
   */
  function removeTooltipDiv() {
    var div = document.getElementById('scroll-tooltip');
    if (div) {
      div.remove();
    }
  }

  /**
   * Activate the tool.
   *
   * @param {boolean} _bool The flag to activate or not.
   */
  this.activate = function (_bool) {
    // remove tooltip html when deactivating
    if (!_bool) {
      removeTooltipDiv();
    }
  };

  /**
   * Set the tool live features: disaply tooltip.
   *
   * @param {object} features The list of features.
   */
  this.setFeatures = function (features) {
    if (typeof features.displayTooltip !== 'undefined') {
      displayTooltip = features.displayTooltip;
    }
  };

  /**
   * Initialise the tool.
   */
  this.init = function () {
    // does nothing
  };

}; // Scroll class

// namespaces
var dwv = dwv || {};
dwv.tool = dwv.tool || {};

/**
 * Scroll wheel class: provides a wheel event handler
 *   that scroll the corresponding data.
 *
 * @class
 * @param {dwv.App} app The associated application.
 */
dwv.tool.ScrollWheel = function (app) {
  /**
   * Accumulated wheel event deltaY.
   *
   * @type {number}
   */
  var wheelDeltaY = 0;

  /**
   * Handle mouse wheel event.
   *
   * @param {object} event The mouse wheel event.
   */
  this.wheel = function (event) {
    // deltaMode (deltaY values on my machine...):
    // - 0 (DOM_DELTA_PIXEL): chrome, deltaY mouse scroll = 53
    // - 1 (DOM_DELTA_LINE): firefox, deltaY mouse scroll = 6
    // - 2 (DOM_DELTA_PAGE): ??
    // TODO: check scroll event
    var scrollMin = 52;
    if (event.deltaMode === 1) {
      scrollMin = 5.99;
    }
    wheelDeltaY += event.deltaY;
    if (Math.abs(wheelDeltaY) < scrollMin) {
      return;
    } else {
      wheelDeltaY = 0;
    }

    var up = event.deltaY < 0 ? true : false;

    var layerDetails = dwv.gui.getLayerDetailsFromEvent(event);
    var layerGroup = app.getLayerGroupByDivId(layerDetails.groupDivId);
    var viewController =
      layerGroup.getActiveViewLayer().getViewController();
    var imageSize = viewController.getImageSize();
    if (imageSize.canScroll3D()) {
      if (up) {
        viewController.incrementScrollIndex();
      } else {
        viewController.decrementScrollIndex();
      }
    } else if (imageSize.moreThanOne(3)) {
      if (up) {
        viewController.incrementIndex(3);
      } else {
        viewController.decrementIndex(3);
      }
    }
  };
}; // ScrollWheel class

// namespaces
var dwv = dwv || {};
dwv.tool = dwv.tool || {};

/**
 * UndoStack class.
 *
 * @class
 */
dwv.tool.UndoStack = function () {
  /**
   * Array of commands.
   *
   * @private
   * @type {Array}
   */
  var stack = [];

  /**
   * Current command index.
   *
   * @private
   * @type {number}
   */
  var curCmdIndex = 0;

  /**
   * Listener handler.
   *
   * @type {object}
   * @private
   */
  var listenerHandler = new dwv.utils.ListenerHandler();

  /**
   * Get the stack size.
   *
   * @returns {number} The size of the stack.
   */
  this.getStackSize = function () {
    return stack.length;
  };

  /**
   * Get the current stack index.
   *
   * @returns {number} The stack index.
   */
  this.getCurrentStackIndex = function () {
    return curCmdIndex;
  };

  /**
   * Add a command to the stack.
   *
   * @param {object} cmd The command to add.
   * @fires dwv.tool.UndoStack#undoadd
   */
  this.add = function (cmd) {
    // clear commands after current index
    stack = stack.slice(0, curCmdIndex);
    // store command
    stack.push(cmd);
    // increment index
    ++curCmdIndex;
    /**
     * Command add to undo stack event.
     *
     * @event dwv.tool.UndoStack#undoadd
     * @type {object}
     * @property {string} command The name of the command added to the
     *   undo stack.
     */
    fireEvent({
      type: 'undoadd',
      command: cmd.getName()
    });
  };

  /**
   * Undo the last command.
   *
   * @fires dwv.tool.UndoStack#undo
   */
  this.undo = function () {
    // a bit inefficient...
    if (curCmdIndex > 0) {
      // decrement command index
      --curCmdIndex;
      // undo last command
      stack[curCmdIndex].undo();
      /**
       * Command undo event.
       *
       * @event dwv.tool.UndoStack#undo
       * @type {object}
       * @property {string} command The name of the undone command.
       */
      fireEvent({
        type: 'undo',
        command: stack[curCmdIndex].getName()
      });
    }
  };

  /**
   * Redo the last command.
   *
   * @fires dwv.tool.UndoStack#redo
   */
  this.redo = function () {
    if (curCmdIndex < stack.length) {
      // run last command
      stack[curCmdIndex].execute();
      /**
       * Command redo event.
       *
       * @event dwv.tool.UndoStack#redo
       * @type {object}
       * @property {string} command The name of the redone command.
       */
      fireEvent({
        type: 'redo',
        command: stack[curCmdIndex].getName()
      });
      // increment command index
      ++curCmdIndex;
    }
  };

  /**
   * Add an event listener to this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *    event type, will be called with the fired event.
   */
  this.addEventListener = function (type, callback) {
    listenerHandler.add(type, callback);
  };
  /**
   * Remove an event listener from this class.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type.
   */
  this.removeEventListener = function (type, callback) {
    listenerHandler.remove(type, callback);
  };
  /**
   * Fire an event: call all associated listeners with the input event object.
   *
   * @param {object} event The event to fire.
   * @private
   */
  function fireEvent(event) {
    listenerHandler.fireEvent(event);
  }

}; // UndoStack class

// namespaces
var dwv = dwv || {};
dwv.tool = dwv.tool || {};

/**
 * WindowLevel tool: handle window/level related events.
 *
 * @class
 * @param {dwv.App} app The associated application.
 * @example
 * // create the dwv app
 * var app = new dwv.App();
 * // initialise
 * app.init({
 *   dataViewConfigs: {'*': [{divId: 'layerGroup0'}]},
 *   tools: {WindowLevel: {}}
 * });
 * // activate tool
 * app.addEventListener('load', function () {
 *   app.setTool('WindowLevel');
 * });
 * // load dicom data
 * app.loadURLs([
 *   'https://raw.githubusercontent.com/ivmartel/dwv/master/tests/data/bbmri-53323851.dcm'
 * ]);
 */
dwv.tool.WindowLevel = function (app) {
  /**
   * Closure to self: to be used by event handlers.
   *
   * @private
   * @type {dwv.tool.WindowLevel}
   */
  var self = this;
  /**
   * Interaction start flag.
   *
   * @type {boolean}
   */
  this.started = false;

  /**
   * Scroll wheel handler.
   *
   * @type {dwv.tool.ScrollWheel}
   */
  var scrollWhell = new dwv.tool.ScrollWheel(app);

  /**
   * Handle mouse down event.
   *
   * @param {object} event The mouse down event.
   */
  this.mousedown = function (event) {
    // set start flag
    self.started = true;
    // store initial position
    self.x0 = event._x;
    self.y0 = event._y;
  };

  /**
   * Handle mouse move event.
   *
   * @param {object} event The mouse move event.
   */
  this.mousemove = function (event) {
    // check start flag
    if (!self.started) {
      return;
    }

    var layerDetails = dwv.gui.getLayerDetailsFromEvent(event);
    var layerGroup = app.getLayerGroupByDivId(layerDetails.groupDivId);
    var viewController =
      layerGroup.getActiveViewLayer().getViewController();

    // difference to last position
    var diffX = event._x - self.x0;
    var diffY = self.y0 - event._y;
    // data range
    var range = viewController.getImageRescaledDataRange();
    // 1/1000 seems to give reasonable results...
    var pixelToIntensity = (range.max - range.min) * 0.01;

    // calculate new window level
    var center = parseInt(viewController.getWindowLevel().center, 10);
    var width = parseInt(viewController.getWindowLevel().width, 10);
    var windowCenter = center + Math.round(diffY * pixelToIntensity);
    var windowWidth = width + Math.round(diffX * pixelToIntensity);
    // bound window width
    windowWidth = dwv.image.validateWindowWidth(windowWidth);

    // add the manual preset to the view
    viewController.addWindowLevelPresets({
      manual: {
        wl: [new dwv.image.WindowLevel(windowCenter, windowWidth)],
        name: 'manual'
      }
    });
    viewController.setWindowLevelPreset('manual');

    // store position
    self.x0 = event._x;
    self.y0 = event._y;
  };

  /**
   * Handle mouse up event.
   *
   * @param {object} _event The mouse up event.
   */
  this.mouseup = function (_event) {
    // set start flag
    if (self.started) {
      self.started = false;
    }
  };

  /**
   * Handle mouse out event.
   *
   * @param {object} event The mouse out event.
   */
  this.mouseout = function (event) {
    // treat as mouse up
    self.mouseup(event);
  };

  /**
   * Handle touch start event.
   *
   * @param {object} event The touch start event.
   */
  this.touchstart = function (event) {
    self.mousedown(event);
  };

  /**
   * Handle touch move event.
   *
   * @param {object} event The touch move event.
   */
  this.touchmove = function (event) {
    self.mousemove(event);
  };

  /**
   * Handle touch end event.
   *
   * @param {object} event The touch end event.
   */
  this.touchend = function (event) {
    self.mouseup(event);
  };

  /**
   * Handle double click event.
   *
   * @param {object} event The double click event.
   */
  this.dblclick = function (event) {
    var layerDetails = dwv.gui.getLayerDetailsFromEvent(event);
    var layerGroup = app.getLayerGroupByDivId(layerDetails.groupDivId);
    var viewLayer = layerGroup.getActiveViewLayer();
    var index = viewLayer.displayToPlaneIndex(event._x, event._y);
    var viewController = viewLayer.getViewController();
    var image = app.getImage(viewLayer.getDataIndex());

    // update view controller
    viewController.setWindowLevel(
      parseInt(image.getRescaledValueAtIndex(
        viewController.getCurrentIndex().getWithNew2D(
          index.get(0),
          index.get(1)
        )
      ), 10),
      parseInt(viewController.getWindowLevel().width, 10));
  };

  /**
   * Handle mouse wheel event.
   *
   * @param {object} event The mouse wheel event.
   */
  this.wheel = function (event) {
    scrollWhell.wheel(event);
  };

  /**
   * Handle key down event.
   *
   * @param {object} event The key down event.
   */
  this.keydown = function (event) {
    event.context = 'dwv.tool.WindowLevel';
    app.onKeydown(event);
  };

  /**
   * Activate the tool.
   *
   * @param {boolean} _bool The flag to activate or not.
   */
  this.activate = function (_bool) {
    // does nothing
  };

  /**
   * Initialise the tool.
   */
  this.init = function () {
    // does nothing
  };

}; // WindowLevel class

// namespaces
var dwv = dwv || {};
dwv.tool = dwv.tool || {};

/**
 * ZoomAndPan class.
 *
 * @class
 * @param {dwv.App} app The associated application.
 * @example
 * // create the dwv app
 * var app = new dwv.App();
 * // initialise
 * app.init({
 *   dataViewConfigs: {'*': [{divId: 'layerGroup0'}]},
 *   tools: {ZoomAndPan: {}}
 * });
 * // activate tool
 * app.addEventListener('load', function () {
 *   app.setTool('ZoomAndPan');
 * });
 * // load dicom data
 * app.loadURLs([
 *   'https://raw.githubusercontent.com/ivmartel/dwv/master/tests/data/bbmri-53323851.dcm'
 * ]);
 */
dwv.tool.ZoomAndPan = function (app) {
  /**
   * Closure to self: to be used by event handlers.
   *
   * @private
   * @type {object}
   */
  var self = this;
  /**
   * Interaction start flag.
   *
   * @type {boolean}
   */
  this.started = false;

  /**
   * Handle mouse down event.
   *
   * @param {object} event The mouse down event.
   */
  this.mousedown = function (event) {
    self.started = true;
    // first position
    self.x0 = event._x;
    self.y0 = event._y;
  };

  /**
   * Handle two touch down event.
   *
   * @param {object} event The touch down event.
   */
  this.twotouchdown = function (event) {
    self.started = true;
    // store first point
    self.x0 = event._x;
    self.y0 = event._y;
    // first line
    var point0 = new dwv.math.Point2D(event._x, event._y);
    var point1 = new dwv.math.Point2D(event._x1, event._y1);
    self.line0 = new dwv.math.Line(point0, point1);
    self.midPoint = self.line0.getMidpoint();
  };

  /**
   * Handle mouse move event.
   *
   * @param {object} event The mouse move event.
   */
  this.mousemove = function (event) {
    if (!self.started) {
      return;
    }
    // calculate translation
    var tx = event._x - self.x0;
    var ty = event._y - self.y0;
    // apply translation
    var layerDetails = dwv.gui.getLayerDetailsFromEvent(event);
    var layerGroup = app.getLayerGroupByDivId(layerDetails.groupDivId);
    var viewLayer = layerGroup.getActiveViewLayer();
    var viewController = viewLayer.getViewController();
    var planeOffset = viewLayer.displayToPlaneScale(tx, ty);
    var offset3D = viewController.getOffset3DFromPlaneOffset(planeOffset);
    layerGroup.addTranslation({
      x: offset3D.getX(),
      y: offset3D.getY(),
      z: offset3D.getZ()
    });
    layerGroup.draw();
    // reset origin point
    self.x0 = event._x;
    self.y0 = event._y;
  };

  /**
   * Handle two touch move event.
   *
   * @param {object} event The touch move event.
   */
  this.twotouchmove = function (event) {
    if (!self.started) {
      return;
    }
    var point0 = new dwv.math.Point2D(event._x, event._y);
    var point1 = new dwv.math.Point2D(event._x1, event._y1);
    var newLine = new dwv.math.Line(point0, point1);
    var lineRatio = newLine.getLength() / self.line0.getLength();

    var layerDetails = dwv.gui.getLayerDetailsFromEvent(event);
    var layerGroup = app.getLayerGroupByDivId(layerDetails.groupDivId);
    var viewLayer = layerGroup.getActiveViewLayer();
    var viewController = viewLayer.getViewController();

    if (lineRatio === 1) {
      // scroll mode
      // difference  to last position
      var diffY = event._y - self.y0;
      // do not trigger for small moves
      if (Math.abs(diffY) < 15) {
        return;
      }
      var imageSize = viewController.getImageSize();
      // update view controller
      if (imageSize.canScroll(2)) {
        if (diffY > 0) {
          viewController.incrementIndex(2);
        } else {
          viewController.decrementIndex(2);
        }
      }
    } else {
      // zoom mode
      var zoom = (lineRatio - 1) / 10;
      if (Math.abs(zoom) % 0.1 <= 0.05) {
        var planePos = viewLayer.displayToMainPlanePos(
          self.midPoint.getX(), self.midPoint.getY());
        var center = viewController.getPlanePositionFromPlanePoint(planePos);
        layerGroup.addScale(zoom, center);
        layerGroup.draw();
      }
    }
  };

  /**
   * Handle mouse up event.
   *
   * @param {object} _event The mouse up event.
   */
  this.mouseup = function (_event) {
    if (self.started) {
      // stop recording
      self.started = false;
    }
  };

  /**
   * Handle mouse out event.
   *
   * @param {object} event The mouse out event.
   */
  this.mouseout = function (event) {
    self.mouseup(event);
  };

  /**
   * Handle touch start event.
   *
   * @param {object} event The touch start event.
   */
  this.touchstart = function (event) {
    var touches = event.targetTouches;
    if (touches.length === 1) {
      self.mousedown(event);
    } else if (touches.length === 2) {
      self.twotouchdown(event);
    }
  };

  /**
   * Handle touch move event.
   *
   * @param {object} event The touch move event.
   */
  this.touchmove = function (event) {
    var touches = event.targetTouches;
    if (touches.length === 1) {
      self.mousemove(event);
    } else if (touches.length === 2) {
      self.twotouchmove(event);
    }
  };

  /**
   * Handle touch end event.
   *
   * @param {object} event The touch end event.
   */
  this.touchend = function (event) {
    self.mouseup(event);
  };

  /**
   * Handle mouse wheel event.
   *
   * @param {object} event The mouse wheel event.
   */
  this.wheel = function (event) {
    var step = -event.deltaY / 500;

    var layerDetails = dwv.gui.getLayerDetailsFromEvent(event);
    var layerGroup = app.getLayerGroupByDivId(layerDetails.groupDivId);
    var viewLayer = layerGroup.getActiveViewLayer();
    var viewController = viewLayer.getViewController();
    var planePos = viewLayer.displayToMainPlanePos(event._x, event._y);
    var center = viewController.getPlanePositionFromPlanePoint(planePos);
    layerGroup.addScale(step, center);
    layerGroup.draw();
  };

  /**
   * Handle key down event.
   *
   * @param {object} event The key down event.
   */
  this.keydown = function (event) {
    event.context = 'dwv.tool.ZoomAndPan';
    app.onKeydown(event);
  };

  /**
   * Activate the tool.
   *
   * @param {boolean} _bool The flag to activate or not.
   */
  this.activate = function (_bool) {
    // does nothing
  };

}; // ZoomAndPan class

/**
 * Initialise the tool.
 */
dwv.tool.ZoomAndPan.prototype.init = function () {
  // does nothing
};

// namespaces
var dwv = dwv || {};
dwv.utils = dwv.utils || {};

/**
 * Check for array equality after sorting.
 *
 * @param {Array} arr0 First array.
 * @param {*} arr1 Second array.
 * @returns {boolean} True if both array are defined and contain same values.
 */
dwv.utils.arraySortEquals = function (arr0, arr1) {
  if (arr0 === null ||
    arr1 === null ||
    typeof arr0 === 'undefined' ||
    typeof arr1 === 'undefined') {
    return false;
  }
  var arr0sorted = arr0.slice().sort();
  var arr1sorted = arr1.slice().sort();
  return dwv.utils.arrayEquals(arr0sorted, arr1sorted);
};

/**
 * Check for array equality.
 *
 * @param {Array} arr0 First array.
 * @param {*} arr1 Second array.
 * @returns {boolean} True if both array are defined and contain same values.
 */
dwv.utils.arrayEquals = function (arr0, arr1) {
  if (arr0 === null ||
    arr1 === null ||
    typeof arr0 === 'undefined' ||
    typeof arr1 === 'undefined') {
    return false;
  }
  if (arr0.length !== arr1.length) {
    return false;
  }
  return arr0.every(function (element, index) {
    return element === arr1[index];
  });
};

/**
 * Convert a Uint8Array to a string.
 *
 * @param {Uint8Array} arr The array to convert.
 * @returns {string} The array as string.
 */
dwv.utils.uint8ArrayToString = function (arr) {
  return String.fromCharCode.apply(String, arr);
};

/**
 * Array find in a subset of the input array.
 * Equivalent to: arr.slice(start, end).find(callbackFn)
 *
 * @param {Array} arr The input array to search.
 * @param {Function} callbackFn The find function.
 * @param {number} start The array start index.
 * @param {number} end The array end index.
 * @returns {number|undefined} The index where the element was found.
 */
dwv.utils.findInArraySubset = function (arr, callbackFn, start, end) {
  // check inputs
  if (typeof start === 'undefined' ||
    start < 0 ||
    start >= arr.length
  ) {
    start = 0;
  }
  if (typeof end === 'undefined' ||
    end <= start ||
    end > arr.length) {
    end = arr.length;
  }
  // run
  for (var i = start; i < end; ++i) {
    if (callbackFn(arr[i], i, arr)) {
      return i;
    }
  }
  return undefined;
};

/**
 * Get a find in array callback.
 *
 * @param {Array} arr1 The array to find.
 * @returns {Function} The find callback function.
 */
dwv.utils.getFindArrayInArrayCallback = function (arr1) {
  return function (element, index, arr0) {
    for (var i = 0; i < arr1.length; ++i) {
      if (arr0[index + i] !== arr1[i]) {
        return false;
      }
    }
    return true;
  };
};

/**
 * Extract each element of a multipart ArrayBuffer.
 * https://en.wikipedia.org/wiki/MIME#Multipart_messages
 *
 * @param {ArrayBuffer} arr The multipart array.
 * @returns {Array} The multipart parts as an array of object as
 *  {'Content-Type', ..., data} (depending on header tags)
 */
dwv.utils.parseMultipart = function (arr) {
  var u8Array = new Uint8Array(arr);

  var parts = [];
  // check input
  if (u8Array.length === 0) {
    return parts;
  }

  // \r\n\r\n
  var doubleReturnNew = new Uint8Array([0x0d, 0x0a, 0x0d, 0x0a]);
  var partHeaderEndCb = dwv.utils.getFindArrayInArrayCallback(doubleReturnNew);

  // look for boundary in first part header
  var partHeaderEndIndex = dwv.utils.findInArraySubset(
    u8Array, partHeaderEndCb, 0
  );
  if (typeof partHeaderEndIndex === 'undefined') {
    throw new Error('Can\'t find the end of the first multipart header');
  }
  var firstPartHeader = u8Array.slice(0, partHeaderEndIndex);
  // switch to string to use split
  var lines = dwv.utils.uint8ArrayToString(firstPartHeader).split('\r\n');
  // boundary should start with '--'
  var boundaryStr;
  for (var i = 0; i < lines.length; ++i) {
    if (lines[i][0] === '-' && lines[i][1] === '-') {
      boundaryStr = lines[i];
      break;
    }
  }
  if (typeof boundaryStr === 'undefined') {
    throw new Error('Can\'t find the boundary between multi-parts');
  }
  var boundary = dwv.utils.stringToUint8Array(boundaryStr);
  var boundaryCb = dwv.utils.getFindArrayInArrayCallback(boundary);
  var boundaryLen = boundaryStr.length;

  // skip mime header
  var nextBoundaryIndex = dwv.utils.findInArraySubset(
    u8Array, boundaryCb, 0
  );

  // loop through content
  while (typeof partHeaderEndIndex !== 'undefined') {
    var part = {};

    // header
    var partHeader = u8Array.slice(
      nextBoundaryIndex + boundaryLen, partHeaderEndIndex);
    // split into object
    var partHeaderLines =
      dwv.utils.uint8ArrayToString(partHeader).split('\r\n');
    for (var l = 0; l < partHeaderLines.length; ++l) {
      var line = partHeaderLines[l];
      var semiColonIndex = line.indexOf(':');
      if (semiColonIndex !== -1) {
        var key = line.substring(0, semiColonIndex).trim();
        var val = line.substring(semiColonIndex + 1).trim();
        part[key] = val;
      }
    }

    // find next boundary
    nextBoundaryIndex = dwv.utils.findInArraySubset(
      u8Array, boundaryCb, partHeaderEndIndex
    );
    // exit if none
    if (typeof nextBoundaryIndex === 'undefined') {
      break;
    }

    // get part
    // partHeaderEndIndex plus the size of the '\r\n\r\n' separator
    var dataBeginIndex = partHeaderEndIndex + 4;
    // nextBoundaryIndex minus the previous '\r\n'
    var dataEndIndex = nextBoundaryIndex - 2;
    if (dataBeginIndex < dataEndIndex) {
      part.data = u8Array.slice(dataBeginIndex, dataEndIndex).buffer;
    } else {
      part.data = new Uint8Array();
    }

    // store part
    parts.push(part);

    // find next part header end
    partHeaderEndIndex = dwv.utils.findInArraySubset(
      u8Array, partHeaderEndCb,
      nextBoundaryIndex + boundaryLen
    );
  }

  return parts;
};

/**
 * Build a multipart message.
 * See: https://en.wikipedia.org/wiki/MIME#Multipart_messages
 * See: https://hg.orthanc-server.com/orthanc-dicomweb/file/tip/Resources/Samples/JavaScript/stow-rs.js
 *
 * @param {Array} parts The message parts as an array of object containing
 *   content headers and messages as the data property (as returned by parse).
 * @param {string} boundary The message boundary.
 * @returns {Uint8Array} The full multipart message.
 */
dwv.utils.buildMultipart = function (parts, boundary) {
  var lineBreak = '\r\n';
  // build headers and calculate size
  var partsSize = 0;
  var headers = [];
  for (var i = 0; i < parts.length; ++i) {
    var headerStr = '';
    if (i !== 0) {
      headerStr += lineBreak;
    }
    headerStr += '--' + boundary + lineBreak;
    var partKeys = Object.keys(parts[i]);
    for (var k = 0; k < partKeys.length; ++k) {
      var key = partKeys[k];
      if (key !== 'data') {
        headerStr += key + ': ' + parts[i][key] + lineBreak;
      }
    }
    headerStr += lineBreak;
    var header = dwv.utils.stringToUint8Array(headerStr);
    headers.push(header);
    partsSize += header.byteLength + parts[i].data.byteLength;
  }
  // build trailer
  var trailerStr = lineBreak + '--' + boundary + '--' + lineBreak;
  var trailer = dwv.utils.stringToUint8Array(trailerStr);

  // final buffer
  var buffer = new Uint8Array(partsSize + trailer.byteLength);
  var offset = 0;
  // concatenate parts
  for (var j = 0; j < parts.length; ++j) {
    buffer.set(headers[j], offset);
    offset += headers[j].byteLength;
    buffer.set(new Uint8Array(parts[j].data), offset);
    offset += parts[j].data.byteLength;
  }
  // end buffer with trailer
  buffer.set(trailer, offset);

  // return
  return buffer;
};

// namespaces
var dwv = dwv || {};
dwv.utils = dwv.utils || {};

// example implementation: dcmtk/dcmiod/libsrc/cielabutil.cc
// https://github.com/DCMTK/dcmtk/blob/DCMTK-3.6.6/dcmiod/libsrc/cielabutil.cc

/**
 * Check if two rgb objects are equal.
 *
 * @param {object} c1 The first colour.
 * @param {object} c2 The second colour.
 * @returns {boolean} True if both colour are equal.
 */
dwv.utils.isEqualRgb = function (c1, c2) {
  return c1 !== null &&
    c2 !== null &&
    typeof c1 !== 'undefined' &&
    typeof c2 !== 'undefined' &&
    c1.r === c2.r &&
    c1.g === c2.g &&
    c1.b === c2.b;
};

/**
 * Convert YBR to RGB.
 *
 * @see http://dicom.nema.org/dicom/2013/output/chtml/part03/sect_C.7.html#sect_C.7.6.3.1.2
 * @see https://en.wikipedia.org/wiki/YCbCr#JPEG_conversion
 * @param {number} y The Y component.
 * @param {number} cb The Cb component.
 * @param {number} cr The Cr component.
 * @returns {object} RGB equivalent as {r,g,b}.
 */
dwv.utils.ybrToRgb = function (y, cb, cr) {
  return {
    r: y + 1.402 * (cr - 128),
    g: y - 0.34414 * (cb - 128) - 0.71414 * (cr - 128),
    b: y + 1.772 * (cb - 128)
  };
};

/**
 * Convert a hex color into RGB.
 *
 * @param {string} hexStr The hex color as '#ab01ef'.
 * @returns {object} The RGB values as {r,g,b}.
 */
dwv.utils.hexToRgb = function (hexStr) {
  return {
    r: parseInt(hexStr.substring(1, 3), 16),
    g: parseInt(hexStr.substring(3, 5), 16),
    b: parseInt(hexStr.substring(5, 7), 16)
  };
};

/**
 * Convert RGB to its hex equivalent.
 *
 * @param {object} rgb The RGB object as {r,g,b}.
 * @returns {string} A string representing the hex color as '#ab01ef'.
 */
dwv.utils.rgbToHex = function (rgb) {
  return '#' +
    ((1 << 24) + (rgb.r << 16) + (rgb.g << 8) + rgb.b).toString(16).slice(1);
};

/**
 * Get the brightness of a RGB colour: calculates
 * the luma (Y) of the YIQ colour space.
 *
 * @see https://en.wikipedia.org/wiki/YIQ#From_RGB_to_YIQ
 * @param {object} rgbTriplet RGB triplet.
 * @returns {number} The brightness ([0,1]).
 */
dwv.utils.getBrightness = function (rgbTriplet) {
  // 0.001172549 = 0.299 / 255
  // 0.002301961 = 0.587 / 255
  // 0.000447059 = 0.114 / 255
  return rgbTriplet.r * 0.001172549 +
    rgbTriplet.g * 0.002301961 +
    rgbTriplet.b * 0.000447059;
};

/**
 * Check if a colour given in hexadecimal format is dark.
 *
 * @param {string} hexColour The colour (as '#ab01ef').
 * @returns {boolean} True if the colour is dark (brightness < 0.5).
 */
dwv.utils.isDarkColour = function (hexColour) {
  return dwv.utils.getBrightness(dwv.utils.hexToRgb(hexColour)) < 0.5;
};

/**
 * Get the shadow colour of an input colour.
 *
 * @param {string} hexColour The colour (as '#ab01ef').
 * @returns {string} The shadow colour (white or black).
 */
dwv.utils.getShadowColour = function (hexColour) {
  return dwv.utils.isDarkColour(hexColour) ? '#fff' : '#000';
};

/**
 * Unsigned int CIE LAB value ([0, 65535]) to CIE LAB value
 *   (L: [0, 100], a: [-128, 127], b: [-128, 127]).
 *
 * @param {object} triplet CIE LAB triplet as {l,a,b} with unsigned range.
 * @returns {object} CIE LAB triplet as {l,a,b} with CIE LAB range.
 */
dwv.utils.uintLabToLab = function (triplet) {
  // 0.001525902 = 100 / 65535
  // 0.003891051 = 255 / 65535
  return {
    l: 0.001525902 * triplet.l,
    a: 0.003891051 * triplet.a - 128,
    b: 0.003891051 * triplet.b - 128,
  };
};

/**
 * CIE LAB value (L: [0, 100], a: [-128, 127], b: [-128, 127]) to
 *   unsigned int CIE LAB ([0, 65535]).
 *
 * @param {object} triplet CIE XYZ triplet as {x,y,z} with CIE LAB range.
 * @returns {object} CIE LAB triplet as {l,a,b} with unsigned range.
 */
dwv.utils.labToUintLab = function (triplet) {
  // 655.35 = 65535 / 100
  // aUint = (a + 128) * 65535 / 255
  // 257 = 65535 / 255
  // 32896 = 257 * 128
  return {
    l: 655.35 * triplet.l,
    a: 257 * triplet.a + 32896,
    b: 257 * triplet.b + 32896,
  };
};

/**
 * CIE Standard Illuminant D65, standard 2° observer.
 *
 * @see https://en.wikipedia.org/wiki/Illuminant_D65
 */
dwv.utils.d65 = {
  x: 95.0489,
  y: 100,
  z: 108.884
};

/**
 * Convert CIE LAB to CIE XYZ (standard illuminant D65, 2degree 1931).
 *
 * @see https://en.wikipedia.org/wiki/CIELAB_color_space#From_CIELAB_to_CIEXYZ
 * @param {object} triplet CIE LAB triplet as {l,a,b}.
 * @returns {object} CIE XYZ triplet as {x,y,z}.
 */
dwv.utils.cielabToCiexyz = function (triplet) {
  var invLabFunc = function (x) {
    var res = null;
    // delta = 6 / 29 = 0.206896552
    if (x > 0.206896552) {
      res = Math.pow(x, 3);
    } else {
      // 0.128418549 = 3 * delta^2
      // 0.017712903 = 3 * delta^2 * (4 / 29)
      res = 0.128418549 * x - 0.017712903;
    }
    return res;
  };

  var illuminant = dwv.utils.d65;
  var l0 = (triplet.l + 16) / 116;

  return {
    x: illuminant.x * invLabFunc(l0 + triplet.a / 500),
    y: illuminant.y * invLabFunc(l0),
    z: illuminant.z * invLabFunc(l0 - triplet.b / 200)
  };
};

/**
 * Convert CIE XYZ to CIE LAB (standard illuminant D65, 2degree 1931).
 *
 * @see https://en.wikipedia.org/wiki/CIELAB_color_space#From_CIEXYZ_to_CIELAB
 * @param {object} triplet CIE XYZ triplet as {x,y,z}.
 * @returns {object} CIE LAB triplet as {l,a,b}.
 */
dwv.utils.ciexyzToCielab = function (triplet) {
  var labFunc = function (x) {
    var res = null;
    // delta = 6 / 29 = 0.206896552
    // delta^3 = 0.008856452
    if (x > 0.008856452) {
      res = Math.pow(x, 0.333333333);
    } else {
      // 7.787037037 = 1 / 3 * delta^2
      // 0.137931034 = 4 / 29
      res = 7.787037037 * x + 0.137931034;
    }
    return res;
  };

  var illuminant = dwv.utils.d65;
  var fy = labFunc(triplet.y / illuminant.y);

  return {
    l: 116 * fy - 16,
    a: 500 * (labFunc(triplet.x / illuminant.x) - fy),
    b: 200 * (fy - labFunc(triplet.z / illuminant.z))
  };
};

/**
 * Convert CIE XYZ to sRGB.
 *
 * @see https://en.wikipedia.org/wiki/SRGB#From_CIE_XYZ_to_sRGB
 * @param {object} triplet CIE XYZ triplet as {x,y,z}.
 * @returns {object} sRGB triplet as {r,g,b}.
 */
dwv.utils.ciexyzToSrgb = function (triplet) {
  var gammaFunc = function (x) {
    var res = null;
    if (x <= 0.0031308) {
      res = 12.92 * x;
    } else {
      // 0.416666667 = 1 / 2.4
      res = 1.055 * Math.pow(x, 0.416666667) - 0.055;
    }
    // clip [0,1]
    return Math.min(1, Math.max(0, res));
  };

  var x = triplet.x / 100;
  var y = triplet.y / 100;
  var z = triplet.z / 100;

  return {
    r: Math.round(255 * gammaFunc(3.2406 * x - 1.5372 * y - 0.4986 * z)),
    g: Math.round(255 * gammaFunc(-0.9689 * x + 1.8758 * y + 0.0415 * z)),
    b: Math.round(255 * gammaFunc(0.0557 * x - 0.2040 * y + 1.0570 * z))
  };
};

/**
 * Convert sRGB to CIE XYZ.
 *
 * @see https://en.wikipedia.org/wiki/SRGB#From_sRGB_to_CIE_XYZ
 * @param {object} triplet sRGB triplet as {r,g,b}.
 * @returns {object} CIE XYZ triplet as {x,y,z}.
 */
dwv.utils.srgbToCiexyz = function (triplet) {
  var invGammaFunc = function (x) {
    var res = null;
    if (x <= 0.04045) {
      res = x / 12.92;
    } else {
      res = Math.pow((x + 0.055) / 1.055, 2.4);
    }
    return res;
  };

  var rl = invGammaFunc(triplet.r / 255);
  var gl = invGammaFunc(triplet.g / 255);
  var bl = invGammaFunc(triplet.b / 255);

  return {
    x: 100 * (0.4124 * rl + 0.3576 * gl + 0.1805 * bl),
    y: 100 * (0.2126 * rl + 0.7152 * gl + 0.0722 * bl),
    z: 100 * (0.0193 * rl + 0.1192 * gl + 0.9505 * bl)
  };
};

/**
 * Convert CIE LAB to sRGB (standard illuminant D65).
 *
 * @param {object} triplet CIE LAB triplet as {l,a,b}.
 * @returns {object} sRGB triplet as {r,g,b}.
 */
dwv.utils.cielabToSrgb = function (triplet) {
  return dwv.utils.ciexyzToSrgb(dwv.utils.cielabToCiexyz(triplet));
};

/**
 * Convert sRGB to CIE LAB (standard illuminant D65).
 *
 * @param {object} triplet sRGB triplet as {r,g,b}.
 * @returns {object} CIE LAB triplet as {l,a,b}.
 */
dwv.utils.srgbToCielab = function (triplet) {
  return dwv.utils.ciexyzToCielab(dwv.utils.srgbToCiexyz(triplet));
};

/**
 * Get the hex code of a string colour for a colour used in pre dwv v0.17.
 *
 * @param {string} name The name of a colour.
 * @returns {string} The hex representing the colour.
 */
dwv.utils.colourNameToHex = function (name) {
  // default colours used in dwv version < 0.17
  var dict = {
    Yellow: '#ffff00',
    Red: '#ff0000',
    White: '#ffffff',
    Green: '#008000',
    Blue: '#0000ff',
    Lime: '#00ff00',
    Fuchsia: '#ff00ff',
    Black: '#000000'
  };
  var res = '#ffff00';
  if (typeof dict[name] !== 'undefined') {
    res = dict[name];
  }
  return res;
};

// namespaces
var dwv = dwv || {};
/** @namespace */
dwv.env = dwv.env || {};

/**
 * Local function to ask Modernizr if a property is supported.
 *
 * @param {string} property The property to test.
 * @returns {boolean} True if the env supports the input feature.
 */
dwv.env.askModernizr = function (property) {
  if (typeof dwv.Modernizr === 'undefined') {
    dwv.ModernizrInit(window, document);
  }
  var props = property.split('.');
  var prop = dwv.Modernizr;
  for (var i = 0; i < props.length; ++i) {
    prop = prop[props[i]];
  }
  return prop;
};

/**
 * Browser check for the FileAPI.
 * Assume support for Safari5.
 *
 * @returns {boolean} True if the env supports the feature.
 */
dwv.env.hasFileApi = function () {
  // regular test does not work on Safari 5
  var isSafari5 = (navigator.appVersion.indexOf('Safari') !== -1) &&
    (navigator.appVersion.indexOf('Chrome') === -1) &&
    ((navigator.appVersion.indexOf('5.0.') !== -1) ||
    (navigator.appVersion.indexOf('5.1.') !== -1));
  if (isSafari5) {
    dwv.logger.warn('Assuming FileAPI support for Safari5...');
    return true;
  }
  // regular test
  return dwv.env.askModernizr('filereader');
};

/**
 * Browser check for the XMLHttpRequest.
 *
 * @returns {boolean} True if the env supports the feature.
 */
dwv.env.hasXmlHttpRequest = function () {
  return dwv.env.askModernizr('xhrresponsetype') &&
    dwv.env.askModernizr('xhrresponsetypearraybuffer') &&
    dwv.env.askModernizr('xhrresponsetypetext') &&
    'XMLHttpRequest' in window && 'withCredentials' in new XMLHttpRequest();
};

/**
 * Browser check for typed array.
 *
 * @returns {boolean} True if the env supports the feature.
 */
dwv.env.hasTypedArray = function () {
  return dwv.env.askModernizr('dataview') &&
    dwv.env.askModernizr('typedarrays');
};

/**
 * Browser check for input with type='color'.
 * Missing in IE and Safari.
 *
 * @returns {boolean} True if the env supports the feature.
 */
dwv.env.hasInputColor = function () {
  return dwv.env.askModernizr('inputtypes.color');
};

/**
 * Browser check for input with type='files' and webkitdirectory flag.
 * Missing in IE and Safari.
 *
 * @returns {boolean} True if the env supports the feature.
 */
dwv.env.hasInputDirectory = function () {
  return dwv.env.askModernizr('fileinputdirectory');
};

// only check at startup (since we propose a replacement)
dwv.env._hasTypedArraySlice =
  (typeof Uint8Array.prototype.slice !== 'undefined');

/**
 * Browser check for typed array slice method.
 * Missing in Internet Explorer 11.
 *
 * @returns {boolean} True if the env supports the feature.
 */
dwv.env.hasTypedArraySlice = function () {
  return dwv.env._hasTypedArraySlice;
};

// only check at startup (since we propose a replacement)
dwv.env._hasFloat64Array = ('Float64Array' in window);

/**
 * Browser check for Float64Array array.
 * Missing in PhantomJS 1.9.20 (on Travis).
 *
 * @returns {boolean} True if the env supports the feature.
 */
dwv.env.hasFloat64Array = function () {
  return dwv.env._hasFloat64Array;
};

// only check at startup (since we propose a replacement)
dwv.env._hasClampedArray = ('Uint8ClampedArray' in window);

/**
 * Browser check for clamped array.
 * Missing in:
 * - Safari 5.1.7 for Windows
 * - PhantomJS 1.9.20 (on Travis).
 *
 * @returns {boolean} True if the env supports the feature.
 */
dwv.env.hasClampedArray = function () {
  return dwv.env._hasClampedArray;
};

// Check if the BigInt type is defined
dwv.env._hasBigint = (typeof BigInt !== 'undefined');

/**
 * Browser check for BigInt (associated typed arrays).
 *
 * @returns {boolean} True if the env supports the feature.
 */
dwv.env.hasBigInt = function () {
  return dwv.env._hasBigint;
};

// Check if the TextDecoder is defined
dwv.env._hasTextDecoder = (typeof TextDecoder !== 'undefined');

/**
 * Does the environement provide TextDecoder.
 *
 * @returns {boolean} True if the env supports the feature.
 */
dwv.env.hasTextDecoder = function () {
  return dwv.env._hasTextDecoder;
};

// Check if the TextEncoder is defined
dwv.env._hasTextEncoder = (typeof TextEncoder !== 'undefined');

/**
 * Does the environement provide TextEncoder.
 *
 * @returns {boolean} True if the env supports the feature.
 */
dwv.env.hasTextEncoder = function () {
  return dwv.env._hasTextEncoder;
};

/**
 * Browser checks to see if it can run dwv. Throws an error if not.
 * Silently replaces basic functions.
 */
dwv.env.check = function () {

  // Required --------------

  var message = '';
  // Check for the File API support
  if (!dwv.env.hasFileApi()) {
    message = 'The File APIs are not supported in this browser. ';
    throw new Error(message);
  }
  // Check for XMLHttpRequest
  if (!dwv.env.hasXmlHttpRequest()) {
    message = 'The XMLHttpRequest is not supported in this browser. ';
    throw new Error(message);
  }
  // Check typed array
  if (!dwv.env.hasTypedArray()) {
    message = 'The Typed arrays are not supported in this browser. ';
    throw new Error(message);
  }
  // Check text encoding/decoding
  if (!dwv.env.hasTextDecoder() || !dwv.env.hasTextEncoder()) {
    message = 'Text decoding/encoding is not supported in this browser.';
    throw new Error(message);
  }

  // Check Float64
  if (!dwv.env.hasFloat64Array()) {
    dwv.logger.warn('Float64Array is not supported in this browser. ' +
      'Data including tags with Float64 VR is not supported. ');
  }
  // Check BigInt
  if (!dwv.env.hasBigInt()) {
    dwv.logger.warn('BigInt is not supported in this browser. ' +
      'Data including tags with Int64 and Uint64 VRs is not supported. ');
  }

  // Replaced if not present ------------

  // Check typed array slice
  if (!dwv.env.hasTypedArraySlice()) {
    // silent fail with warning
    dwv.logger.warn(
      'The TypedArray.slice method is not supported in this browser.' +
      ' This may impair performance. ');
    // basic Uint16Array implementation
    Uint16Array.prototype.slice = function (begin, end) {
      var size = end - begin;
      var cloned = new Uint16Array(size);
      for (var i = 0; i < size; i++) {
        cloned[i] = this[begin + i];
      }
      return cloned;
    };
    // basic Int16Array implementation
    Int16Array.prototype.slice = function (begin, end) {
      var size = end - begin;
      var cloned = new Int16Array(size);
      for (var i = 0; i < size; i++) {
        cloned[i] = this[begin + i];
      }
      return cloned;
    };
    // basic Uint8Array implementation
    Uint8Array.prototype.slice = function (begin, end) {
      var size = end - begin;
      var cloned = new Uint8Array(size);
      for (var i = 0; i < size; i++) {
        cloned[i] = this[begin + i];
      }
      return cloned;
    };
    // basic Int8Array implementation
    Int8Array.prototype.slice = function (begin, end) {
      var size = end - begin;
      var cloned = new Int8Array(size);
      for (var i = 0; i < size; i++) {
        cloned[i] = this[begin + i];
      }
      return cloned;
    };
  }
  // check clamped array
  if (!dwv.env.hasClampedArray()) {
    // silent fail with warning
    dwv.logger.warn(
      'The Uint8ClampedArray is not supported in this browser.' +
      ' This may impair performance. ');
    // Use Uint8Array instead... Not good
    // TODO Find better replacement!
    window.Uint8ClampedArray = window.Uint8Array;
  }

  // array Find
  // https://tc39.github.io/ecma262/#sec-array.prototype.find
  if (!Array.prototype.find) {
    Object.defineProperty(Array.prototype, 'find', {
      value: function (predicate) {
        // 1. Let O be ? ToObject(this value).
        if (this === null) {
          throw new TypeError('"this" is null or not defined');
        }

        var o = Object(this);

        // 2. Let len be ? ToLength(? Get(O, "length")).
        var len = o.length >>> 0;

        // 3. If IsCallable(predicate) is false, throw a TypeError exception.
        if (typeof predicate !== 'function') {
          throw new TypeError('predicate must be a function');
        }

        // 4. If thisArg was supplied, let T be thisArg; else let T
        //    be undefined.
        var thisArg = arguments[1];

        // 5. Let k be 0.
        var k = 0;

        // 6. Repeat, while k < len
        while (k < len) {
          // a. Let Pk be ! ToString(k).
          // b. Let kValue be ? Get(O, Pk).
          // c. Let testResult be ToBoolean(? Call(predicate,
          //    T, « kValue, k, O »)).
          // d. If testResult is true, return kValue.
          var kValue = o[k];
          if (predicate.call(thisArg, kValue, k, o)) {
            return kValue;
          }
          // e. Increase k by 1.
          k++;
        }

        // 7. Return undefined.
        return undefined;
      },
      configurable: true,
      writable: true
    });
  }

  // check string startsWith
  if (!String.prototype.startsWith) {
    Object.defineProperty(String.prototype, 'startsWith', {
      value: function (search, rawPos) {
        return dwv.utils.startsWith(this, search, rawPos);
      }
    });
  }
};

// namespaces
var dwv = dwv || {};

/**
 * Get the translated text.
 *
 * @param {string} key The key to the text entry.
 * @param {object} _options The translation options such as plural, context...
 * @returns {string|undefined} The translated text.
 */
dwv.i18n = function (key, _options) {
  // defaut expects something like 'unit.cm2'
  var unit = {
    mm: 'mm',
    cm2: 'cm²',
    degree: '°'
  };
  var props = key.split('.');
  if (props.length !== 2) {
    throw new Error('Unexpected translation key length.');
  }
  if (props[0] !== 'unit') {
    throw new Error('Unexpected translation key prefix.');
  }
  return unit[props[1]];
};

// namespaces
var dwv = dwv || {};
dwv.utils = dwv.utils || {};

/**
 * ListenerHandler class: handles add/removing and firing listeners.
 *
 * @class
 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget#example
 */
dwv.utils.ListenerHandler = function () {
  /**
   * listeners.
   *
   * @private
   */
  var listeners = {};

  /**
   * Add an event listener.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *    event type, will be called with the fired event.
   */
  this.add = function (type, callback) {
    // create array if not present
    if (typeof listeners[type] === 'undefined') {
      listeners[type] = [];
    }
    // add callback to listeners array
    listeners[type].push(callback);
  };

  /**
   * Remove an event listener.
   *
   * @param {string} type The event type.
   * @param {object} callback The method associated with the provided
   *   event type.
   */
  this.remove = function (type, callback) {
    // check if the type is present
    if (typeof listeners[type] === 'undefined') {
      return;
    }
    // remove from listeners array
    for (var i = 0; i < listeners[type].length; ++i) {
      if (listeners[type][i] === callback) {
        listeners[type].splice(i, 1);
      }
    }
  };

  /**
   * Fire an event: call all associated listeners with the input event object.
   *
   * @param {object} event The event to fire.
   */
  this.fireEvent = function (event) {
    // check if they are listeners for the event type
    if (typeof listeners[event.type] === 'undefined') {
      return;
    }
    // fire events from a copy of the listeners array
    // to avoid interference from possible add/remove
    var stack = listeners[event.type].slice();
    for (var i = 0; i < stack.length; ++i) {
      stack[i](event);
    }
  };
};

// namespaces
var dwv = dwv || {};
/** @namespace */
dwv.utils = dwv.utils || {};
/** @namespace */
dwv.utils.logger = dwv.utils.logger || {};
/** @namespace */
dwv.utils.logger.console = dwv.utils.logger.console || {};

/**
 * Main logger namespace. Defaults to the console logger.
 *
 * @see dwv.utils.logger.console
 */
dwv.logger = dwv.utils.logger.console;

/**
 * Available log levels.
 * Note: need to activate verbose level in Chrome console to see DEBUG messages.
 */
dwv.utils.logger.levels = {
  TRACE: 0,
  DEBUG: 1,
  INFO: 2,
  WARN: 3,
  ERROR: 4
};

/**
 * Default console logger.
 */

// console logger default level
dwv.utils.logger.console.level = dwv.utils.logger.levels.WARN;

/**
 * Log a trace message.
 *
 * @param {string} msg The message to log.
 */
dwv.utils.logger.console.trace = function (msg) {
  if (dwv.logger.level <= dwv.utils.logger.levels.TRACE) {
    console.trace(msg);
  }
};

/**
 * Log a debug message.
 * Careful: depends on console settings.
 *
 * @param {string} msg The message to log.
 */
dwv.utils.logger.console.debug = function (msg) {
  if (dwv.logger.level <= dwv.utils.logger.levels.DEBUG) {
    console.debug(msg);
  }
};

/**
 * Log an info message.
 *
 * @param {string} msg The message to log.
 */
dwv.utils.logger.console.info = function (msg) {
  if (dwv.logger.level <= dwv.utils.logger.levels.INFO) {
    console.info(msg);
  }
};

/**
 * Log a warn message.
 *
 * @param {string} msg The message to log.
 */
dwv.utils.logger.console.warn = function (msg) {
  if (dwv.logger.level <= dwv.utils.logger.levels.WARN) {
    console.warn(msg);
  }
};

/**
 * Log an error message.
 *
 * @param {string} msg The message to log.
 */
dwv.utils.logger.console.error = function (msg) {
  if (dwv.logger.level <= dwv.utils.logger.levels.ERROR) {
    console.error(msg);
  }
};

/*eslint-disable */
// namespaces
var dwv = dwv || {};

/*!
 * modernizr v3.6.0
 * Build https://modernizr.com/download?-dataview-directory-filereader-inputtypes-typedarrays-urlparser-urlsearchparams-xhrresponsetype-xhrresponsetypearraybuffer-xhrresponsetypejson-xhrresponsetypetext-dontmin
 *
 * Copyright (c)
 *  Faruk Ates
 *  Paul Irish
 *  Alex Sexton
 *  Ryan Seddon
 *  Patrick Kettner
 *  Stu Cox
 *  Richard Herrera

 * MIT License
 */

/*
 * Modernizr tests which native CSS3 and HTML5 features are available in the
 * current UA and makes the results available to you in two ways: as properties on
 * a global `Modernizr` object, and as classes on the `<html>` element. This
 * information allows you to progressively enhance your pages with a granular level
 * of control over the experience.
*/

dwv.ModernizrInit = function (window, document, undefined) {
// ;(function(window, document, undefined){
  var tests = [];


  /**
   *
   * ModernizrProto is the constructor for Modernizr
   *
   * @class
   * @access public
   */

  var ModernizrProto = {
    // The current version, dummy
    _version: '3.6.0',

    // Any settings that don't work as separate modules
    // can go in here as configuration.
    _config: {
      'classPrefix': '',
      'enableClasses': true,
      'enableJSClass': true,
      'usePrefixes': true
    },

    // Queue of tests
    _q: [],

    // Stub these for people who are listening
    on: function(test, cb) {
      // I don't really think people should do this, but we can
      // safe guard it a bit.
      // -- NOTE:: this gets WAY overridden in src/addTest for actual async tests.
      // This is in case people listen to synchronous tests. I would leave it out,
      // but the code to *disallow* sync tests in the real version of this
      // function is actually larger than this.
      var self = this;
      setTimeout(function() {
        cb(self[test]);
      }, 0);
    },

    addTest: function(name, fn, options) {
      tests.push({name: name, fn: fn, options: options});
    },

    addAsyncTest: function(fn) {
      tests.push({name: null, fn: fn});
    }
  };



  // Fake some of Object.create so we can force non test results to be non "own" properties.
  var Modernizr = function() {};
  Modernizr.prototype = ModernizrProto;

  // Leak modernizr globally when you `require` it rather than force it here.
  // Overwrite name so constructor name is nicer :D
  Modernizr = new Modernizr();


/*!
{
  "name": "DataView",
  "property": "dataview",
  "authors": ["Addy Osmani"],
  "builderAliases": ["dataview_api"],
  "notes": [{
    "name": "MDN documentation",
    "href": "https://developer.mozilla.org/en/JavaScript_typed_arrays/DataView"
  }],
  "polyfills": ["jdataview"]
}
!*/
/* DOC
Detects support for the DataView interface for reading data from an ArrayBuffer as part of the Typed Array spec.
*/

  Modernizr.addTest('dataview', (typeof DataView !== 'undefined' && 'getFloat64' in DataView.prototype));

/*!
{
  "name": "Typed arrays",
  "property": "typedarrays",
  "caniuse": "typedarrays",
  "tags": ["js"],
  "authors": ["Stanley Stuart (@fivetanley)"],
  "notes": [{
    "name": "MDN documentation",
    "href": "https://developer.mozilla.org/en-US/docs/JavaScript_typed_arrays"
  },{
    "name": "Kronos spec",
    "href": "https://www.khronos.org/registry/typedarray/specs/latest/"
  }],
  "polyfills": ["joshuabell-polyfill"]
}
!*/
/* DOC
Detects support for native binary data manipulation via Typed Arrays in JavaScript.

Does not check for DataView support; use `Modernizr.dataview` for that.
*/

  // Should fail in:
  // Internet Explorer <= 9
  // Firefox <= 3.6
  // Chrome <= 6.0
  // iOS Safari < 4.2
  // Safari < 5.1
  // Opera < 11.6
  // Opera Mini, <= 7.0
  // Android Browser < 4.0
  // Blackberry Browser < 10.0

  Modernizr.addTest('typedarrays', 'ArrayBuffer' in window);

/*!
{
  "name": "File API",
  "property": "filereader",
  "caniuse": "fileapi",
  "notes": [{
    "name": "W3C Working Draft",
    "href": "https://www.w3.org/TR/FileAPI/"
  }],
  "tags": ["file"],
  "builderAliases": ["file_api"],
  "knownBugs": ["Will fail in Safari 5 due to its lack of support for the standards defined FileReader object"]
}
!*/
/* DOC
`filereader` tests for the File API specification

Tests for objects specific to the File API W3C specification without
being redundant (don't bother testing for Blob since it is assumed
to be the File object's prototype.)
*/

  Modernizr.addTest('filereader', !!(window.File && window.FileList && window.FileReader));

/*!
{
  "name": "XHR responseType",
  "property": "xhrresponsetype",
  "tags": ["network"],
  "notes": [{
    "name": "XMLHttpRequest Living Standard",
    "href": "https://xhr.spec.whatwg.org/#the-responsetype-attribute"
  }]
}
!*/
/* DOC
Tests for XMLHttpRequest xhr.responseType.
*/

  Modernizr.addTest('xhrresponsetype', (function() {
    if (typeof XMLHttpRequest == 'undefined') {
      return false;
    }
    var xhr = new XMLHttpRequest();
    xhr.open('get', '/', true);
    return 'response' in xhr;
  }()));

/*!
{
  "name": "URL parser",
  "property": "urlparser",
  "notes": [{
    "name": "URL",
    "href": "https://dvcs.w3.org/hg/url/raw-file/tip/Overview.html"
  }],
  "polyfills": ["urlparser"],
  "authors": ["Ron Waldon (@jokeyrhyme)"],
  "tags": ["url"]
}
!*/
/* DOC
Check if browser implements the URL constructor for parsing URLs.
*/

  Modernizr.addTest('urlparser', function() {
    var url;
    try {
      // have to actually try use it, because Safari defines a dud constructor
      url = new URL('http://modernizr.com/');
      return url.href === 'http://modernizr.com/';
    } catch (e) {
      return false;
    }
  });

/*!
{
  "authors": ["Cătălin Mariș"],
  "name": "URLSearchParams API",
  "notes": [
    {
      "name": "WHATWG specification",
      "href": "https://url.spec.whatwg.org/#interface-urlsearchparams"
    },
    {
      "name": "MDN documentation",
      "href": "https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams"
    }
  ],
  "property": "urlsearchparams",
  "tags": ["querystring", "url"]
}
!*/

/* DOC
Detects support for an API that provides utility methods for working with the query string of a URL.
*/


  Modernizr.addTest('urlsearchparams', 'URLSearchParams' in window);


  var classes = [];


  /**
   * is returns a boolean if the typeof an obj is exactly type.
   *
   * @access private
   * @function is
   * @param {*} obj - A thing we want to check the type of
   * @param {string} type - A string to compare the typeof against
   * @returns {boolean}
   */

  function is(obj, type) {
    return typeof obj === type;
  }
  ;

  /**
   * Run through all tests and detect their support in the current UA.
   *
   * @access private
   */

  function testRunner() {
    var featureNames;
    var feature;
    var aliasIdx;
    var result;
    var nameIdx;
    var featureName;
    var featureNameSplit;

    for (var featureIdx in tests) {
      if (tests.hasOwnProperty(featureIdx)) {
        featureNames = [];
        feature = tests[featureIdx];
        // run the test, throw the return value into the Modernizr,
        // then based on that boolean, define an appropriate className
        // and push it into an array of classes we'll join later.
        //
        // If there is no name, it's an 'async' test that is run,
        // but not directly added to the object. That should
        // be done with a post-run addTest call.
        if (feature.name) {
          featureNames.push(feature.name.toLowerCase());

          if (feature.options && feature.options.aliases && feature.options.aliases.length) {
            // Add all the aliases into the names list
            for (aliasIdx = 0; aliasIdx < feature.options.aliases.length; aliasIdx++) {
              featureNames.push(feature.options.aliases[aliasIdx].toLowerCase());
            }
          }
        }

        // Run the test, or use the raw value if it's not a function
        result = is(feature.fn, 'function') ? feature.fn() : feature.fn;


        // Set each of the names on the Modernizr object
        for (nameIdx = 0; nameIdx < featureNames.length; nameIdx++) {
          featureName = featureNames[nameIdx];
          // Support dot properties as sub tests. We don't do checking to make sure
          // that the implied parent tests have been added. You must call them in
          // order (either in the test, or make the parent test a dependency).
          //
          // Cap it to TWO to make the logic simple and because who needs that kind of subtesting
          // hashtag famous last words
          featureNameSplit = featureName.split('.');

          if (featureNameSplit.length === 1) {
            Modernizr[featureNameSplit[0]] = result;
          } else {
            // cast to a Boolean, if not one already
            if (Modernizr[featureNameSplit[0]] && !(Modernizr[featureNameSplit[0]] instanceof Boolean)) {
              Modernizr[featureNameSplit[0]] = new Boolean(Modernizr[featureNameSplit[0]]);
            }

            Modernizr[featureNameSplit[0]][featureNameSplit[1]] = result;
          }

          classes.push((result ? '' : 'no-') + featureNameSplit.join('-'));
        }
      }
    }
  }
  ;

  /**
   * docElement is a convenience wrapper to grab the root element of the document
   *
   * @access private
   * @returns {HTMLElement|SVGElement} The root element of the document
   */

  var docElement = document.documentElement;


  /**
   * http://mathiasbynens.be/notes/xhr-responsetype-json#comment-4
   *
   * @access private
   * @function testXhrType
   * @param {string} type - String name of the XHR type you want to detect
   * @returns {boolean}
   * @author Mathias Bynens
   */

  /* istanbul ignore next */
  var testXhrType = function(type) {
    if (typeof XMLHttpRequest == 'undefined') {
      return false;
    }
    var xhr = new XMLHttpRequest();
    xhr.open('get', '/', true);
    try {
      xhr.responseType = type;
    } catch (error) {
      return false;
    }
    return 'response' in xhr && xhr.responseType == type;
  };


/*!
{
  "name": "XHR responseType='arraybuffer'",
  "property": "xhrresponsetypearraybuffer",
  "tags": ["network"],
  "notes": [{
    "name": "XMLHttpRequest Living Standard",
    "href": "https://xhr.spec.whatwg.org/#the-responsetype-attribute"
  }]
}
!*/
/* DOC
Tests for XMLHttpRequest xhr.responseType='arraybuffer'.
*/

  Modernizr.addTest('xhrresponsetypearraybuffer', testXhrType('arraybuffer'));

/*!
{
  "name": "XHR responseType='json'",
  "property": "xhrresponsetypejson",
  "tags": ["network"],
  "notes": [{
    "name": "XMLHttpRequest Living Standard",
    "href": "https://xhr.spec.whatwg.org/#the-responsetype-attribute"
  },{
    "name": "Explanation of xhr.responseType='json'",
    "href": "https://mathiasbynens.be/notes/xhr-responsetype-json"
  }]
}
!*/
/* DOC
Tests for XMLHttpRequest xhr.responseType='json'.
*/

  Modernizr.addTest('xhrresponsetypejson', testXhrType('json'));

/*!
{
  "name": "XHR responseType='text'",
  "property": "xhrresponsetypetext",
  "tags": ["network"],
  "notes": [{
    "name": "XMLHttpRequest Living Standard",
    "href": "https://xhr.spec.whatwg.org/#the-responsetype-attribute"
  }]
}
!*/
/* DOC
Tests for XMLHttpRequest xhr.responseType='text'.
*/

  Modernizr.addTest('xhrresponsetypetext', testXhrType('text'));


  /**
   * A convenience helper to check if the document we are running in is an SVG document
   *
   * @access private
   * @returns {boolean}
   */

  var isSVG = docElement.nodeName.toLowerCase() === 'svg';


  /**
   * createElement is a convenience wrapper around document.createElement. Since we
   * use createElement all over the place, this allows for (slightly) smaller code
   * as well as abstracting away issues with creating elements in contexts other than
   * HTML documents (e.g. SVG documents).
   *
   * @access private
   * @function createElement
   * @returns {HTMLElement|SVGElement} An HTML or SVG element
   */

  function createElement() {
    if (typeof document.createElement !== 'function') {
      // This is the case in IE7, where the type of createElement is "object".
      // For this reason, we cannot call apply() as Object is not a Function.
      return document.createElement(arguments[0]);
    } else if (isSVG) {
      return document.createElementNS.call(document, 'http://www.w3.org/2000/svg', arguments[0]);
    } else {
      return document.createElement.apply(document, arguments);
    }
  }

  ;

  /**
   * since we have a fairly large number of input tests that don't mutate the input
   * we create a single element that can be shared with all of those tests for a
   * minor perf boost
   *
   * @access private
   * @returns {HTMLInputElement}
   */
  var inputElem = createElement('input');

/*!
{
  "name": "Form input types",
  "property": "inputtypes",
  "caniuse": "forms",
  "tags": ["forms"],
  "authors": ["Mike Taylor"],
  "polyfills": [
    "jquerytools",
    "webshims",
    "h5f",
    "webforms2",
    "nwxforms",
    "fdslider",
    "html5slider",
    "galleryhtml5forms",
    "jscolor",
    "html5formshim",
    "selectedoptionsjs",
    "formvalidationjs"
  ]
}
!*/
/* DOC
Detects support for HTML5 form input types and exposes Boolean subproperties with the results:

```javascript
Modernizr.inputtypes.color
Modernizr.inputtypes.date
Modernizr.inputtypes.datetime
Modernizr.inputtypes['datetime-local']
Modernizr.inputtypes.email
Modernizr.inputtypes.month
Modernizr.inputtypes.number
Modernizr.inputtypes.range
Modernizr.inputtypes.search
Modernizr.inputtypes.tel
Modernizr.inputtypes.time
Modernizr.inputtypes.url
Modernizr.inputtypes.week
```
*/

  // Run through HTML5's new input types to see if the UA understands any.
  //   This is put behind the tests runloop because it doesn't return a
  //   true/false like all the other tests; instead, it returns an object
  //   containing each input type with its corresponding true/false value

  // Big thanks to @miketaylr for the html5 forms expertise. miketaylr.com/
  var inputtypes = 'search tel url email datetime date month week time datetime-local number range color'.split(' ');
  var inputs = {};

  Modernizr.inputtypes = (function(props) {
    var len = props.length;
    var smile = '1)';
    var inputElemType;
    var defaultView;
    var bool;

    for (var i = 0; i < len; i++) {

      inputElem.setAttribute('type', inputElemType = props[i]);
      bool = inputElem.type !== 'text' && 'style' in inputElem;

      // We first check to see if the type we give it sticks..
      // If the type does, we feed it a textual value, which shouldn't be valid.
      // If the value doesn't stick, we know there's input sanitization which infers a custom UI
      if (bool) {

        inputElem.value         = smile;
        inputElem.style.cssText = 'position:absolute;visibility:hidden;';

        if (/^range$/.test(inputElemType) && inputElem.style.WebkitAppearance !== undefined) {

          docElement.appendChild(inputElem);
          defaultView = document.defaultView;

          // Safari 2-4 allows the smiley as a value, despite making a slider
          bool =  defaultView.getComputedStyle &&
            defaultView.getComputedStyle(inputElem, null).WebkitAppearance !== 'textfield' &&
            // Mobile android web browser has false positive, so must
            // check the height to see if the widget is actually there.
            (inputElem.offsetHeight !== 0);

          docElement.removeChild(inputElem);

        } else if (/^(search|tel)$/.test(inputElemType)) {
          // Spec doesn't define any special parsing or detectable UI
          //   behaviors so we pass these through as true

          // Interestingly, opera fails the earlier test, so it doesn't
          //  even make it here.

        } else if (/^(url|email)$/.test(inputElemType)) {
          // Real url and email support comes with prebaked validation.
          bool = inputElem.checkValidity && inputElem.checkValidity() === false;

        } else {
          // If the upgraded input compontent rejects the :) text, we got a winner
          bool = inputElem.value != smile;
        }
      }

      inputs[ props[i] ] = !!bool;
    }
    return inputs;
  })(inputtypes);


  /**
   * If the browsers follow the spec, then they would expose vendor-specific styles as:
   *   elem.style.WebkitBorderRadius
   * instead of something like the following (which is technically incorrect):
   *   elem.style.webkitBorderRadius

   * WebKit ghosts their properties in lowercase but Opera & Moz do not.
   * Microsoft uses a lowercase `ms` instead of the correct `Ms` in IE8+
   *   erik.eae.net/archives/2008/03/10/21.48.10/

   * More here: github.com/Modernizr/Modernizr/issues/issue/21
   *
   * @access private
   * @returns {string} The string representing the vendor-specific style properties
   */

  var omPrefixes = 'Moz O ms Webkit';


  /**
   * List of JavaScript DOM values used for tests
   *
   * @memberof Modernizr
   * @name Modernizr._domPrefixes
   * @optionName Modernizr._domPrefixes
   * @optionProp domPrefixes
   * @access public
   * @example
   *
   * Modernizr._domPrefixes is exactly the same as [_prefixes](#modernizr-_prefixes), but rather
   * than kebab-case properties, all properties are their Capitalized variant
   *
   * ```js
   * Modernizr._domPrefixes === [ "Moz", "O", "ms", "Webkit" ];
   * ```
   */

  var domPrefixes = (ModernizrProto._config.usePrefixes ? omPrefixes.toLowerCase().split(' ') : []);
  ModernizrProto._domPrefixes = domPrefixes;

/*!
{
  "name": "input[directory] Attribute",
  "property": "directory",
  "authors": ["silverwind"],
  "tags": ["file", "input", "attribute"]
}
!*/
/* DOC
When used on an `<input type="file">`, the `directory` attribute instructs
the user agent to present a directory selection dialog instead of the usual
file selection dialog.
*/

  Modernizr.addTest('fileinputdirectory', function() {
    var elem = createElement('input'), dir = 'directory';
    elem.type = 'file';
    if (dir in elem) {
      return true;
    } else {
      for (var i = 0, len = domPrefixes.length; i < len; i++) {
        if (domPrefixes[i] + dir in elem) {
          return true;
        }
      }
    }
    return false;
  });


  // Run each test
  testRunner();

  delete ModernizrProto.addTest;
  delete ModernizrProto.addAsyncTest;

  // Run the things that are supposed to run after the tests
  for (var i = 0; i < Modernizr._q.length; i++) {
    Modernizr._q[i]();
  }

  // Leak Modernizr namespace
  // window.Modernizr = Modernizr;
  dwv.Modernizr = Modernizr;


;

// })(window, document);
};

// namespaces
var dwv = dwv || {};
dwv.utils = dwv.utils || {};

/**
 * Check if the input is a generic object, including arrays.
 *
 * @param {*} unknown The input to check.
 * @returns {boolean} True if the input is an object.
 * ref: https://github.com/jashkenas/underscore/blob/1.9.1/underscore.js#L1319-L1323
 */
dwv.utils.isObject = function (unknown) {
  var type = typeof unknown;
  return type === 'function' || type === 'object' && !!unknown;
};

/**
 * Check if the input is an array.
 *
 * @param {*} unknown The input to check.
 * @returns {boolean} True if the input is an array.
 * ref: https://github.com/jashkenas/underscore/blob/1.9.1/underscore.js#L1313-L1317
 */
dwv.utils.isArray = function (unknown) {
  return Array.isArray(unknown);
};

/**
 * Dump an object to an array.
 *
 * @param {object} obj The input object as: {key0: {}, key1: {}}
 * @returns {Array} The corresponding array:
 *   [{name: key0, {}}, {name: key1, {}}]
 */
dwv.utils.objectToArray = function (obj) {
  var array = [];
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; ++i) {
    var key = keys[i];
    if (obj[key] === null) {
      continue;
    }
    var row = {name: key};
    var innerKeys = Object.keys(obj[key]);
    for (var j = 0; j < innerKeys.length; ++j) {
      var innerKey = innerKeys[j];
      var value = obj[key][innerKey];
      if (dwv.utils.isArray(value)) {
        var arrayValues = [];
        for (var k = 0; k < value.length; ++k) {
          if (dwv.utils.isObject(value[k])) {
            arrayValues.push(dwv.utils.objectToArray(value[k]));
          } else {
            arrayValues.push(value[k]);
          }
        }
        value = arrayValues;
      } else if (dwv.utils.isObject(value)) {
        value = dwv.utils.objectToArray(value);
      }
      row[innerKey] = value;
    }
    array.push(row);
  }
  return array;
};

/**
 * Merge two similar objects.
 * Objects need to be in the form of:
 * <code>
 * {
 *   idKey: {valueKey: 0},
 *   key0: {valueKey: "abc"},
 *   key1: {valueKey: 33}
 * }
 * </code>
 * Merged objects will be in the form of:
 * <code>
 * {
 *   idKey: {valueKey: [0,1,2], merged: true},
 *   key0: {valueKey: {
 *     0: {valueKey: "abc"},
 *     1: {valueKey: "def"},
 *     2: {valueKey: "ghi"}
 *   }},
 *   key1: {valueKey: {
 *     0: {valueKey: 33},
 *     1: {valueKey: 44},
 *     2: {valueKey: 55}
 *   }}
 * }
 * </code>
 *
 * @param {object} obj1 The first object, can be the result of a previous merge.
 * @param {object} obj2 The second object.
 * @param {string} idKey The key to use as index for duplicate values.
 * @param {string} valueKey The key to use to access object values.
 * @returns {object} The merged object.
 */
dwv.utils.mergeObjects = function (obj1, obj2, idKey, valueKey) {
  var res = {};
  // check id key
  if (!idKey) {
    throw new Error('Cannot merge object with an undefined id key: ' + idKey);
  } else {
    if (!Object.prototype.hasOwnProperty.call(obj1, idKey)) {
      throw new Error('Id key not found in first object while merging: ' +
                idKey + ', obj: ' + obj1);
    }
    if (!Object.prototype.hasOwnProperty.call(obj2, idKey)) {
      throw new Error('Id key not found in second object while merging: ' +
                idKey + ', obj: ' + obj2);
    }
  }
  // check value key
  if (!valueKey) {
    throw new Error('Cannot merge object with an undefined value key: ' +
      valueKey);
  }

  // check if merged object
  var mergedObj1 = false;
  if (Object.prototype.hasOwnProperty.call(obj1[idKey], 'merged') &&
    obj1[idKey].merged) {
    mergedObj1 = true;
  }
  // handle the id part
  if (!Object.prototype.hasOwnProperty.call(obj1[idKey], valueKey)) {
    throw new Error('Id value not found in first object while merging: ' +
            idKey + ', valueKey: ' + valueKey + ', ojb: ' + obj1);
  }
  if (!Object.prototype.hasOwnProperty.call(obj2[idKey], valueKey)) {
    throw new Error('Id value not found in second object while merging: ' +
            idKey + ', valueKey: ' + valueKey + ', ojb: ' + obj2);
  }
  var id1 = obj1[idKey][valueKey];
  var id2 = obj2[idKey][valueKey];
  // for merged object, id1 is an array
  if (mergedObj1) {
    // check if array does not include id2
    for (var k = 0; k < id1.length; ++k) {
      if (id1[k] === id2) {
        throw new Error('The first object already contains id2: ' +
                    id2 + ', id1: ' + id1);
      }
    }
    res[idKey] = obj1[idKey];
    res[idKey][valueKey].push(id2);
  } else {
    if (id1 === id2) {
      throw new Error('Cannot merge object with same ids: ' +
                id1 + ', id2: ' + id2);
    }
    // create merge object
    res[idKey] = {value: [id1, id2], merged: true};
  }

  // get keys
  var keys1 = Object.keys(obj1);
  // keys2 without duplicates of keys1
  var keys2 = Object.keys(obj2).filter(function (item) {
    return keys1.indexOf(item) < 0;
  });
  var keys = keys1.concat(keys2);

  // loop through keys
  for (var i = 0, leni = keys.length; i < leni; ++i) {
    var key = keys[i];
    if (key !== idKey) {
      // first
      var value1 = null;
      var subValue1 = null;
      if (Object.prototype.hasOwnProperty.call(obj1, key)) {
        value1 = obj1[key];
        if (Object.prototype.hasOwnProperty.call(value1, valueKey)) {
          subValue1 = value1[valueKey];
        }
      }
      // second
      var value2 = null;
      var subValue2 = null;
      if (Object.prototype.hasOwnProperty.call(obj2, key)) {
        value2 = obj2[key];
        if (Object.prototype.hasOwnProperty.call(value2, valueKey)) {
          subValue2 = value2[valueKey];
        }
      }
      // result value
      var value;
      // create merge object if different values
      if (subValue2 !== subValue1) {
        value = {};
        // add to merged object or create new
        if (mergedObj1) {
          if (dwv.utils.isObject(subValue1)) {
            value[valueKey] = subValue1;
          } else {
            // merged object with repeated value
            // copy it with the index list
            value[valueKey] = {};
            for (var j = 0; j < id1.length; j++) {
              value[valueKey][id1[j]] = value1;
            }
          }
          // add obj2 value
          value[valueKey][id2] = value2;
        } else {
          // create merge object
          var newValue = {};
          newValue[id1] = value1;
          newValue[id2] = value2;
          value[valueKey] = newValue;
        }
      } else {
        value = value1;
      }
      // store value in result object
      res[key] = value;
    }
  }
  return res;
};

// namespaces
var dwv = dwv || {};
dwv.utils = dwv.utils || {};

/**
 * Multiple progresses handler.
 * Stores a multi dimensional list of progresses to allow to
 * calculate a global progress.
 *
 * @param {Function} callback The function to pass the global progress to.
 */
dwv.utils.MultiProgressHandler = function (callback) {
  // closure to self
  var self = this;

  /**
   * List of progresses.
   * First dimension is a list of item for which the progress is recorded,
   *   for example file names.
   * Second dimension is a list of possible progresses, for example
   *   the progress of the download and the progress of the decoding.
   *
   * @private
   * @type {Array}
   */
  var progresses = [];

  /**
   * Number of dimensions.
   *
   * @private
   * @type {number}
   */
  var numberOfDimensions = 2;

  /**
   * Set the number of dimensions.
   *
   * @param {number} num The number.
   */
  this.setNumberOfDimensions = function (num) {
    numberOfDimensions = num;
  };

  /**
   * Set the number of data to load.
   *
   * @param {number} n The number of data to load.
   */
  this.setNToLoad = function (n) {
    for (var i = 0; i < n; ++i) {
      progresses[i] = [];
      for (var j = 0; j < numberOfDimensions; ++j) {
        progresses[i][j] = 0;
      }
    }
  };

  /**
   * Handle a load progress.
   * Call the member callback with a global event.
   *
   * @param {object} event The progress event.
   */
  this.onprogress = function (event) {
    // check event
    if (!event.lengthComputable) {
      return;
    }
    if (typeof event.subindex === 'undefined') {
      return;
    }
    if (typeof event.index === 'undefined') {
      return;
    }
    // calculate percent
    var percent = (event.loaded * 100) / event.total;
    // set percent for index
    progresses[event.index][event.subindex] = percent;

    // item progress
    var item = null;
    if (typeof event.item !== 'undefined') {
      item = event.item;
    } else {
      item = {
        loaded: getItemProgress(event.index),
        total: 100,
        source: event.source
      };
    }

    // call callback with a global event
    callback({
      lengthComputable: true,
      loaded: getGlobalPercent(),
      total: 100,
      item: item
    });
  };

  /**
   * Get the item load percent.
   *
   * @param {number} index The index of the item.
   * @returns {number} The load percentage.
   * @private
   */
  function getItemProgress(index) {
    var sum = 0;
    for (var j = 0; j < numberOfDimensions; ++j) {
      sum += progresses[index][j];
    }
    return sum / numberOfDimensions;
  }

  /**
   * Get the global load percent including the provided one.
   *
   * @returns {number} The accumulated percentage.
   * @private
   */
  function getGlobalPercent() {
    var sum = 0;
    var lenprog = progresses.length;
    for (var i = 0; i < lenprog; ++i) {
      sum += getItemProgress(i);
    }
    return Math.round(sum / lenprog);
  }

  /**
   * Create a mono progress event handler.
   *
   * @param {number} index The index of the data.
   * @param {number} subindex The sub-index of the data.
   * @returns {Function} A progress handler function.
   */
  this.getMonoProgressHandler = function (index, subindex) {
    return function (event) {
      event.index = index;
      event.subindex = subindex;
      self.onprogress(event);
    };
  };

  /**
   * Create a mono progress event handler with an undefined index.
   * Warning: The caller handles the progress index.
   *
   * @param {number} subindex The sub-index of the data.
   * @returns {Function} A progress handler function.
   */
  this.getUndefinedMonoProgressHandler = function (subindex) {
    return function (event) {
      event.subindex = subindex;
      self.onprogress(event);
    };
  };
};

// namespaces
var dwv = dwv || {};
dwv.utils = dwv.utils || {};

/**
 * Capitalise the first letter of a string.
 *
 * @param {string} string The string to capitalise the first letter.
 * @returns {string} The new string.
 */
dwv.utils.capitaliseFirstLetter = function (string) {
  var res = string;
  if (string) {
    res = string.charAt(0).toUpperCase() + string.slice(1);
  }
  return res;
};

/**
 * Check if a string starts with the input element.
 *
 * @param {string} str The input string.
 * @param {string} search The searched start.
 * @param {number} rawPos The position in this string at which to begin
 *  searching for searchString. Defaults to 0.
 * @returns {boolean} True if the input string starts with the searched string.
 */
dwv.utils.startsWith = function (str, search, rawPos) {
  if (typeof str === 'undefined' || str === null ||
    typeof search === 'undefined' || search === null) {
    return false;
  }
  var pos = rawPos > 0 ? rawPos | 0 : 0;
  return str.substring(pos, pos + search.length) === search;
};

/**
 * Check if a string ends with the input element.
 *
 * @param {string} str The input string.
 * @param {string} search The searched ending.
 * @returns {boolean} True if the input string ends with the searched string.
 */
dwv.utils.endsWith = function (str, search) {
  if (typeof str === 'undefined' || str === null ||
    typeof search === 'undefined' || search === null) {
    return false;
  }
  return str.substring(str.length - search.length) === search;
};

/**
 * Split key/value string:
 *  key0=val00&key0=val01&key1=val10 returns
 *  { key0 : [val00, val01], key1 : val1 }
 *
 * @param {string} inputStr The string to split.
 * @returns {object} The split string.
 */
dwv.utils.splitKeyValueString = function (inputStr) {
  // result
  var result = {};
  // check input string
  if (inputStr) {
    // split key/value pairs
    var pairs = inputStr.split('&');
    for (var i = 0; i < pairs.length; ++i) {
      var pair = pairs[i].split('=');
      // if the key does not exist, create it
      if (!result[pair[0]]) {
        result[pair[0]] = pair[1];
      } else {
        // make it an array
        if (!(result[pair[0]] instanceof Array)) {
          result[pair[0]] = [result[pair[0]]];
        }
        result[pair[0]].push(pair[1]);
      }
    }
  }
  return result;
};

/**
 * Get flags from an input string. Flags are words surrounded with curly
 * braces.
 *
 * @param {string} inputStr The input string.
 * @returns {Array} An array of found flags.
 */
dwv.utils.getFlags = function (inputStr) {
  var flags = [];
  // check input string
  if (inputStr === null || typeof inputStr === 'undefined') {
    return flags;
  }

  // word surrounded by curly braces
  var regex = /{(\w+)}/g;

  var match = regex.exec(inputStr);
  while (match) {
    flags.push(match[1]); // first matching group
    match = regex.exec(inputStr);
  }
  return flags;
};

/**
 * Replace flags in a input string. Flags are keywords surrounded with curly
 * braces.
 *
 * @param {string} inputStr The input string.
 * @param {object} values A object of {value, unit}.
 * @example
 *    var values = {"length": { "value": 33, "unit": "cm" } };
 *    var str = "The length is: {length}.";
 *    var res = dwv.utils.replaceFlags(str, values); // "The length is: 33 cm."
 * @returns {string} The result string.
 */
dwv.utils.replaceFlags = function (inputStr, values) {
  var res = '';
  // check input string
  if (inputStr === null || typeof inputStr === 'undefined') {
    return res;
  }
  res = inputStr;
  // check values
  if (values === null || typeof values === 'undefined') {
    return res;
  }

  // loop through flags
  var keys = dwv.utils.getFlags(inputStr);
  for (var i = 0; i < keys.length; ++i) {
    var valueObj = values[keys[i]];
    if (valueObj !== null && typeof valueObj !== 'undefined' &&
      valueObj.value !== null && typeof valueObj.value !== 'undefined') {
      // value string
      var valueStr = valueObj.value.toPrecision(4);
      // add unit if available
      // space or no space? Yes apart from degree...
      // check: https://en.wikipedia.org/wiki/Space_(punctuation)#Spaces_and_unit_symbols
      if (valueObj.unit !== null &&
        typeof valueObj.unit !== 'undefined' &&
        valueObj.unit.length !== 0) {
        if (valueObj.unit !== 'degree') {
          valueStr += ' ';
        }
        valueStr += valueObj.unit;
      }
      // flag to replace
      var flag = '{' + keys[i] + '}';
      // replace
      res = res.replace(flag, valueStr);
    }
  }
  // return
  return res;
};

/**
 * Replace flags in a input string. Flags are keywords surrounded with curly
 * braces.
 *
 * @param {string} inputStr The input string.
 * @param {Array} values An array of strings.
 * @example
 *    var values = ["a", "b"];
 *    var str = "The length is: {v0}. The size is: {v1}";
 *    var res = dwv.utils.replaceFlags2(str, values);
 *    // "The length is: a. The size is: b"
 * @returns {string} The result string.
 */
dwv.utils.replaceFlags2 = function (inputStr, values) {
  var res = inputStr;
  for (var j = 0; j < values.length; ++j) {
    res = res.replace('{v' + j + '}', values[j]);
  }
  return res;
};

dwv.utils.createDefaultReplaceFormat = function (values) {
  var res = '';
  for (var j = 0; j < values.length; ++j) {
    if (j !== 0) {
      res += ', ';
    }
    res += '{v' + j + '}';
  }
  return res;
};

/**
 * Get the root of an input path.
 * Splits using `/` as separator.
 *
 * @param {string} path The input path
 * @returns {string} The input path without its last part.
 */
dwv.utils.getRootPath = function (path) {
  return path.split('/').slice(0, -1).join('/');
};

/**
 * Get a file extension: anything after the last dot.
 * File name starting with a dot are discarded.
 * Extensions are expected to contain at least one letter.
 *
 * @param {string} filePath The file path containing the file name.
 * @returns {string} The lower case file extension or null for none.
 */
dwv.utils.getFileExtension = function (filePath) {
  var ext = null;
  if (typeof filePath !== 'undefined' &&
    filePath !== null &&
    filePath[0] !== '.') {
    var pathSplit = filePath.toLowerCase().split('.');
    if (pathSplit.length !== 1) {
      ext = pathSplit.pop();
      // extension should contain at least one letter and no slash
      var regExp = /[a-z]/;
      if (!regExp.test(ext) || ext.includes('/')) {
        ext = null;
      }
    }
  }
  return ext;
};

/**
 * Convert a string to a Uint8Array.
 *
 * @param {string} str The string to convert.
 * @returns {Uint8Array} The Uint8Array.
 */
dwv.utils.stringToUint8Array = function (str) {
  var arr = new Uint8Array(str.length);
  for (var i = 0, leni = str.length; i < leni; i++) {
    arr[i] = str.charCodeAt(i);
  }
  return arr;
};

/**
 * Round a float number to a given precision.
 * Inspired from https://stackoverflow.com/a/49729715/3639892.
 * Can be a solution to not have trailing zero as when
 * using toFixed or toPrecision.
 * '+number.toFixed(precision)' does not pass all the tests...
 *
 * @param {number} number The number to round.
 * @param {number} precision The rounding precision.
 * @returns {number} The rounded number.
 */
dwv.utils.precisionRound = function (number, precision) {
  var factor = Math.pow(10, precision);
  var delta = 0.01 / factor; // fixes precisionRound(1.005, 2)
  return Math.round(number * factor + delta) / factor;
};

// namespaces
var dwv = dwv || {};
dwv.utils = dwv.utils || {};

/**
 * Thread Pool.
 * Highly inspired from {@link http://www.smartjava.org/content/html5-easily-parallelize-jobs-using-web-workers-and-threadpool}.
 *
 * @class
 * @param {number} poolSize The size of the pool.
 */
dwv.utils.ThreadPool = function (poolSize) {
  // task queue
  var taskQueue = [];
  // lsit of available threads
  var freeThreads = [];
  // create 'poolSize' number of worker threads
  for (var i = 0; i < poolSize; ++i) {
    freeThreads.push(new dwv.utils.WorkerThread(this));
  }
  // list of running threads (unsed in abort)
  var runningThreads = [];

  /**
   * Add a worker task to the queue.
   * Will be run when a thread is made available.
   *
   * @param {object} workerTask The task to add to the queue.
   */
  this.addWorkerTask = function (workerTask) {
    // send work start if first task
    if (freeThreads.length === poolSize) {
      this.onworkstart({type: 'work-start'});
    }
    // launch task or queue
    if (freeThreads.length > 0) {
      // get the first free worker thread
      var workerThread = freeThreads.shift();
      // add the thread to the runnning list
      runningThreads.push(workerThread);
      // run the input task
      workerThread.run(workerTask);
    } else {
      // no free thread, add task to queue
      taskQueue.push(workerTask);
    }
  };

  /**
   * Abort all threads.
   */
  this.abort = function () {
    // stop all threads
    stop();
    // callback
    this.onabort({type: 'work-abort'});
    this.onworkend({type: 'work-end'});
  };

  /**
   * Handle a task end.
   *
   * @param {object} workerThread The thread to free.
   */
  this.onTaskEnd = function (workerThread) {
    // launch next task in queue or finish
    if (taskQueue.length > 0) {
      // get waiting task
      var workerTask = taskQueue.shift();
      // use input thread to run the waiting task
      workerThread.run(workerTask);
    } else {
      // stop the worker
      workerThread.stop();
      // no task to run, add to free list
      freeThreads.push(workerThread);
      // remove from running list
      for (var i = 0; i < runningThreads.length; ++i) {
        if (runningThreads[i].getId() === workerThread.getId()) {
          runningThreads.splice(i, 1);
        }
      }
      // the work is done when the queue is back to its initial size
      if (freeThreads.length === poolSize) {
        this.onwork({type: 'work'});
        this.onworkend({type: 'work-end'});
      }
    }
  };

  /**
   * Handle an error message from a worker.
   *
   * @param {object} event The error event.
   */
  this.handleWorkerError = function (event) {
    // stop all threads
    stop();
    // callback
    this.onerror({error: event});
    this.onworkend({type: 'work-end'});
  };

  // private ----------------------------------------------------------------

  /**
   * Stop the pool: stop all running threads.
   *
   * @private
   */
  function stop() {
    // clear tasks
    taskQueue = [];
    // cancel running workers
    for (var i = 0; i < runningThreads.length; ++i) {
      runningThreads[i].stop();
    }
    runningThreads = [];
  }

}; // ThreadPool

/**
 * Handle a work start event.
 * Default does nothing.
 *
 * @param {object} _event The work start event.
 */
dwv.utils.ThreadPool.prototype.onworkstart = function (_event) {};
/**
 * Handle a work item event.
 * Default does nothing.
 *
 * @param {object} _event The work item event fired
 *   when a work item ended successfully.
 */
dwv.utils.ThreadPool.prototype.onworkitem = function (_event) {};
/**
 * Handle a work event.
 * Default does nothing.
 *
 * @param {object} _event The work event fired
 *   when a work ended successfully.
 */
dwv.utils.ThreadPool.prototype.onwork = function (_event) {};
/**
 * Handle a work end event.
 * Default does nothing.
 *
 * @param {object} _event The work end event fired
 *  when a work has completed, successfully or not.
 */
dwv.utils.ThreadPool.prototype.onworkend = function (_event) {};
/**
 * Handle an error event.
 * Default does nothing.
 *
 * @param {object} _event The error event.
 */
dwv.utils.ThreadPool.prototype.onerror = function (_event) {};
/**
 * Handle an abort event.
 * Default does nothing.
 *
 * @param {object} _event The abort event.
 */
dwv.utils.ThreadPool.prototype.onabort = function (_event) {};

/**
 * Worker background task.
 *
 * @external Worker
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Worker
 */

/**
 * Worker thread.
 *
 * @class
 * @param {object} parentPool The parent pool.
 */
dwv.utils.WorkerThread = function (parentPool) {
  // closure to self
  var self = this;
  // thread ID
  var id = Math.random().toString(36).substring(2, 15);
  // running task
  var runningTask = null;
  // worker used to run task
  var worker;

  /**
   * Get the thread ID.
   *
   * @returns {string} The thread ID (alphanumeric).
   */
  this.getId = function () {
    return id;
  };

  /**
   * Run a worker task
   *
   * @param {object} workerTask The task to run.
   */
  this.run = function (workerTask) {
    // store task
    runningTask = workerTask;
    // create a new web worker if not done yet
    if (typeof worker === 'undefined') {
      worker = new Worker(runningTask.script);
      // set callbacks
      worker.onmessage = onmessage;
      worker.onerror = onerror;
    }
    // launch the worker
    worker.postMessage(runningTask.startMessage);
  };

  /**
   * Finish a task and tell the parent.
   */
  this.stop = function () {
    // stop the worker
    worker.terminate();
    // force create at next run
    worker = undefined;
  };

  /**
   * Message event handler.
   * For now assume we only get a single callback from a worker
   * which also indicates the end of this worker.
   *
   * @param {object} event The message event.
   * @private
   */
  function onmessage(event) {
    // augment event
    event.itemNumber = runningTask.info.itemNumber;
    event.numberOfItems = runningTask.info.numberOfItems;
    event.dataIndex = runningTask.info.dataIndex;
    // send event
    parentPool.onworkitem(event);
    // tell the parent pool the task is done
    parentPool.onTaskEnd(self);
  }

  /**
   * Error event handler.
   *
   * @param {object} event The error event.
   * @private
   */
  function onerror(event) {
    // augment event
    event.itemNumber = runningTask.info.itemNumber;
    event.numberOfItems = runningTask.info.numberOfItems;
    event.dataIndex = runningTask.info.dataIndex;
    // pass to parent
    parentPool.handleWorkerError(event);
    // stop the worker and free the thread
    self.stop();
  }
}; // class WorkerThread

/**
 * Worker task.
 *
 * @class
 * @param {string} script The worker script.
 * @param {object} message The data to pass to the worker.
 * @param {object} info Information object about the input data.
 */
dwv.utils.WorkerTask = function (script, message, info) {
  // worker script
  this.script = script;
  // worker start message
  this.startMessage = message;
  // information about the work data
  this.info = info;
};

// namespaces
var dwv = dwv || {};
dwv.utils = dwv.utils || {};

/**
 * Get an full object URL from a string uri.
 *
 * @param {string} uri A string representing the url.
 * @returns {URL} A URL object.
 * WARNING: platform support dependent, see https://caniuse.com/#feat=url
 */
dwv.utils.getUrlFromUriFull = function (uri) {
  // add base to allow for relative urls
  // (base is not used for absolute urls)
  return new URL(uri, window.location.origin);
};

/**
 * Get an simple object URL from a string uri.
 *
 * @param {string} uri A string representing the url.
 * @returns {URL} A simple URL object that exposes 'pathname' and
 *   'searchParams.get()'
 * WARNING: limited functionality, simple nmock of the URL object.
 */
dwv.utils.getUrlFromUriSimple = function (uri) {
  var url = {};
  // simple implementation (mainly for IE)
  // expecting only one '?'
  var urlSplit = uri.split('?');
  // pathname
  var fullPath = urlSplit[0];
  // remove host and domain
  var fullPathSplit = fullPath.split('//');
  var hostAndPath = fullPathSplit.pop();
  var hostAndPathSplit = hostAndPath.split('/');
  hostAndPathSplit.splice(0, 1);
  url.pathname = '/' + hostAndPathSplit.join('/');
  // search params
  var searchSplit = [];
  if (urlSplit.length === 2) {
    var search = urlSplit[1];
    searchSplit = search.split('&');
  }
  var searchParams = {};
  for (var i = 0; i < searchSplit.length; ++i) {
    var paramSplit = searchSplit[i].split('=');
    searchParams[paramSplit[0]] = paramSplit[1];
  }
  url.searchParams = {
    get: function (param) {
      return searchParams[param];
    }
  };

  return url;
};

/**
 * Get an object URL from a string uri.
 *
 * @param {string} uri A string representing the url.
 * @returns {URL} A URL object (full or simple depending upon platform).
 * WANRING: returns an official URL or a simple URL depending on platform,
 *   see https://caniuse.com/#feat=url
 */
dwv.utils.getUrlFromUri = function (uri) {
  var url = null;
  if (dwv.env.askModernizr('urlparser') &&
        dwv.env.askModernizr('urlsearchparams')) {
    url = dwv.utils.getUrlFromUriFull(uri);
  } else {
    url = dwv.utils.getUrlFromUriSimple(uri);
  }
  return url;
};

/**
 * Split an input URI:
 * 'root?key0=val00&key0=val01&key1=val10' returns
 * { base : root, query : [ key0 : [val00, val01], key1 : val1 ] }
 * Returns an empty object if the input string is not correct (null, empty...)
 * or if it is not a query string (no question mark).
 *
 * @param {string} uri The string to split.
 * @returns {object} The split string.
 */
dwv.utils.splitUri = function (uri) {
  // result
  var result = {};
  // check if query string
  var sepIndex = null;
  if (uri && (sepIndex = uri.indexOf('?')) !== -1) {
    // base: before the '?'
    result.base = uri.substring(0, sepIndex);
    // query : after the '?' and until possible '#'
    var hashIndex = uri.indexOf('#');
    if (hashIndex === -1) {
      hashIndex = uri.length;
    }
    var query = uri.substring(sepIndex + 1, hashIndex);
    // split key/value pairs of the query
    result.query = dwv.utils.splitKeyValueString(query);
  }
  // return
  return result;
};

/**
 * Get the query part, split into an array, of an input URI.
 * The URI scheme is: 'base?query#fragment'
 *
 * @param {string} uri The input URI.
 * @returns {object} The query part, split into an array, of the input URI.
 */
dwv.utils.getUriQuery = function (uri) {
  // split
  var parts = dwv.utils.splitUri(uri);
  // check not empty
  if (Object.keys(parts).length === 0) {
    return null;
  }
  // return query
  return parts.query;
};

/**
 * Generic URI query decoder.
 * Supports manifest:
 *   [dwv root]?input=encodeURIComponent('[manifest file]')&type=manifest
 * or encoded URI with base and key value/pairs:
 *   [dwv root]?input=encodeURIComponent([root]?key0=value0&key1=value1)
 *
 * @param {string} query The query part to the input URI.
 * @param {Function} callback The function to call with the decoded file urls.
 * @param {object} options Optional url request options.
 */
dwv.utils.decodeQuery = function (query, callback, options) {
  // manifest
  if (query.type && query.type === 'manifest') {
    dwv.utils.decodeManifestQuery(query, callback);
  } else {
    // default case: encoded URI with base and key/value pairs
    callback(
      dwv.utils.decodeKeyValueUri(query.input, query.dwvReplaceMode),
      options);
  }
};

/**
 * Decode a Key/Value pair URI. If a key is repeated, the result
 * be an array of base + each key.
 *
 * @param {string} uri The URI to decode.
 * @param {string} replaceMode The key replace more.
 *   replaceMode can be:
 *   - key (default): keep the key
 *   - other than key: do not use the key
 *   'file' is a special case where the '?' of the query is not kept.
 * @returns {Array} The list of input file urls.
 */
dwv.utils.decodeKeyValueUri = function (uri, replaceMode) {
  var result = [];

  // repeat key replace mode (default to keep key)
  var repeatKeyReplaceMode = 'key';
  if (replaceMode) {
    repeatKeyReplaceMode = replaceMode;
  }

  // decode input URI
  var queryUri = decodeURIComponent(uri);
  // get key/value pairs from input URI
  var inputQueryPairs = dwv.utils.splitUri(queryUri);
  if (Object.keys(inputQueryPairs).length === 0) {
    result.push(queryUri);
  } else {
    var keys = Object.keys(inputQueryPairs.query);
    // find repeat key
    var repeatKey = null;
    for (var i = 0; i < keys.length; ++i) {
      if (inputQueryPairs.query[keys[i]] instanceof Array) {
        repeatKey = keys[i];
        break;
      }
    }

    if (!repeatKey) {
      result.push(queryUri);
    } else {
      var repeatList = inputQueryPairs.query[repeatKey];
      // build base uri
      var baseUrl = inputQueryPairs.base;
      // add '?' when:
      // - base is not empty
      // - the repeatKey is not 'file'
      // root/path/to/?file=0.jpg&file=1.jpg
      if (baseUrl !== '' && repeatKey !== 'file') {
        baseUrl += '?';
      }
      var gotOneArg = false;
      for (var j = 0; j < keys.length; ++j) {
        if (keys[j] !== repeatKey) {
          if (gotOneArg) {
            baseUrl += '&';
          }
          baseUrl += keys[j] + '=' + inputQueryPairs.query[keys[j]];
          gotOneArg = true;
        }
      }
      // append built urls to result
      var url;
      for (var k = 0; k < repeatList.length; ++k) {
        url = baseUrl;
        if (gotOneArg) {
          url += '&';
        }
        if (repeatKeyReplaceMode === 'key') {
          url += repeatKey + '=';
        }
        // other than 'key' mode: do nothing
        url += repeatList[k];
        result.push(url);
      }
    }
  }
  // return
  return result;
};

/**
 * Decode a manifest query.
 *
 * @external XMLHttpRequest
 * @param {object} query The manifest query: {input, nslices},
 * with input the input URI and nslices the number of slices.
 * @param {Function} callback The function to call with the decoded urls.
 */
dwv.utils.decodeManifestQuery = function (query, callback) {
  var uri = '';
  if (query.input[0] === '/') {
    uri = window.location.protocol + '//' + window.location.host;
  }
  // TODO: needs to be decoded (decodeURIComponent?
  uri += query.input;

  // handle error
  var onError = function (/*event*/) {
    dwv.logger.warn('RequestError while receiving manifest: ' + this.status);
  };

  // handle load
  var onLoad = function (/*event*/) {
    callback(dwv.utils.decodeManifest(this.responseXML, query.nslices));
  };

  var request = new XMLHttpRequest();
  request.open('GET', decodeURIComponent(uri), true);
  request.responseType = 'document';
  request.onload = onLoad;
  request.onerror = onError;
  request.send(null);
};

/**
 * Decode an XML manifest.
 *
 * @param {object} manifest The manifest to decode.
 * @param {number} nslices The number of slices to load.
 * @returns {Array} The decoded manifest.
 */
dwv.utils.decodeManifest = function (manifest, nslices) {
  var result = [];
  // wado url
  var wadoElement = manifest.getElementsByTagName('wado_query');
  var wadoURL = wadoElement[0].getAttribute('wadoURL');
  var rootURL = wadoURL + '?requestType=WADO&contentType=application/dicom&';
  // patient list
  var patientList = manifest.getElementsByTagName('Patient');
  if (patientList.length > 1) {
    dwv.logger.warn('More than one patient, loading first one.');
  }
  // study list
  var studyList = patientList[0].getElementsByTagName('Study');
  if (studyList.length > 1) {
    dwv.logger.warn('More than one study, loading first one.');
  }
  var studyUID = studyList[0].getAttribute('StudyInstanceUID');
  // series list
  var seriesList = studyList[0].getElementsByTagName('Series');
  if (seriesList.length > 1) {
    dwv.logger.warn('More than one series, loading first one.');
  }
  var seriesUID = seriesList[0].getAttribute('SeriesInstanceUID');
  // instance list
  var instanceList = seriesList[0].getElementsByTagName('Instance');
  // loop on instances and push links
  var max = instanceList.length;
  if (nslices < max) {
    max = nslices;
  }
  for (var i = 0; i < max; ++i) {
    var sopInstanceUID = instanceList[i].getAttribute('SOPInstanceUID');
    var link = rootURL +
        '&studyUID=' + studyUID +
        '&seriesUID=' + seriesUID +
        '&objectUID=' + sopInstanceUID;
    result.push(link);
  }
  // return
  return result;
};

/**
 * Load from an input uri
 *
 * @param {string} uri The input uri, for example: 'window.location.href'.
 * @param {dwv.App} app The associated app that handles the load.
 * @param {object} options Optional url request options.
 */
dwv.utils.loadFromUri = function (uri, app, options) {
  var query = dwv.utils.getUriQuery(uri);
  // check query
  if (query && typeof query.input !== 'undefined') {
    dwv.utils.loadFromQuery(query, app, options);
  }
  // no else to allow for empty uris
};

/**
 * Load from an input query
 *
 * @param {object} query A query derived from an uri.
 * @param {object} app The associated app that handles the load.
 * @param {object} options Optional url request options.
 */
dwv.utils.loadFromQuery = function (query, app, options) {
  // load base
  dwv.utils.decodeQuery(query, app.loadURLs, options);
  // optional display state
  if (typeof query.state !== 'undefined') {
    // queue after main data load
    var onLoadEnd = function (/*event*/) {
      app.removeEventListener('loadend', onLoadEnd);
      app.loadURLs([query.state]);
    };
    app.addEventListener('loadend', onLoadEnd);
  }
};

    return dwv;
}));
